A more complete description should be available at 
\begin{verbatim}
   http://emsl.pnl.gov:2080/docs/nwchem/nwchem.html
\end{verbatim}

The command required to invoke NWChem is machine dependent, whereas
most of the NWChem input is machine independent\footnote{Machine
dependence within the input arises from file names, machine
specific resources, and differing services provided by the operating system.} .

\section{Sequential execution}

To run NWChem sequentially on nearly all UNIX-based platforms simply
use the command \verb+nwchem+ and provide the name of the input file
as an argument (section \ref{sec:inputstructure}).

Output is to standard output, standard error and Fortran unit 6
(usually the same as standard output).  Files are created by default
in the current directory, though this may be overridden in the input
(section \ref{sec:dirs}).

\section{Parallel execution on UNIX-based parallel machines
including workstation clusters using TCGMSG}
\label{sec:procgrp}

 These platforms require the use of the TCGMSG\footnote{Where required
TCGMSG is automatically built with NWChem.} \verb+parallel+ command
and thus also require the definition of a process-group (or procgroup)
file.  The process-group file describes how many processes to start,
what program to run, which machines to use, which directories to work
in, and under which userid to run the processes.  By convention the
process-group file has a \verb+.p+ suffix.

The process-group file is read to end-of-file.  The character \verb+#+
(hash or pound sign) is used to indicate a comment which continues to
the next new-line character.  Each line describes a cluster of
processes and consists of the following whitespace separated fields:

\begin{verbatim}
  userid hostname nslave executable workdir
\end{verbatim}

\begin{itemize}
\item \verb+userid+ -- The user-name on the machine that will be executing the
      process. 

\item \verb+hostname+ --  The hostname of the machine to execute this process.
             If it is the same machine on which parallel was invoked
             the name must match the value returned by the command 
             hostname. If a remote machine it must allow remote execution
             from this machine (see man pages for rlogin, rsh).

\item \verb+nslave+ --  The total number of copies of this process to be executing
             on the specified machine. Only ``clusters'' of identical processes
             specified in this fashion can use shared memory to communicate.
             If no shared memory is supported on machine \verb+<hostname>+ then
             only the value one (1) is valid.

\item \verb+executable+ --  Full path name on the host \verb+<hostname>+ of the image to execute.
             If \verb+<hostname>+ is the local machine then a local path will
             suffice.

\item \verb+workdir+ --  Full path name on the host \verb+<hostname>+ of the directory to
             work in. Processes execute a chdir() to this directory before
             returning from pbegin(). If specified as a ``.'' then remote
             processes will use the login directory on that machine and local
             processes (relative to where parallel was invoked) will use
             the current directory of parallel.
\end{itemize}

  For example, if your file \verb+"nwchem.p"+ contained the following
\begin{verbatim}
 d3g681 pc 4 /msrc/apps/bin/nwchem /scr22/rjh
\end{verbatim}
then 4 processes running NWChem would be started on the machine 
\verb+pc+ running as user \verb+d3g681+ in directory \verb+"/scr22/rjh"+.
To actually run this simply type:
\begin{verbatim}
  parallel nwchem big_molecule.nw
\end{verbatim}

{\em N.B.} : The first process specified (process zero) is the only
process that
\begin{itemize}
\item opens and reads the input file, and
\item opens and reads/updates the database.
\end{itemize}
Thus, if your file systems are physically distributed (e.g., most
workstation clusters) you must ensure that process zero can correctly
resolve the paths for the input and database files.

{\em N.B.} : If only one cluster is specified (one line in the
process-group file) then all processes execute NWChem.  If multiple
clusters are specified (multiple lines in the process-group file)
then one process out of each cluster is devoted to sharing
global-arrays between clusters, and therefore one more process than
desired the number of application processes should be specified in
each cluster.

\section{Parallel execution on MPPs}

All of these machines require use of different commands in order to
gain exclusive access to computational resources.

\section{Kendall Square Research}

\begin{verbatim}
  allocate_cells <n> parallel nwchem <input_file>
\end{verbatim}

The KSR command \verb+allocate_cells+ is used to acquire exclusive use
of a set of processors.  It takes the number of processors \verb+n+ and
the command as arguments.  The TCGMSG parallel command is described
above (section \ref{sec:procgrp}).  Note that when running the SCF
code optimal performance is obtained by allocating one more processor
to the processor set than required by your \verb+"nwchem.p"+
file\footnote{This is because dynamic load balanced is supported by
the process executing the command parallel which needs a dedicated
processor to do this efficiently.}.  For instance, if your
process-group file \verb+"nwchem32.p"+ read
\begin{verbatim}
  d3g681 circus 31 /usr/local/bin/nwchem /tmp/rjh
\end{verbatim}
then you might use the following command
\begin{verbatim}
  allocate_cells 32 parallel nwchem32 big_molecule.nw
\end{verbatim}

A useful tool for monitoring usage of the KSR is xringinfo.  See the
manual page for details.

\section{IBM SP}

If using POE (IBM's Parallel Operating Environment) interactively,
simply create the list nodes to use in the file \verb+"host.list"+ in
the current directory and invoke NWChem with
\begin{verbatim}
  nwchem <input_file> -procs <n>
\end{verbatim}
where \verb+n+ is the number of processes to use.  Process 0 will run
on the first node in \verb+"host.list"+ and must have access to the
input and other necessary files.  Very significant performance gains
may be had by setting the following environment variables before
running NWChem (or setting them using POE command line options).
\begin{itemize}
\item \verb+setenv MP_EUILIB us+ --- dedicated user space
  communication over the switch (the default is IP over the switch
  which is much slower).
\item \verb+setenv MP_CSS_INTERRUPT yes+ --- enable interrupts when a 
  message arrives (the default is to poll which significantly slows
  down global array accesses).
\end{itemize}

For batch execution, we recommend use of the \verb+llnw+ command which
is installed in \verb+/usr/local/bin+ on the EMSL/PNNL IBM SP.
Interactive help may be obtained with the command \verb+llnw -help+.
Otherwise, the very simplest job to run NWChem in batch using Load
Leveller is something like this
\begin{verbatim}
#!/bin/csh -x
# @ job_type         =    parallel
# @ class            =    small
# @ requirements     =    (Adapter == "hps_user")
# @ input            =    /dev/null
# @ output           =    <OUTPUT_FILE_NAME>
# @ error            =    <ERROUT_FILE_NAME>
# @ environment      =    COPY_ALL; MP_EUILIB=us ; MP_CSS_INTERRUPT=yes
# @ min_processors   =    7
# @ max_processors   =    7
# @ cpu_limit        =    1:00:00
# @ queue
#

cd /scratch

nwchem <INPUT_FILE_NAME>
\end{verbatim}

Substitute \verb+<OUTPUT_FILE_NAME>+, \verb+<ERROUT_FILE_NAME>+ and
\verb+<INPUT_FILE_NAME>+ with the {\em full} path of the appropriate
files.  These files and the NWChem executable must be in a file system
accessible to all processes.  Put the above into a file (e.g.,
\verb+"test.job"+) and submit it with the command
\begin{verbatim}
  llsubmit test.job
\end{verbatim}
It will run a 7 processor, 1 hour job in the queue \verb+small+.  It
should be apparent how to change these values.

Unfortunately, this simple job becomes very inefficient when running
on many nodes (taking up to 15 minutes to commence execution) because
POE saturates networked file systems when copying the executable to
all of the nodes.  There is a script \verb+llnw+ that may be invoked
either as a one line command or with interactive prompting that
automates job creation and submission, and, by efficient copying of the
executable, reduces startup time to about 1 minute.

Note that on many IBM SPs, including that at EMSL, the local scratch
disks are wiped clean at the beginning of each job and therefore
persistent files should be stored elsewhere.  PIOFS is recommended for
files larger than 1--2 MB.

\section{Intel Paragon}

\begin{verbatim}
  nwchem -sz <n> <input_file>
\end{verbatim}

or if pexec is used (e.g., at ORNL)

\begin{verbatim}
  pexec nwchem <input_file> -sz <n>
\end{verbatim}

where \verb+n+ is the number of processors and \verb+input_file+ is the
name of your input file.


\section{Intel Touchstone Delta}

\begin{verbatim}
  mexec -t"(<rows>,<cols>)" -f "nwchem <input_file>"
\end{verbatim}

where \verb+rows+ and \verb+cols+ specify the dimensions of the
processor mesh and \verb+input_file+ is the name of your input file.
For example, to run using all 512 nodes on the Delta
\begin{verbatim}
  mexec -t"(16,32)" -f "nwchem big_molecule.nw"
\end{verbatim}

\section{Cray T3D}

\begin{verbatim}
  nwchem  <input_file> -npes <n>
\end{verbatim}

where \verb+n+ is the number of processors and \verb+input_file+ is the
name of your input file.

When compiling NWChem on the Cray T3D, you need to setup the
environmental variable {\tt TARGET} for the correct cross-compilation
of C routines by typing
\begin{verbatim}
  setenv TARGET CRAY-T3D
\end{verbatim}

\section{Tested Platforms and O/S versions}

\begin{itemize}
\item KSR-2 
\item Intel Delta 
\item Intel Paragon 
\item IBM SP1 and SP2, AIX 3.2 and 4.1.
\item Cray T3D
\item SGI R8000
\item SGI R4000
\item IBM RS6000, AIX 3.2 and 4.1.
\item SUN workstations, SunOS 4.1.3 and Solaris 5.5
\item x86 computers running Linux 1.2.13 works
\end{itemize}
