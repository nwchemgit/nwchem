                Standard Integral File Structure Documentation
                 Written by Ron Shepard (shepard@tcg.anl.gov)
                         version date: 08-nov-1990 -rls
                                       30-jun-1998 -rmp

The Standard Integral File Structure (SIFS) is used by the COLUMBUS Program
System to store 2-index and 4-index integral and density matrix arrays and
to transfer these arrays between individual programs.

The goals of the SIFS are:

        (1) All integral and density matrix files should have the same
structure and should be read with the same set of library routines.  This
includes MCSCF density matrix files, MRSDCI density matrix files, AO integral
files, transformed MO integral files, or integral files that result from
several consecutive transformation steps.

        (2) The various site-specific integral index-packing and record-length
differences should be eliminated in the COLUMBUS programs.  If such features
are necessary, e.g. for performance reasons, then they should be hidden from
the calling program within SIFS library routines.

        (3) Future extensions should be anticipated in such a way that the
calling programs can remain unchanged.  These extensions can and will include
such things as the compression of the integral values, the inclusion of new
integral types, and the compression of the integral labels.

        (4) Program TRAN should be able to transform an integral file in a
consistent manner without knowing exactly what types of integrals exist on the
input file.

        (5) Energy-related programs (SCF, MCSCF, CI) should be able to read the
1-e hamiltonian matrix without knowing exactly how the components are written
on the input file.

        (6) There should be an option to place the 1-e integrals on a separate
file from the 2-e integrals.  This simplifies calculations in which several
sets of 1-e integrals are associated with a single set of 2-e integrals.
Examples include finite-field calculations involving 1-e perturbations, the
computation of basis-set superposition errors, and the use of scattered 
point charges to simulate electrostatic environments.  In such situations, only
the 1-e integral file needs to be modified.

        (7) The use of efficient non-Fortran I/O should be supported in such a
way that programs using and manipulating integral files are isolated from the
low-level I/O conventions.  This allows high-level calling programs to be
written in a portable and machine-independent manner, while any necessary
machine dependence is localized in a small set of library routines that are
shared by all programs.  These supported extensions used for the processing of
integral files should include asynchronous I/O techniques that are not
supported by standard Fortran and are generally quite machine specific.

        (8) The SIFS should facilitate consistency checking and verification by
the various interdependent electronic structure programs that write and read
the integral and density matrix files.  This should include the ability to
determine the sequence of calculations that have been performed prior to the
generation of an SIFS file.

These goals are realized in the COLUMBUS Program System SIFS which is described
in detail in the following sections.

**********************************************************************
1. The Standard Integral File Structure
**********************************************************************

The SIFS is defined as the sequence of records:

        Header_1 : Header_2 : 1-e Records... : 2-e Records...

which have structures as follows:

**********************************************************************
1.1 Header_1:
**********************************************************************

This is a standard, variable-length, unformatted Fortran record containing
integer values which are required in order to read the subsequent records.
These integers are

      VRSION, NTITLE, NSYM, NBFT, NINFO, NENRGY, NMAP

1.1.1 VRSION = SIFS version number.  This allows consistency checks between the
record-reading routines and the record-writing routines.  This is the first
entry on Header_1, so that this value may be checked independently of the
remaining information on this record.

1.1.2 NTITLE = The number of character*80 titles.  This value should satisfy
(1<=NTITLE<=20).  Each program in an electronic structure sequence may add new
titles, which are then passed on to other programs.  The calling program should
allow for more than 20 titles if several files containing titles are to be
input.  Such programs may also require some program-dependent scheme for
discarding redundant titles and possibly also nonredundant titles if necessary.
[Programmers may find the colib routine UNIQUE() useful for this purpose.]

1.1.3 NSYM = Number of symmetry blocks of integrals.  This must be 1,2,4, or 8
for the D2h COLUMBUS programs.

1.1.4 NBFT = Total number of basis functions.

1.1.5 NINFO = Number of INFO values to be read in Header_2.  Since this
parameter is provided for future extensions, there is no limit on the value of
NINFO.

1.1.6 NENRGY = Number of energy values to be read in Header_2.  The number of
energy values is unlimited.

1.1.7 NMAP = Number of integer mapping vectors to be read.  NMAP=0 is allowed.
There is no limit on the number of mapping vectors.

**********************************************************************
1.2 Header_2:
**********************************************************************

This is a standard Fortran record containing the arrays:

    TITLE, NBPSY, SLABEL, INFO, BFNLAB, IETYPE, ENERGY, IMTYPE, MAP

        CHARACTER*80   TITLE(1:NTITLE)
        INTEGER        NBPSY(1:NSYM)
        CHARACTER*4    SLABEL(1:NSYM)
        INTEGER        INFO(1:NINFO)
        CHARACTER*8    BFNLAB(1:NBFT)
        INTEGER        IETYPE(1:NENRGY)
        REAL*8         ENERGY(1:NENRGY)
        INTEGER        IMTYPE(1:NMAP)
        INTEGER        MAP(1:NBFT,1:NMAP)

which contain the following information:

1.2.1 TITLE*80(1:NTITLE) = Identifying titles.  These include both
user-generated titles, containing molecular geometry comments, basis-set
comments, wave function descriptions, etc., and program-generated time stamps.

1.2.2 NBPSY(1:NSYM) = Number of basis functions in each symmetry block.  Blocks
should be ordered to conform to the appropriate leading subblock of the
"standard" 8 by 8 multiplication table.  (This table is isomorphic to the
exclusive-OR multiplication table of the binary digits from 0 to 7.)  The
calling program should allow blocks with no basis functions.

1.2.3 SLABEL*4(1:NSYM) = Character labels for the symmetry blocks.

1.2.4 INFO(1:NINFO) = Additional parameters describing the integral file
characteristics.  The first five elements are defined as:

1.2.4.1 INFO(1)=FSPLIT: Parameter that allows separation of the 2-e integral
records.

1.2.4.1.1 FSPLIT=1: Headers, 1-e records, and 2-e records are on the file
AOINTS.

1.2.4.1.2 FSPLIT=2: Headers and 1-e records are on AOINTS, 2-e records are on
AOINTS2.  The actual filenames are program dependent, but AOINTS and AOINTS2
are the standard file names used for AO integral files, and these names will be
used in this documentation file as representative 1-e and 2-e file names.
Programmers' note: Programs should be written to assume that two integral files
are always used.  SIFS library routines eliminate the resulting complications
when FSPLIT=1.

1.2.4.2 INFO(2)=L1REC: 1-e integral record length in working-precision (e.g.
REAL*8) words.  This is the size of the record-buffer space that must be
allocated to read 1-e integral records.

1.2.4.3 INFO(3)=N1MAX: Maximum number of 1-e integrals in a record.

1.2.4.4 INFO(4)=L2REC: 2-e integral record length in working-precision words.
Note that the 1-e and 2-e record lengths may be different.

1.2.4.5 INFO(5)=N2MAX: Maximum number of 2-e integrals in a record.

[Note: It should not be assumed in the calling program that L1REC>N1MAX or that
L2REC>N2MAX.  The use of data compression methods could result in violations of
these inequalities.]

1.2.5 BFNLAB*8(1:NBFT) = Character labels for the individual basis functions.
Although these might be specified individually by a user, it is recommended
that each program generate these labels from some smaller set of input data
specified by the user.  For example, an atom label, a basis function label, and
a component label ('C1g:xxyz') might be combined to form the individual
BFNLAB(*) elements.  Programmers may need to brush up on the use of internal
write statements to construct these character strings.

1.2.6 IETYPE(1:NENRGY) = Energy types.  Each entry is defined to be of the form
(ITYPEA * 1024 + ITYPEB).  If necessary, these integers may be extracted with
the expressions, ITYPEA=IETYPE/1024 and ITYPEB=MOD(IETYPE,1024).  Specific
values are defined as.

1.2.6.1 IETYPE < 0 : For strictly negative entries, ITYPEA is a generic energy
type and ITYPEB is a specific energy type as defined in TABLE I.

1.2.6.2 IETYPE >= 0 : Nonnegative values are assumed to derive from the frozen
core contributions of a 1-e hamiltonian array (e.g. Tr(T1 * DENFC)).  The
ITYPEA and ITYPEB parameters are defined below in the description of the 1-e
records. (See TABLE III.)

 TABLE I.  Negative IETYPE(*) Values.  IETYPE = (ITYPEA * 1024 + ITYPEB)
===============================================================================
 -ITYPEA   -ITYPEB    Description
 -------   -------    ---------------------------------------------------------
    0                 Core energy contributions.

              1       Nuclear repulsion energy.
           2 - 1023   Reserved for future core energy definitions.

    1                 Total energy values.

              0       SCF total energy.
              1       MCSCF total energy.
              2       MRSDCI total energy.
              3       CPF total energy.
              4       ACPF total energy.
              5       Linearized Coupled Cluster (LCC-SD) total energy.
              6       Multireference Perturbation Theory (MRPT) total energy.
              7       Bk total energy.
              8       DV1 total energy = MRSDCI + DE * (1-C0**2)
              9       DV2 total energy = MRSDCI + DE * (1-C0**2)/C0**2
             10       EPOPLE total energy.
             11       Spin-Orbit CI energy.
             12       Single Reference SDCI energy
             13       UCEPA
             14       MR-AQCC
             15       a4den
          16 - 1023   Reserved for future total energy definitions.

    2                 Energy and wave function convergence values.

              0       SCF Delta_Energy.
              1       SCF Delta_D1(*).
              2       MCSCF Delta_Energy.
              3       MCSCF W(*) Vector Norm [orbital gradient norm].
              4       MCSCF K(*) Norm [orbital rotation vector norm].
              5       MCSCF Approximate Delta_Energy.
              6       Bk Residual Vector Norm.
              7       CI Residual Vector Norm.
              8       CI Delta_Energy.
              9       CI Approximate Delta_Energy.
          10 - 1023   Reserved for future use.

 3 - 2**20            Reserved for future use.
===============================================================================

All ITYPEA=0 core energy contributions should be combined with the electronic
energy contributions when determining the total energy of a molecule.  Where
applicable, the nuclear repulsion energy should be the first ENERGY(*) entry.
That is, IETYPE(1)=-1, should be enforced by the programmer, even if this value
is zero or meaningless, in order to facilitate automatic consistency checks by
the various programs.  If there are multiple ENERGY(*) values of the same type,
particularly total energy values, the calling program which uses this
information must know which values are appropriate and correctly account for
the repetitions.  In most cases however, the energy(*) values will simply be
printed, thereby giving the history, according to the various energy
contributions, of the sequence of electronic structure calculations.

1.2.7 ENERGY(1:NENRGY) = Core energy contributions according to the
corresponding IETYPE(*) entries.  In order to allow consistency checks, the
nuclear repulsion energy should be the first entry, and this value should be
kept separate from other frozen-core, effective-potential, or reference
energies.  Total energy values should include any core energy contributions
with which they were computed.  This convention is to prevent confusion
concerning whether a particular total energy value was computed before or after
a particular core energy was added to energy(*).  See also the discussion below
of the FCORE values for the individual 1-e integral arrays.

1.2.8 IMTYPE(1:NMAP) = Map vector types according to the following definitions.

1.2.8.1 IMTYPE(i)=1: bfn-to-new_bfn map vector.  The calling program must know
how to use this vector.  If only a subset of the orbital labels appear in the
integral list, then the unreferenced elements of IMTYPE(*) are undefined.

1.2.8.2 IMTYPE(i)=2: Orbital resolution vector.  For density matrix files, this
gives the orbital transformations that are supported by the underlying CSF
expansion set.  See Table II for the definition of the conventions used in the
COLUMBUS Program System for this vector.  For partial integral files, it
defines the occupations of the orbitals.  Also, see below the ITYPEA=3,
ITYPEB=2 entry in TABLE III.

 TABLE II.  MAP(i) Definitions
===============================================================================
IMTYPE=2 Orbital Resolution Vector Values for MCSCF/SCF Orbitals
-------------------------------------------------------------------------------

  -5 = Frozen core orbital.  This orbital was doubly occupied in every
       expansion CSF and not allowed to change during the MCSCF procedure.

  -4 = Doubly occupied (i.e. inactive) MCSCF orbital.  This orbital was doubly
       occupied in every expansion CSF.  Q(*,*) (effective fock matrix)
       resolution is assumed to have been applied.

  -3 = Frozen virtual orbital.  This orbital was unoccupied in every expansion
       CSF, and not allowed to change during the MCSCF procedure.

  -2 = Virtual MCSCF orbital. This orbital was unoccupied in every expansion
       CSF.  Q(*,*) (effective fock matrix) resolution is assumed.

  -1 = Frozen active orbital.  This orbital was artificially frozen during the
       wave function optimization process.

   0 = Active orbital that does not belong to an invariant subspace.  All
       rotations involving this orbital were included in the wave function
       optimization.

   n = Orbital that belongs to invariant orbital subspace "n".  The rotation
       operator (Epq-Eqp) is redundant when MAP(p)=MAP(q).  Note that MAP(p)=0
       is logically the same as MAP(p)=n provided that MAP(q)<>n for all of the
       remaining orbitals.  Orbital subspaces may be resolved (canonicalized)
       by the MCSCF or SCF program according to the following conditions:

       1   <= n <=  99  No orbital resolution was imposed.
       100 <= n <= 199  D1(*,*) natural orbital resolution was imposed.
       200 <= n <= 299  F(*,*) generalized fock matrix resolution was imposed.
       300 <= n <= 399  Q(*,*) effective fock matrix resolution was imposed.
       400 <= n         Reserved for future use.

-------------------------------------------------------------------------------
IMTYPE(i)=4 Basis Function Type Values for AO Basis Function Files.
-------------------------------------------------------------------------------

   1 =  s orbital.
   2 =  p orbital.
   3 = 3s orbital.  (The xx+yy+zz combination of the Cartesian d components.)
   4 =  d orbital.
   5 = 4p orbital.  (From the Cartesian f space.)
   6 =  f orbital.
   7 = 5s orbital.  (From the Cartesian g space.)
   8 = 5d orbital.  (From the Cartesian g space.)
   9 =  g orbital.
  10 = 6p orbital.  (From the Cartesian h space.)
  11 = 6f orbital.  (From the Cartesian h space.)
  12 =  h orbital.
  13 = 7s orbital.  (From the Cartesian i space.)
  14 = 7d orbital.  (From the Cartesian i space.)
  15 = 7g orbital.  (From the Cartesian i space.)
  16 =  i orbital.
===============================================================================

1.2.8.3 IMTYPE(i)=3: bfn-to-center map vector, required for population
analysis.

1.2.8.4 IMTYPE(i)=4: bfn-to-orbital_type vector, required for population
analysis.  See Table II for the COLUMBUS conventions.

1.2.9 MAP(1:NBFT,1:NMAP) = Integer mapping vectors.  The type of each vector is
determined by the corresponding IMTYPE(*) entry.  IMTYPE(*) and MAP(*) may be
ignored by the calling program if they are not to be used.  That is, the
input/output processing of the integral arrays in the following records should
not depend on the use of MAP(*) vectors.  These arrays should always be the
last entries in Header_2.

**********************************************************************
1.3 Integral Records:
**********************************************************************

1-e integral records are always written to the AOINTS file immediately
following the header records.  2-e integrals may be written to AOINTS or, if
INFO(1)[=FSPLIT]=2, to an alternate file, AOINTS2.  AOINTS is always
variable-record-length Fortran file, but AOINTS2 may be written with
non-Fortran, machine-specific routines for increased processing efficiency.  In
all cases, the actual 1-e and 2-e integral records are fixed length, regardless
of the file type.

The structure of each 1-e integral record has the form,

 DWORD // PACKED_VALUES(*) // FCORE // PACKED_LABELS(*) // PACKED_BIT_VECTOR(*)

and each 2-e record has the form,

 DWORD // PACKED_VALUES(*) // PACKED_LABELS(*) // PACKED_BIT_VECTOR(*)

1.3.1 DWORD is a working-precision word that contains a packed representation
of the integer parameters that describe the structure of the record.  The
number of bits used for each parameter is also specified, and determines the
maximum value for that parameter.  The values of some of these parameters may
change from record to record, even for records corresponding to the same
integral array.

===============================================================================
   Reserved     NUM     ITYPEA   ITYPEB     LAST     IFMT    IBVTYP    LAB1
-------------------------------------------------------------------------------
    11 bits   16 bits   3 bits   10 bits   2 bits   3 bits   3 bits   16bits
===============================================================================

1.3.1.1 NUM(16 bits) = The actual number of integrals in the record. Note that
(NUM<=N1MAX) or (NUM<=N2MAX) as appropriate.

1.3.1.2 ITYPEA(3 bits) = The generic integral type.  The ITYPEA parameter is
sufficient for a general integral transformation program to correctly transform
the integrals.  It is also used by various SIFS library routines, described
below, to determine how the symmetry-partitioned subblocks of various arrays
are referenced.

1.3.1.2.1 ITYPEA=0: For general, block-diagonal, symmetric, 1-e matrices.  This
applies to most operators and matrices used by the various programs.

1.3.1.2.2 ITYPEA=1: For general, non-block-diagonal, symmetric 1-e matrices.
This applies to matrix representations of observable 1-e properties.

1.3.1.2.3 ITYPEA=2: For general, non-block-diagonal, antisymmetric 1-e
matrices.  This applies to matrix representations of purely imaginary hermitian
operators, stored in real form, such as the spatial components of the L*S
spin-orbit operator.

1.3.1.2.4 ITYPEA=3: For 2-e integrals and density matrices.  These are 4-index
quantities (ij:kl) with the usual 8-fold permutation identities:
(ij:kl)=(ji:kl)=(ij:lk)=(ji:lk)=(kl:ij)=(lk:ij)=(kl:ji)=(lk:ji).

1.3.1.2.5 ITYPEA=4-7: Reserved for future use.  The inclusion of orbital
coefficient arrays and complex property arrays is under consideration.

1.3.1.3 ITYPEB(10 bits) = The specific type of integral within the ITYPEA
class.  See the table below for specific definitions.

1.3.1.4 LAST(2 bits) = Flag value associated with each record.  The values are
specified by the following parameter statement.

         PARAMETER( MSAME=0, NMSAME=1, NOMORE=2 )

1.3.1.4.1 LAST=MSAME: The following record contains more integrals of the same
type as the current record.  All records corresponding to a specific array must
occur together in the file.  That is, records of different arrays should not be
interspersed.  This implies that ITYPEA and ITYPEB cannot change as long as
LAST=MSAME.  It is recommended that programmers use the above parameters in
their codes in order to promote readability of their programs.

1.3.1.4.2 LAST=NMSAME: For 1-e records, the following record contains 1-e
integrals of a different type.  (For 2-e records, LAST=1 is reserved for future
use.  This will probably be used for splitting the AOINTS2 file into multiple
smaller files, or for distributing this file across a network.)

1.3.1.4.3 LAST=NOMORE: This is the last 1-e integral record or 2-e integral
record.

1.3.1.4.4 LAST=3: Reserved for future use.

1.3.1.5 IFMT(3 bits) = Format code for the current record.

1.3.1.5.1 IFMT=0: Integral values are not packed.  Orbital labels are packed
8-bits/label.

1.3.1.5.2 IFMT=1: Integral values are not packed.  Orbital labels are packed
16-bits/label.

1.3.1.5.3 IFMT=2-7: Reserved for future use.  These will be used for
alternative integral and label packing schemes.

1.3.1.6 IBVTYP(3 bits) = Bit vector type.  The last (NxMAX+63)/64 buffer words
(x=1 or 2 as appropriate) are used to store Boolean flags associated with
blocking of the integral values within a record or across records.  The present
convention is that bit-vector elements are associated with values within an
integral record, and not with characteristics of the array elements themselves.
Bit vectors may be used to facilitate the processing of integral arrays, but
they should be used in such a way that they are required in order to define
individual values.  These bit vectors are defined as follows.

1.3.1.6.1 IBVTYP= 0: Bit vector is not stored.  The buffer space may be used
for values and labels.

1.3.1.6.2 IBVTYP=1: PK-flags are stored in the bit vector.  The bit
corresponding to the last integral of a PK block of integrals is set.
disjoint subset of P and K integral combinations only involves integrals within
one of these blocks.  When available on the integral file, the P and K
combinations of integrals may be constructed with only one pass through the
AOINTS file and one pass through the sorted result file.  With randomly ordered
integrals, this process normally requires twice this amount of I/O.  For
density matrix files, this blocking allows the computation of analytic
derivatives directly from the SIFS file, provided the ordering of the blocks is
consistent with the derivative integral evaluation.

1.3.1.6.3 IBVTYP=2-7: Reserved for future use.  Possibilities include symmetry
blocking partitionings, occupation-type partitionings, or excitation-level
partitionings of the integrals or density elements.

1.3.1.7 LAB1(16 bits) = The location within the record, measured in
working-precision words, of the beginning of the packed labels.

 TABLE III.  1-e and 2-e Array Definitions
===============================================================================
 ITYPEA ITYPEB Description
 ------ ------ -------------------------------------------------------
    0          Block-diagonal, symmetric matrices.

           0   S1(*) overlap integrals.
           1   T1(*) kinetic energy integrals.
           2   V1(*) electron-nuclear attraction integrals.
           3   VEC(*) effective_core/pseudopotential integrals.
           4   VFC(*) frozen core integrals.
           5   VREF(*) hamiltonian repartitioning contributions.
           6   H1(*) additional generic 1-e hamiltonian contributions.
           7   D1(*) one-particle density matrix.
           8   F(*) generalized fock matrix.
           9   Q(*) effective fock matrix.
       10-1023 Reserved for future use.

    1          Non-block-diagonal, symmetric matrices.

           0   <x> dipole moment  # <x>, <y>, and <z> are included to allow
           1   <y> dipole moment  # finite electric field and (dipole length)
           2   <z> dipole moment  # transition moment calculations.
           3   <xx> second moment
           4   <xy> second moment # quadrupole moment and diamagnetic
           5   <xz> second moment # can be obtained from these.
           6   <yy> second moment
           7   <yz> second moment
           8   <zz> second moment
           9   <xxx> third moment
          10   <xxy>
          11   <xxz>
          12   <xyy>
          13   <xyz>
          14   <xzz>
          15   <yyy>
          16   <yyz>
          17   <yzz>
          18   <zzz>
          19   <xxxx> fourth moment
          20   <xxxy>
          21   <xxxz>
          22   <xxyy>
          23   <xxyz>
          24   <xxzz>
          25   <xyyy>
          26   <xyyz>
          27   <xyzz>
          28   <xzzz>
          29   <yyyy>
          30   <yyyz>
          31   <yyzz>
          32   <yzzz>
          33   <zzzz>
       34-1023 Reserved for future use.

    2          Non-block-diagonal, antisymmetric matrices.

           0   Im<SO:x> (imaginary) x component of spin-orbit operator.
           1   Im<SO:y> (imaginary) y component of spin-orbit operator.
           2   Im<SO:z> (imaginary) z component of spin-orbit operator.
           3   Im<px> (imaginary)  # components of linear momentum are included
           4   Im<py> (imaginary)  # to allow (dipole velocity) transition
           5   Im<pz> (imaginary)  # moment calculations.
           6   Im<lx> (imaginary)  # components of orbital angular momentum
           7   Im<ly> (imaginary)  # are included to allow magnetic moment
           8   Im<lz> (imaginary)  # calculations.
       9-1023 Reserved for future use.

    3          2-particle (4-index) arrays.

           0   2-e 1/r12 repulsion integrals.
           1   two-particle density matrix elements.
           2   partial 2-e 1/r12 integrals. (oo|xx), (ox|ox) subsets only,
               where "o" is occupied and "x" is general.  These are the only
               integrals necessary for MCSCF or PT(2), or "POL-CI" and
               "first-order CI" (i.e. multireference single-excitation CI)
               calculations.  The IMTYPE(i) = 2, MAP(*,i) vector contains the
               occupation information.
	   3   half (ket-)differentiated overlap integrals with respect to geometry
	       distorsion. NOTE: 1-electron (2-index array), 
	       4 index structure: ind1, ind2, atom number, 0
	   4   half (bra-)differentiated overlap integrals with respect to geometry
	       distorsion. NOTE: 1-electron (2-index array), 
	       4 index structure: ind1, ind2, atom number, 0
        3-1023 Reserved for future use.

   4-7         Reserved for future use.
===============================================================================

1.3.2 PACKED_VALUES(*) = The packed integral or density matrix values.  The
values begin at BUFFER(2).  Only the distinct array elements should be
included.  For example, if S1(i,j) is included, then S1(j,i) should not be
written also.  For normal 2-e arrays, only one of the eight permutationally
equivalent array elements should be written to the file.  This convention is to
allow array contributions to be accumulated directly from the records.  The
IFMT parameter determines how the values are packed, and the packing method may
differ from record to record.

1.3.2 FCORE(*) = Frozen core contributions for 1-e integral arrays.  In the
full basis, the expectation value of an arbitrary operator, X, may be written
as

  <X> = tr( X * D(total) )
      = tr( X * D(c) ) + tr( X * D(n) )
      = X_FCORE + tr( X * D(n) )

where D(total) is the total density matrix, D(c) is the frozen core, or
reference, density matrix and D(n) is the remaining noncore density matrix
(i.e. D(n)=D(total)-D(c)).  Consequently the correct expectation value of such
an array must include both the X_FCORE contribution and the trace contribution
from the noncore density matrix.  FCORE values must be included in the record
even if they are zero, and the same value must be specified for each record of
a particular array.

Some special cases of FCORE values merit special mention.  For the S1(*)
matrix, using Smo and Dmo as the overlap and density matrices in the MO
representation (Smo should be a unit matrix),

  S1_FCORE = tr( Smo * Dmo ) = tr( Dmo ) = N(frozen_electrons)

is the number of electrons which have been frozen.  This quantity may be used
by various programs to test the validity of the basis, and in particular, to
measure the accuracy of the orbital coefficients used to define the frozen core
density matrix.

In the case of energy calculations for which the 2-e potential contributions
must also be considered, the total electronic energy may be written as

  E =   tr( T1 * D(c) ) + tr( V1 * D(c) ) + 1/2 * tr( VFC * D(c) )
      + tr( T1 * D(n) ) + tr( V1 * D(n) ) + tr( VFC * D(n) )
      + 1/2 * tr( g * d2(n) )

where the first three terms are T1_FCORE, V1_FCORE, VFC_FCORE respectively.
(Note that the factor of 1/2 is included in the VFC_FCORE definition.  This
convention is adopted so that VFC_CORE may be treated analogously to other
frozen core energy values, and so that VFC(*)may be treated as a 1-e potential
contribution to the hamiltonian operator.)  When reading SIFS integral files,
all of these terms should be added together, along with any relevant ENERGY(*)
core values, for the final total energy calculation.  Consequently, when
writing SIFS integral files, care should be taken to not include such FCORE
contributions redundantly (i.e. both as FCORE values and as ENERGY(*) values)
on the integral file.

It is recommended that frozen core contributions associated with 1-e
hamiltonian integral arrays be written as FCORE values instead of ENERGY(*)
values.  Frozen core contributions of nonhamiltonian arrays (e.g. S1(*)) should
never be written as ENERGY(*) values.

1.3.3 PACKED_LABELS(*) = The packed orbital labels associated with each value.
The labels begin at BUFFER(LAB1).  There are two orbital labels associated with
each 1-e integral or density matrix value, and four orbital labels associated
with each 2-e integral or density matrix value.  The IFMT parameter determines
how the labels are packed, and the packing method may differ from record to
record.

1.3.4 PACKED_BIT_VECTOR(*) = If IBVTYP.NE.0, then a packed bit-vector is stored
at the end of the buffer.  If this vector is not present, its buffer space may
be used to store values and labels.

**********************************************************************
2. SIFS Subroutine Library:
**********************************************************************

The following set of routines is defined to allow the calling program structure
to remain simple despite the underlying complexity and generality of the
integral file structure.  These routines are hierarchical, and the higher-level
routines allow the file structure to be accessed in a machine-independent and
packing-method-independent manner.  The use of these library routines isolates
the programmer from the details of the underlying file and record structures,
from any machine dependence in these structures, and from possible future
changes to these structures.  These routines also perform numerous consistency
checks to help ensure that the parameters are consistent with the SIFS
definition.

The use of these high-level routines is the recommended method of accessing the
integral file records.  However, it may be desirable to access these records in
some nonstandard way for a particular application.  If possible, this should be
done by calling the lower-level routines.  If a particular nonstandard form of
access is required by many programs, then the routines supporting this are
candidates for inclusion into the standard integral I/O library.

Only a brief description of the routine is given here.  The actual source code
should be consulted for detailed descriptions and for dummy argument
definitions.

2.1 ALPHABETICAL SIFS LIBRARY SUBPROGRAM INDEX:

      subroutine sif2w8 ..... 2.2.5.1
      subroutine sifc2f ..... 2.2.2.1
      subroutine sifcfg ..... 2.2.1.1
      subroutine sifd1  ..... 2.3.1
      subroutine sifd2  ..... 2.2.5.2
      subroutine sife1  ..... 2.3.2
      subroutine sife2  ..... 2.3.3
      subroutine sifew1 ..... 2.2.3.1
      subroutine sifew2 ..... 2.2.3.2
      subroutine siffr1 ..... 2.2.1.2
      subroutine siffr2 ..... 2.2.1.3
      subroutine siffw1 ..... 2.2.1.4
      subroutine siffw2 ..... 2.2.1.5
      subroutine sifmge ..... 2.2.1.6
      subroutine sifo2f ..... 2.2.2.2
      subroutine sifpre ..... 2.2.1.7
      subroutine sifr1n ..... 2.2.4.1
      subroutine sifr1x ..... 2.2.4.2
      subroutine sifr2  ..... 2.2.5.3
      subroutine sifrd1 ..... 2.2.4.3
      subroutine sifrd2 ..... 2.2.4.4
      subroutine sifrh1 ..... 2.2.4.5
      subroutine sifrh2 ..... 2.2.4.6
      subroutine sifrsh ..... 2.2.4.7
      function   sifsce ..... 2.2.1.8
      subroutine sifsk1 ..... 2.2.2.3
      subroutine sifskh ..... 2.2.2.4
      subroutine sifstv ..... 2.2.4.8
      subroutine siftdy ..... 2.2.1.9
      subroutine siftyp ..... 2.2.1.10
      subroutine sifw1x ..... 2.2.3.3
      subroutine sifw2 ...... 2.3.4
      subroutine sifwh  ..... 2.2.3.4
      subroutine sifzh2 ..... 2.4.1
      subroutine sifzwh ..... 2.4.2


2.2 HIGH-LEVEL ROUTINES:

The use of these routines is recommended where applicable.  The source code of
these routines can also be used as a guide when building modified high-level
routines with slightly different functionality than the standard library
routines.  These routines are grouped, somewhat arbitrarily, into five
categories: (1) inquiry/action routines, (2) file-manipulation routines,
(3) output routines, (4) synchronous input routines, and (5) asynchronous
I/O routines.

2.2.1 Inquiry/Action Routines

2.2.1.1  ********************

      subroutine sifcfg(  itype,   lrecal,  nbft,    ibvtyp,  ifmt,
     &  lrec,    nmax,    ierr  )

This routine returns a consistent set of SIFS file configuration parameters
for the specified integral type, number of basis functions, and maximum buffer
length.

2.2.1.2  ********************

      subroutine siffr1(  ninput,  info,    nipv,    num,     last,
     &  itypea,  itypeb,  ifmt,    ibvtyp,  values,  labels,  fcore,
     &  ibitv,   ierr  )

This routine reads a formatted representation of a 1-e record.  This operation
is useful for debugging, developmental work, and transferring integral files
from one machine to another.  See also SIFFR2(), SIFFW1(), and SIFFW2().

2.2.1.3  ********************

      subroutine siffr2(  ninput,  info,    nipv,    num,     lasta,
     &  itypea,  itypeb,  ifmt,    ibvtyp,  values,  labels,  ibitv,
     &  ierr  )

This routine reads a formatted representation of a 2-e record.  See also
SIFFR1().

2.2.1.4  ********************

      subroutine siffw1(  info,    nipv,    num,     last,    itypea,
     &  itypeb,  ifmt,    ibvtyp,  values,  labels,  fcore,   ibitv,
     &  nlist,   ierr  )

This routine writes a formatted representation of a 1-e record.  See also
SIFFR1().

2.2.1.5  ********************

      subroutine siffw2(  info,    nipv,    num,     last,    itypea,
     &  itypeb,  ifmt,    ibvtyp,  values,  labels,  ibitv,   nlist,
     &  ierr  )

This routine writes a formatted representation of a 2-e record.  See also
SIFFR1().

2.2.1.6  ********************

      subroutine sifmge(  nenrgy,  energy,  ietype,  nnew,    enew,
     &  typnew  )

This routine merges two ENERGY(*) arrays, eliminating exact duplicates.  If
ENERGY(*) arrays from two sources have some common ancestry, then duplication
of core energies must be eliminated in order to avoid overcounting their
contributions to total energies.

2.2.1.7  ********************

      subroutine sifpre(  nlist,   nenrgy,  energy,  ietype  )

This routine prints out the ENERGY(*) array, thereby allowing some degree of
uniformity among all the programs that need to print this array.

2.2.1.8  ********************

      function sifsce(    nenrgy,  energy,  ietype  )

This REAL*8 function identifies the core energy contributions and computes
their sum.  E_TOTAL = E_ELECTRONIC + SIFSCE(...) gives the total
clamped-nucleus, Born-Oppenheimer, potential energy.  This routine sums all of
the ITYPEA=0 core energies that exist in the ENERGY(*) array, not just those
defined in TABLES I and III.  This convention allows the standard sifsce()
function to be used in program development work as new definitions of core
energies are tested.  However, programmers should be wary of the possibility of
multiple definitions of individual values during this development period in
which these definitions have not yet been standardized.

2.2.1.9  ********************

      subroutine siftdy(  chrtdy  )

This routine returns a character*40 variable which contains the machine name,
date, and time.  It is recommended that each program which creates a SIFS file
also create internally a character*80 TITLE record that is included in the
array of such records in the output file.  TITLE(1:40) should be defined to
contain the program name and function, while TITLE(41:80) should be defined by
calling SIFTDY(TITLE(41:80)).

2.2.1.10 ********************

      subroutine siftyp(  itypea,  itypeb,  chrtyp  )

This routine returns a mnemonic character string for an integral type or
ENERGY(*) type.  This routine allows uniformity of notation among programs that
use SIFS files and print arrays or energy values.

2.2.2 File-Manipulation Routines

2.2.2.1  ********************

      subroutine sifc2f(  aoint2,  info,    ierr  )

This routine closes the 2-e integral file and removes the need for any
FSPLIT-related logic in the calling program for this operation.  The correct
operation order in the calling program is:

     open(unit=aoints,...)        # standard open for the 1-e file.
     call sifo2f(..aoint2.)       # open the 2-e file.
     call sifc2f(aoint2...)       # close the 2-e file.
     close(unit=aoints...)        # close the 1-e file.

The FSPLIT-related logic is localized within sifo2f() and sifc2f().

2.2.2.2  ********************

      subroutine sifo2f(  aoints,  iunit2,  filnm2,  info,    aoint2,
     &  ierr  )

This routine opens the 2-e integral file without requiring any FSPLIT-related
logic in the calling program.

2.2.2.3  ********************

      subroutine sifsk1(  aoint2,  info,    ierr  )

This routine ensures that the file containing the 2-e records is positioned
immediately before the first 2-e record without requiring any FSPLIT-related
logic in the calling program.

2.2.2.4  ********************

      subroutine sifskh(  aoints,  ierr  )

This routine skips over the header records and positions the integral file
immediately before the first 1-e integral record.

2.2.3 Output Routines

2.2.3.1  ********************

      subroutine sifew1(  aoints,  info,    nipv,    num,     last,
     &  itypea,  itypeb,  ifmt,    ibvtyp,  values,  labels,  fcore,
     &  ibitv,   buffer,  nrec,    ierr  )

This routine encodes and writes a 1-e integral buffer.  It calls sife1().

2.2.3.2  ********************

      subroutine sifew2(  aoint2,  info,    nipv,    num,     last,
     &  itypea,  itypeb,  ifmt,    ibvtyp,  values,  labels,  ibitv,
     &  buffer,  iwait,   nrec,    reqnum,  ierr  )

This routine encodes and writes a 2-e integral buffer and is used for both
synchronous and asynchronous record processing.  It calls sife2() and sifw2().

2.2.3.3  ********************

      subroutine sifw1x(  aoints,  info,    lstflg,  itypea,  itypeb,
     &  ifmt,    mapout,  array,   nsym,    nbpsy,   symoff,  kntin,
     &  buffer,  values,  labels,  fcore,   small,   kntout,  numtot,
     &  nrec,    ierr  )

This routine writes an entire 1-e integral array.  See the source code for the
symmetry-block addressing conventions used.

2.2.3.4  ********************

      subroutine sifwh(   aoints,  ntitle,  nsym,    nbft,    ninfo,
     &  nenrgy,  nmap,    title,   nbpsy,   slabel,  info,    bfnlab,
     &  ietype,  energy,  imtype,  map,     ierr  )

This routine writes the header records, Header_1 and Header_2.

2.2.4 Synchronous Input Routines

2.2.4.1  ********************

      subroutine sifr1n(  aoints,  info,    itypea,  btypmx,  btypes,
     &  buffer,  values,  labels,  nsym,    nbpsy,   symoff,  mapin,
     &  lda,     array,   fcore,   symb,    kntin,   lasta,   lastb,
     &  last,    nrec,    ierr  )

This routine searches the 1-e records for a specified list of 1-e array types.
All arrays are read with a single pass through the file.  See the source code
for the symmetry-block addressing conventions used.

2.2.4.2  ********************

      subroutine sifr1x(  aoints,  info,    itypea,  itypeb,  nsym,
     &  nbpsy,   symoff,  buffer,  values,  labels,  mapin,   symb,
     &  lena,    array,   fcore,   kntin,   lasta,   lastb,   last,
     &  nrec,    ierr  )

This routine searches the 1-e records for a specific integral array.  It is a
front end to the more general sifr1n().

2.2.4.3  ********************

      subroutine sifrd1(  aoints,  info,    nipv,    iretbv,  buffer,
     &  num,     last,    itypea,  itypeb,  ifmt,    ibvtyp,  values,
     &  labels,  fcore,   ibitv,   ierr  )

This routine reads and decodes a 1-e record.  It calls sifd1().

2.2.4.4  ********************

      subroutine sifrd2(  aoint2,  info,    nipv,    iretbv,  buffer,
     &  num,     last,    itypea,  itypeb,  ifmt,    ibvtyp,  values,
     &  labels,  ibitv,   ierr  )

This routine reads and decodes a 2-e record and forces synchronous processing
of the input records.  It is a front end to the routines sifr2() and sifd2(),
which should be called directly when asynchronous record processing is desired.

2.2.4.5  ********************

      subroutine sifrh1(  aoints,  ntitle,  nsym,    nbft,    ninfo,
     &  nenrgy,  nmap,    ierr  )

This routine reads Header_1 and performs various consistency checks.

2.2.4.6  ********************

      subroutine sifrh2(  aoints,  ntitle,  nsym,    nbft,    ninfo,
     &  nenrgy,  nmap,    title,   nbpsy,   slabel,  info,    bfnlab,
     &  ietype,  energy,  imtype,  map,     ierr  )

This routine reads Header_2.  It is assumed that Header_1 has been read, that
the dimensions have been verified by the calling program, and that the
necessary array space has been allocated.

2.2.4.7  ********************

      subroutine sifrsh(  aoints,  info,    buffer,  values,  labels,
     &  nsym,    nbpsy,   mapin,   nnbft,   s1h1,    score,   hcore,
     &  symb,    ierr  )

This routine makes a single pass through the 1-e integral records, reads the
S1(*) array, and accumulates all of the contributions to the total H1(*) array.
It is a front end to the more general sifr1n().  See also sifstv().

2.2.4.8  ********************

      subroutine sifstv(  aoints,  info,    buffer,  values,  labels,
     &  nsym,    nbpsy,   mapin,   nnbft,   stv,     score,   tcore,
     &  vcore,   symb,    ierr  )

This routine is a front end to the more general sifr1n().  It makes a single
pass through the 1-e integral records, reads the S1(*) array, and accumulates
all of the contributions to the total T1(*) and V1(*) arrays.  The T1_FCORE and
V1_FCORE values may be combined with their appropriate noncore counterparts and
used to compute virial ratios.  See also sifrsh().

2.2.5 Asynchronous Input Routines

2.2.5.1  ********************

      subroutine sif2w8(  aoint2,  info,    reqnum,  ierr  )

This routine forces completion of the specified pending I/O request on the 2-e
integral file.  Calls to it are necessary only if asynchronous processing is
being used by the calling program.  After initiating a write of an asynchronous
record (e.g. with sifew2()), sif2w8() could be called before modifying the
contents of the output buffer used for that record.  Similarly, after
initiating a read of an asynchronous record (e.g. with sifr2()), sif2w8()
should be called before accessing the contents of the buffer (e.g. before the
sifd2() call).

2.2.5.2  ********************

      subroutine sifd2(   info,    nipv,    iretbv,  buffer,  num,
     &  last,    itypea,  itypeb,  ifmt,    ibvtyp,  values,  labels,
     &  ibitv,   ierr  )

This routine decodes a 2-e integral buffer.  Explicit calls to this routine
are necessary only if the integral records are being processed asynchronously
in the calling program.  See also sif2w8() and sifr2().

2.2.5.3  ********************

      subroutine sifr2(   aoint2,  iwait,   info,    buffer,  reqnum,
     &   ierr  )

This routine reads a 2-e buffer.  Explicit calls to this routine are necessary
only if the integral records are being processed asynchronously in the calling
program.  See also sif2w8() and sifd2().

2.3 MIDDLE-LEVEL ROUTINES:

The use of these routines is recommended only if the previous high-level
routines are not appropriate.

2.3.1    ********************

      subroutine sifd1(   info,    nipv,    iretbv,  buffer,  num,
     &  last,    itypea,  itypeb,  ifmt,    ibvtyp,  values,  labels,
     &  fcore,   ibitv,   ierr  )

This routine decodes a 1-e integral buffer.

2.3.2    ********************

      subroutine sife1(   info,    nipv,    num,     last,    itypea,
     &  itypeb,  ifmt,    ibvtyp,  values,  labels,  fcore,   ibitv,
     &  buffer,  ierr  )

This routine encodes a 1-e integral buffer.

2.3.3    ********************

      subroutine sife2(   info,    nipv,    num,     last,    itypea,
     &  itypeb,  ifmt,    ibvtyp,  values,  labels,  ibitv,   buffer,
     &  ierr  )

This routine encodes a 2-e integral buffer.

2.3.4    ********************

      subroutine sifw2(   aoint2,  iwait,   info,    buffer,  reqnum,
     &  ierr  )

This routine writes a 2-e integral buffer.  Routine sife2() should first be
used to encode the buffer information before calling this routine.

2.4 LOW-LEVEL ROUTINES:

The use of these routines is not recommended unless absolutely necessary.
These routines are documented here in order to fully describe the SIFS library
routines and the low-level file structure.

2.4.1    ********************

      subroutine sifzh2(  aoints,  ntitle,  nsym,    nbft,    ninfo,
     &  nenrgy,  nmap,    title,   nbpsy,   slabel,  info,    bfnlab,
     &  ietype,  energy,  imtype,  map,     mapdim,  ierr  )

This routine reads Header_2, and is called by sifrh2().

2.4.2    ********************

      subroutine sifzwh(  aoints,  vrsion,  ntitle,  nsym,    nbft,
     &  ninfo,   nenrgy,  nmap,    title,   nbpsy,   slabel,  info,
     &  bfnlab,  ietype,  energy,  imtype,  map,     mapdim,  ierr  )

This routine writes Header_1 and Header_2, and is called by sifwh().

**********************************************************************
3. Further Documentation and Examples
**********************************************************************

Each SIFS library routine was written in a manner intended to be clear,
efficient, and straightforward and to contain full internal documentation.
However, it is often useful to examine code examples to see how the library
routines actually work together.  The following are some examples of SIFS
library routine usage.

3.1 Program IFAKE is a small program that creates fake integral files for
debugging, developmental, and testing purposes.  This program shows how array
values and orbital labels are buffered prior to being written to the output
file.

3.2 Program ISTAT reads a SIFS file and computes various sums of array
elements.  This is useful for testing changes to various programs, or for
validating ports of codes to new machines.  ISTAT shows how the array values
and orbitals returned from the library routines can be processed in an
efficient, portable, and machine-independent manner.  The 2-e records are
processed asynchronously.

3.3 Program IWFMT reads a SIFS file and writes a formatted, human-readable,
text representation of the file.

3.4 Program IRFMT reads the formatted file written by IWFMT and writes a normal
unformatted SIFS file.  It is interesting to consider what is done by the Unix
command "iwfmt.x | rsh remote_machine irfmt.x".

3.5 Program TRAN is an actual production program, and is therefore somewhat
more complicated than the above examples.  This program both reads and writes
integral files.  It computes the various FCORE values when orbitals are frozen,
and includes these contributions along with any previous FCORE values when
writing the transformed output file.  It uses asynchronous I/O in both the
input and output integral files.  Program TRAN also contains one example of how
to process more title(*) records than can be stored internally by treating the
internal title(*) array as a circular buffer.

Reference: R. Shepard, Int. J. Quantum Chem. 40, 865-887, (1991).

**********************************************************************
4. Sign-off
**********************************************************************

The author encourages comments and suggestions concerning this documentation
file, the SIFS conventions, and the SIFS library routines.

Ron Shepard,
shepard@tcg.anl.gov
