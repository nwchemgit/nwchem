      SUBROUTINE ccsd_t2_8(d_a,k_a_offset,d_b,k_b_offset,d_c,k_c_offset)
!     $Id: ccsd_t2.F 27404 2015-08-24 14:20:43Z jhammond $
!     This is a Fortran77 program generated by Tensor Contraction Engine v.1.0
!     Copyright (c) Battelle & Pacific Northwest National Laboratory (2002)
!     i0 ( p3 p4 h1 h2 )_vt + = 1/2 * Sum ( p5 p6 ) * t ( p5 p6 h1 h2 )_t * v ( p3 p4 p5 p6 )_v
      IMPLICIT NONE
#include "global.fh"
#include "mafdecls.fh"
#include "sym.fh"
#include "errquit.fh"
#include "tce.fh"
      INTEGER d_a
      INTEGER k_a_offset
      INTEGER d_b
      INTEGER k_b_offset
      INTEGER d_c
      INTEGER k_c_offset
      INTEGER NXTASK
      INTEGER next
      INTEGER nprocs
      INTEGER count
      INTEGER p3b
      INTEGER p4b
      INTEGER h1b
      INTEGER h2b
      INTEGER dimc
      INTEGER l_cs
      INTEGER k_cs
      INTEGER p5b
      INTEGER p6b
      INTEGER p5b_1
      INTEGER p6b_1
      INTEGER h1b_1
      INTEGER h2b_1
      INTEGER p3b_2
      INTEGER p4b_2
      INTEGER p5b_2
      INTEGER p6b_2
      INTEGER dim_common
      INTEGER dima_sort
      INTEGER dima
      INTEGER dimb_sort
      INTEGER dimb
      INTEGER l_as
      INTEGER k_as
      INTEGER l_a
      INTEGER k_a
      INTEGER l_bs
      INTEGER k_bs
      INTEGER l_b
      INTEGER k_b
      INTEGER nsuperp(2)
      INTEGER isuperp
      INTEGER l_c
      INTEGER k_c
      integer p5b_in,p6b_in
      DOUBLE PRECISION FACTORIAL
      EXTERNAL NXTASK
      EXTERNAL FACTORIAL
      nprocs = GA_NNODES()
      count = 0
      next = NXTASK(nprocs, 1)
      DO p3b = noab+1,noab+nvab
      DO p4b = p3b,noab+nvab
      DO h1b = 1,noab
      DO h2b = h1b,noab
      IF ((.not.restricted).or.(int_mb(k_spin+p3b-1)+int_mb(k_spin+p4b-1
     &)+int_mb(k_spin+h1b-1)+int_mb(k_spin+h2b-1).ne.8)) THEN
      IF (int_mb(k_spin+p3b-1)+int_mb(k_spin+p4b-1) .eq. int_mb(k_spin+h
     &1b-1)+int_mb(k_spin+h2b-1)) THEN
      IF (ieor(int_mb(k_sym+p3b-1),ieor(int_mb(k_sym+p4b-1),ieor(int_mb(
     &k_sym+h1b-1),int_mb(k_sym+h2b-1)))) .eq. ieor(irrep_v,irrep_t)) TH
     &EN
      IF (next.eq.count) THEN
      dimc = int_mb(k_range+p3b-1) * int_mb(k_range+p4b-1) * int_mb(k_ra
     &nge+h1b-1) * int_mb(k_range+h2b-1)
      IF (.not.MA_PUSH_GET(mt_dbl,dimc,'cs',l_cs,k_cs)) CALL
     & ERRQUIT('ccsd_t2_8',0,MA_ERR)
      CALL DFILL(dimc,0.0d0,dbl_mb(k_cs),1)
#if 0
      DO p5b = noab+1,noab+nvab
      DO p6b = p5b,noab+nvab
#else
      DO p5b_in =ga_nodeid(),ga_nodeid()+nvab-1
         p5b=mod(p5b_in,nvab)+noab+1
         DO p6b_in=ga_nodeid(),ga_nodeid()+nvab+noab-p5b
            p6b=mod(p6b_in,noab+nvab-p5b+1)+p5b
#endif
      IF (int_mb(k_spin+p5b-1)+int_mb(k_spin+p6b-1) .eq. int_mb(k_spin+h
     &1b-1)+int_mb(k_spin+h2b-1)) THEN
      IF (ieor(int_mb(k_sym+p5b-1),ieor(int_mb(k_sym+p6b-1),ieor(int_mb(
     &k_sym+h1b-1),int_mb(k_sym+h2b-1)))) .eq. irrep_t) THEN
      CALL TCE_RESTRICTED_4(p5b,p6b,h1b,h2b,p5b_1,p6b_1,h1b_1,h2b_1)
      CALL TCE_RESTRICTED_4(p3b,p4b,p5b,p6b,p3b_2,p4b_2,p5b_2,p6b_2)
      dim_common = int_mb(k_range+p5b-1) * int_mb(k_range+p6b-1)
      dima_sort = int_mb(k_range+h1b-1) * int_mb(k_range+h2b-1)
      dima = dim_common * dima_sort
      dimb_sort = int_mb(k_range+p3b-1) * int_mb(k_range+p4b-1)
      dimb = dim_common * dimb_sort
      IF ((dima .gt. 0) .and. (dimb .gt. 0)) THEN
      IF (.not.MA_PUSH_GET(mt_dbl,dima,'as',l_as,k_as)) CALL
     & ERRQUIT('ccsd_t2_8',1,MA_ERR)
      IF (.not.MA_PUSH_GET(mt_dbl,dima,'a',l_a,k_a)) CALL ERRQUIT('
     &ccsd_t2_8',2,MA_ERR)
      CALL GET_HASH_BLOCK(d_a,dbl_mb(k_a),dima,int_mb(k_a_offset),(h2b_1
     & - 1 + noab * (h1b_1 - 1 + noab * (p6b_1 - noab - 1 + nvab * (p5b_
     &1 - noab - 1)))))
      CALL TCE_SORT_4(dbl_mb(k_a),dbl_mb(k_as),int_mb(k_range+p5b-1)
     &,int_mb(k_range+p6b-1),int_mb(k_range+h1b-1),int_mb(k_range+h2b-1)
     &,4,3,2,1,1.0d0)
      IF (.not.MA_POP_STACK(l_a)) CALL ERRQUIT('ccsd_t2_8',3,MA_ERR)
      IF (.not.MA_PUSH_GET(mt_dbl,dimb,'bs',l_bs,k_bs)) CALL
     & ERRQUIT('ccsd_t2_8',4,MA_ERR)
      IF (.not.MA_PUSH_GET(mt_dbl,dimb,'b',l_b,k_b)) CALL ERRQUIT('
     &ccsd_t2_8',5,MA_ERR)
      if(.not.intorb) then
      CALL GET_HASH_BLOCK(d_b,dbl_mb(k_b),dimb,int_mb(k_b_offset),(p6b_2
     & - 1 + (noab+nvab) * (p5b_2 - 1 + (noab+nvab) * (p4b_2 - 1 + (noab
     &+nvab) * (p3b_2 - 1)))))
      else
      CALL GET_HASH_BLOCK_I(d_b,dbl_mb(k_b),dimb,int_mb(k_b_offset),
     &(p6b_2
     & - 1 + (noab+nvab) * (p5b_2 - 1 + (noab+nvab) * (p4b_2 - 1 + (noab
     &+nvab) * (p3b_2 - 1)))),p6b_2,p5b_2,p4b_2,p3b_2)
      end if
      CALL TCE_SORT_4(dbl_mb(k_b),dbl_mb(k_bs),int_mb(k_range+p3b-1)
     &,int_mb(k_range+p4b-1),int_mb(k_range+p5b-1),int_mb(k_range+p6b-1)
     &,2,1,4,3,1.0d0)
      IF (.not.MA_POP_STACK(l_b)) CALL ERRQUIT('ccsd_t2_8',6,MA_ERR)
      nsuperp(1) = 1
      nsuperp(2) = 1
      isuperp = 1
      IF (p5b .eq. p6b) THEN
      nsuperp(isuperp) = nsuperp(isuperp) + 1
      ELSE
      isuperp = isuperp + 1
      END IF
      CALL DGEMM('T','N',dima_sort,dimb_sort,dim_common,2.0d0/FACTORIAL(
     &nsuperp(1))/FACTORIAL(nsuperp(2)),dbl_mb(k_as),dim_common,dbl_
     &mb(k_bs),dim_common,1.0d0,dbl_mb(k_cs),dima_sort)
      IF (.not.MA_POP_STACK(l_bs)) CALL ERRQUIT('ccsd_t2_8',7,MA_ERR
     &)
      IF (.not.MA_POP_STACK(l_as)) CALL ERRQUIT('ccsd_t2_8',8,MA_ERR
     &)
      END IF
      END IF
      END IF
      END DO
      END DO
      IF (.not.MA_PUSH_GET(mt_dbl,dimc,'c',l_c,k_c)) CALL ERRQUIT('
     &ccsd_t2_8',9,MA_ERR)
      CALL TCE_SORT_4(dbl_mb(k_cs),dbl_mb(k_c),int_mb(k_range+p4b-1)
     &,int_mb(k_range+p3b-1),int_mb(k_range+h2b-1),int_mb(k_range+h1b-1)
     &,2,1,4,3,1.0d0/2.0d0)
      CALL ADD_HASH_BLOCK(d_c,dbl_mb(k_c),dimc,int_mb(k_c_offset),(h2b -
     & 1 + noab * (h1b - 1 + noab * (p4b - noab - 1 + nvab * (p3b - noab
     & - 1)))))
      IF (.not.MA_POP_STACK(l_c)) CALL ERRQUIT('ccsd_t2_8',10,MA_ERR)
      IF (.not.MA_POP_STACK(l_cs)) CALL ERRQUIT('ccsd_t2_8',11,MA_ER
     &R)
      next = NXTASK(nprocs, 1)
      END IF
      count = count + 1
      END IF
      END IF
      END IF
      END DO
      END DO
      END DO
      END DO
      next = NXTASK(-nprocs, 1)
      call GA_SYNC()
      RETURN
      END

      SUBROUTINE ccsd_t2_8_test(d_a,k_a_offset,
     &                          d_b,k_b_offset,
     &                          d_c,k_c_offset,
     &                          maxh,maxp)
!     $Id: ccsd_t2.F 27404 2015-08-24 14:20:43Z jhammond $
!     This is a Fortran77 program generated by Tensor Contraction Engine v.1.0
!     Copyright (c) Battelle & Pacific Northwest National Laboratory (2002)
!     i0 ( p3 p4 h1 h2 )_vt + = 1/2 * Sum ( p5 p6 ) * t ( p5 p6 h1 h2 )_t * v ( p3 p4 p5 p6 )_v
      IMPLICIT NONE
#include "global.fh"
#include "mafdecls.fh"
#include "sym.fh"
#include "errquit.fh"
#include "tce.fh"
      INTEGER d_a,d_b,d_c
      INTEGER k_a_offset,k_b_offset,k_c_offset
      INTEGER maxh,maxp,dimhhpp,dimpppp
      INTEGER next,nprocs,count
      INTEGER p5b,p6b,p3b,p4b,h1b,h2b
      INTEGER p5b_1,p6b_1,h1b_1,h2b_1
      INTEGER p3b_2,p4b_2,p5b_2,p6b_2
      INTEGER dima,dimb,dimc,dim_common,dima_sort,dimb_sort
      integer :: h21d, p43d, p65d
#ifdef USE_F90_ALLOCATABLE
      double precision, allocatable :: f_a(:), f_b(:), f_c(:)
#ifdef USE_FASTMEM
      !dec$ attributes fastmem :: f_a,f_b,f_c
#endif
#else
      integer :: k_a, l_a, k_b, l_b, k_c, l_c
#endif
      integer :: e_a,e_b,e_c
      double precision :: alpha
      integer p5b_in,p6b_in
      INTEGER NXTASK
      EXTERNAL NXTASK
      nprocs = GA_NNODES()
      count = 0
      next = NXTASK(nprocs, 1)

      dimhhpp = maxh*maxh*maxp*maxp
      dimpppp = maxp*maxp*maxp*maxp

      e_a=0
      e_b=0
      e_c=0
#ifdef USE_F90_ALLOCATABLE
      allocate(f_a(1:dimhhpp),stat=e_a)
      allocate(f_b(1:dimpppp),stat=e_b)
      allocate(f_c(1:dimhhpp),stat=e_c)
#else
      if(.not.MA_PUSH_GET(mt_dbl,dimhhpp,"a",l_a,k_a)) e_a=-1
      if(.not.MA_PUSH_GET(mt_dbl,dimpppp,"b",l_b,k_b)) e_b=-1
      if(.not.MA_PUSH_GET(mt_dbl,dimhhpp,"c",l_c,k_c)) e_c=-1
#endif
      if (e_a.ne.0) call errquit("MA a",dimhhpp,MA_ERR)
      if (e_b.ne.0) call errquit("MA b",dimpppp,MA_ERR)
      if (e_c.ne.0) call errquit("MA c",dimhhpp,MA_ERR)
      DO p3b = noab+1,noab+nvab
       DO p4b = p3b,noab+nvab
        DO h1b = 1,noab
         DO h2b = h1b,noab
          IF ((.not.restricted).or.
     &        ( int_mb(k_spin+p3b-1)+int_mb(k_spin+p4b-1)
     &         +int_mb(k_spin+h1b-1)+int_mb(k_spin+h2b-1).ne.8)) THEN
           IF (int_mb(k_spin+p3b-1)+int_mb(k_spin+p4b-1) .eq.
     &         int_mb(k_spin+h1b-1)+int_mb(k_spin+h2b-1)) THEN
            IF (ieor(int_mb(k_sym+p3b-1),ieor(int_mb(k_sym+p4b-1),
     &          ieor(int_mb(k_sym+h1b-1),int_mb(k_sym+h2b-1))))
     &                 .eq. ieor(irrep_v,irrep_t)) THEN
             IF (next.eq.count) THEN
              dima_sort = int_mb(k_range+h1b-1)
     &                  * int_mb(k_range+h2b-1)
              dimb_sort = int_mb(k_range+p3b-1)
     &                  * int_mb(k_range+p4b-1)
              dimc = int_mb(k_range+p3b-1) * int_mb(k_range+p4b-1)
     &             * int_mb(k_range+h1b-1) * int_mb(k_range+h2b-1)
#ifdef USE_F90_ALLOCATABLE
              CALL DFILL(dimc,0.0d0,f_c,1)
#if 0
              DO p5b = noab+1,noab+nvab
               DO p6b = p5b,noab+nvab
#else
              DO p5b_in =ga_nodeid(),ga_nodeid()+nvab-1
                p5b=mod(p5b_in,nvab)+noab+1
                DO p6b_in=ga_nodeid(),ga_nodeid()+nvab+noab-p5b
                 p6b=mod(p6b_in,noab+nvab-p5b+1)+p5b
#endif
                IF (int_mb(k_spin+p5b-1)+int_mb(k_spin+p6b-1) .eq.
     &              int_mb(k_spin+h1b-1)+int_mb(k_spin+h2b-1)) THEN
                 IF (ieor(int_mb(k_sym+p5b-1),ieor(int_mb(k_sym+p6b-1),
     &               ieor(int_mb(k_sym+h1b-1),int_mb(k_sym+h2b-1))))
     &                      .eq. irrep_t) THEN
                  CALL TCE_RESTRICTED_4(p5b,p6b,h1b,h2b,
     &                                  p5b_1,p6b_1,h1b_1,h2b_1)
                  CALL TCE_RESTRICTED_4(p3b,p4b,p5b,p6b,
     &                                  p3b_2,p4b_2,p5b_2,p6b_2)
                  dim_common = int_mb(k_range+p5b-1)
     &                       * int_mb(k_range+p6b-1)
                  dima = dim_common * dima_sort
                  dimb = dim_common * dimb_sort
                  IF ((dima .gt. 0) .and. (dimb .gt. 0)) THEN
                   CALL GET_HASH_BLOCK(d_a,f_a,dima,
     &                  int_mb(k_a_offset),(h2b_1-1+noab*(h1b_1-1+noab*
     &                  (p6b_1-noab-1+nvab*(p5b_1-noab-1)))))
                   if(.not.intorb) then
                    CALL GET_HASH_BLOCK(d_b,f_b,dimb,
     &                   int_mb(k_b_offset),(p6b_2-1+(noab+nvab)*
     &                   (p5b_2-1+(noab+nvab)*(p4b_2-1+(noab+nvab)*
     &                   (p3b_2-1)))))
                   else
                    CALL GET_HASH_BLOCK_I(d_b,f_b,dimb,
     &                   int_mb(k_b_offset),(p6b_2-1+(noab+nvab)*
     &                   (p5b_2-1+(noab+nvab)*(p4b_2-1+(noab+nvab)*
     &                   (p3b_2-1)))),p6b_2,p5b_2,p4b_2,p3b_2)
                   end if
                   if (p5b .eq. p6b) then
                    alpha = 1.0d0
                   else
                    alpha = 2.0d0
                   end if
                   h21d = int_mb(k_range+h1b-1)*int_mb(k_range+h2b-1)
                   p43d = int_mb(k_range+p3b-1)*int_mb(k_range+p4b-1)
                   p65d = int_mb(k_range+p5b-1)*int_mb(k_range+p6b-1)
                   call DGEMM('n','n',h21d,p43d,p65d,
     &                         0.5d0*alpha,f_a,h21d,
     &                                     f_b,p65d,
     &                         1.0d0,      f_c,h21d)
                  END IF
                 END IF
                END IF
               END DO
              END DO
              CALL ADD_HASH_BLOCK(d_c,f_c,dimc,
     &             int_mb(k_c_offset),(h2b-1+noab*(h1b-1+noab*
     &             (p4b-noab-1+nvab*(p3b-noab-1)))))
#else 
              CALL DFILL(dimc,0.0d0,dbl_mb(k_c),1)
#if 0
              DO p5b = noab+1,noab+nvab
               DO p6b = p5b,noab+nvab
#else
              DO p5b_in =ga_nodeid(),ga_nodeid()+nvab-1
                p5b=mod(p5b_in,nvab)+noab+1
                DO p6b_in=ga_nodeid(),ga_nodeid()+nvab+noab-p5b
                 p6b=mod(p6b_in,noab+nvab-p5b+1)+p5b
#endif
                IF (int_mb(k_spin+p5b-1)+int_mb(k_spin+p6b-1) .eq.
     &              int_mb(k_spin+h1b-1)+int_mb(k_spin+h2b-1)) THEN
                 IF (ieor(int_mb(k_sym+p5b-1),ieor(int_mb(k_sym+p6b-1),
     &               ieor(int_mb(k_sym+h1b-1),int_mb(k_sym+h2b-1))))
     &                      .eq. irrep_t) THEN
                  CALL TCE_RESTRICTED_4(p5b,p6b,h1b,h2b,
     &                                  p5b_1,p6b_1,h1b_1,h2b_1)
                  CALL TCE_RESTRICTED_4(p3b,p4b,p5b,p6b,
     &                                  p3b_2,p4b_2,p5b_2,p6b_2)
                  dim_common = int_mb(k_range+p5b-1)
     &                       * int_mb(k_range+p6b-1)
                  dima = dim_common * dima_sort
                  dimb = dim_common * dimb_sort
                  IF ((dima .gt. 0) .and. (dimb .gt. 0)) THEN
                   CALL GET_HASH_BLOCK(d_a,dbl_mb(k_a),dima,
     &                  int_mb(k_a_offset),(h2b_1-1+noab*(h1b_1-1+noab*
     &                  (p6b_1-noab-1+nvab*(p5b_1-noab-1)))))
                   if(.not.intorb) then
                    CALL GET_HASH_BLOCK(d_b,dbl_mb(k_b),dimb,
     &                   int_mb(k_b_offset),(p6b_2-1+(noab+nvab)*
     &                   (p5b_2-1+(noab+nvab)*(p4b_2-1+(noab+nvab)*
     &                   (p3b_2-1)))))
                   else
                    CALL GET_HASH_BLOCK_I(d_b,dbl_mb(k_b),dimb,
     &                   int_mb(k_b_offset),(p6b_2-1+(noab+nvab)*
     &                   (p5b_2-1+(noab+nvab)*(p4b_2-1+(noab+nvab)*
     &                   (p3b_2-1)))),p6b_2,p5b_2,p4b_2,p3b_2)
                   end if
                   if (p5b .eq. p6b) then
                    alpha = 1.0d0
                   else
                    alpha = 2.0d0
                   end if
                   h21d = int_mb(k_range+h1b-1)*int_mb(k_range+h2b-1)
                   p43d = int_mb(k_range+p3b-1)*int_mb(k_range+p4b-1)
                   p65d = int_mb(k_range+p5b-1)*int_mb(k_range+p6b-1)
                   call DGEMM('n','n',h21d,p43d,p65d,
     &                         0.5d0*alpha,dbl_mb(k_a),h21d,
     &                                     dbl_mb(k_b),p65d,
     &                         1.0d0,      dbl_mb(k_c),h21d)
                  END IF
                 END IF
                END IF
               END DO
              END DO
              CALL ADD_HASH_BLOCK(d_c,dbl_mb(k_c),dimc,
     &             int_mb(k_c_offset),(h2b-1+noab*(h1b-1+noab*
     &             (p4b-noab-1+nvab*(p3b-noab-1)))))
#endif 
              next = NXTASK(nprocs, 1)
             END IF
             count = count + 1
            END IF
           END IF
          END IF
         END DO
        END DO
       END DO
      END DO
      next = NXTASK(-nprocs, 1)
      call GA_SYNC()

#ifdef USE_F90_ALLOCATABLE
      deallocate(f_a,stat=e_a)
      deallocate(f_b,stat=e_b)
      deallocate(f_c,stat=e_c)
#else
      e_a=0
      if(.not.MA_CHOP_STACK(l_a)) e_a=-1
#endif
      if (e_a.ne.0) call errquit("MA pops a",0,MA_ERR)
      RETURN
      END



      SUBROUTINE ccsd_t2_8_spiral(d_a,k_a_offset,d_b,k_b_offset,
     1                            d_c,k_c_offset)
!     $Id: ccsd_t2.F 27404 2015-08-24 14:20:43Z jhammond $
!     This is a Fortran77 program generated by Tensor Contraction Engine v.1.0
!     Copyright (c) Battelle & Pacific Northwest National Laboratory (2002)
!     i0 ( p3 p4 h1 h2 )_vt + = 1/2 * Sum ( p5 p6 ) * t ( p5 p6 h1 h2 )_t * v ( p3 p4 p5 p6 )_v
      IMPLICIT NONE
#include "global.fh"
#include "mafdecls.fh"
#include "sym.fh"
#include "errquit.fh"
#include "tce.fh"
#include "tce_main.fh"
      integer d_a, d_b, d_c
      integer k_a_offset, k_b_offset, k_c_offset
      integer NXTASK, next, nprocs, count
      integer p3b, p4b, h1b, h2b, p5b, p6b
      integer p5b_1, p6b_1, h1b_1, h2b_1, p3b_2, p4b_2, p5b_2, p6b_2
      integer dim1,dim2,dim3,dim4,dim5,dim6
      integer dim12,dim34,dim56
      integer dima,dimb,dimc
      integer spn1,spn2,spn3,spn4,spn5,spn6
      integer spn12,spn34,spn56
      integer sym1,sym2,sym3,sym4,sym5,sym6
      integer sym12,sym34,sym56
      integer k_as, l_as, k_a, l_a
      integer k_bs, l_bs, k_b, l_b
      integer k_cs, l_cs, k_c, l_c
      integer nbh
      double precision alpha
      external NXTASK
!
!      print*,'entering ccsd_t2_8_spiral (energy)'
!
      nprocs = ga_nnodes()
      count = 0
      next = nxtask(nprocs, 1)
!
      if (.not.ma_push_get(mt_dbl,tile_dim**4,'c',l_c,k_c))
     1     call errquit('ccsd_t2_8',9,MA_ERR)
!
      do p3b = noab+1,noab+nvab
       dim3=int_mb(k_range+p3b-1)
       spn3=int_mb(k_spin +p3b-1)
       sym3=int_mb(k_sym  +p3b-1)
       do p4b = p3b,noab+nvab
        dim4=int_mb(k_range+p4b-1)
        spn4=int_mb(k_spin +p4b-1)
        sym4=int_mb(k_sym  +p4b-1)
!
        dim34 = dim3 * dim4
        spn34 = spn3 + spn4
        sym34 = ieor(sym3,sym4)
!
        do p5b = noab+1,noab+nvab
         dim5=int_mb(k_range+p5b-1)
         spn5=int_mb(k_spin +p5b-1)
         sym5=int_mb(k_sym  +p5b-1)
         do p6b = p5b,noab+nvab
          dim6=int_mb(k_range+p6b-1)
          spn6=int_mb(k_spin +p6b-1)
          sym6=int_mb(k_sym  +p6b-1)
!
          dim56 = dim5 * dim6
          spn56 = spn5 + spn6
          sym56 = ieor(sym5,sym6)
!
          dimb  = dim34 * dim56
!
          if ( (dimb.gt.0) .and. (ieor(sym34,sym56).eq.0)
     1         .and. (spn34.eq.spn56) ) then
!
          if (next.eq.count) then
!
           call tce_restricted_4(p3b,p4b,p5b,p6b,
     1                           p3b_2,p4b_2,p5b_2,p6b_2)
!
           if (.not.ma_push_get(mt_dbl,dimb,'bs',l_bs,k_bs))
     1              call errquit('ccsd_t2_8',4,MA_ERR)
           if (.not.ma_push_get(mt_dbl,dimb,'b',l_b,k_b))
     1              call errquit('ccsd_t2_8',5,MA_ERR)
!
           if(.not.intorb) then
            call get_hash_block(d_b,dbl_mb(k_b),dimb,
     1           int_mb(k_b_offset),
     2           (p6b_2 - 1 + (noab+nvab) * (p5b_2 - 1 +
     3           (noab+nvab) * (p4b_2 - 1 + (noab+nvab) *
     4           (p3b_2 - 1)))))
           else
            call get_hash_block_i(d_b,dbl_mb(k_b),dimb,
     1           int_mb(k_b_offset),
     2           (p6b_2 - 1 + (noab+nvab) * (p5b_2 - 1 +
     3           (noab+nvab) * (p4b_2 - 1 + (noab+nvab) *
     4           (p3b_2 - 1)))),p6b_2,p5b_2,p4b_2,p3b_2)
           end if
!
           call tce_sort_4(dbl_mb(k_b),dbl_mb(k_bs),
     1          dim3,dim4,dim5,dim6,2,1,4,3,1.0d0)
!
           if (.not.ma_pop_stack(l_b))
     1              call errquit('ccsd_t2_8',6,MA_ERR)
!
           do h1b = 1,noab
            dim1=int_mb(k_range+h1b-1)
            spn1=int_mb(k_spin +h1b-1)
            sym1=int_mb(k_sym  +h1b-1)
            do h2b = h1b,noab
             dim2=int_mb(k_range+h2b-1)
             spn2=int_mb(k_spin +h2b-1)
             sym2=int_mb(k_sym  +h2b-1)
!
             dim12 = dim1 * dim2
             spn12 = spn1 + spn2
             sym12 = ieor(sym1,sym2)
!
             dima  = dim12 * dim56
!
             if (dima.gt.0) then
!
              call tce_restricted_4(p5b,p6b,h1b,h2b,
     1                              p5b_1,p6b_1,h1b_1,h2b_1)
!
              if (spn34.eq.spn12) then
               if (spn56.eq.spn12) then
                if ((.not.restricted).or.((spn34+spn12).ne.8)) then
                 if (ieor(sym34,sym12).eq.0) then
                  if (ieor(sym56,sym12).eq.0) then
!
                   dimc  = dim12 * dim34
!
                   if (.not.ma_push_get(mt_dbl,dimc,'cs',l_cs,k_cs))
     1                 call errquit('ccsd_t2_8',0,MA_ERR)
!
                   call dfill(dimc,0.0d0,dbl_mb(k_cs),1)
!
                   if (.not.ma_push_get(mt_dbl,dima,'as',l_as,k_as))
     1                 call errquit('ccsd_t2_8',1,MA_ERR)
                   if (.not.ma_push_get(mt_dbl,dima,'a',l_a,k_a))
     1                 call errquit('ccsd_t2_8',2,MA_ERR)
!
                   call get_hash_block(d_a,dbl_mb(k_a),dima,
     1                  int_mb(k_a_offset),
     2                  (h2b_1 - 1 + noab * (h1b_1 - 1 + noab *
     3                  (p6b_1 - noab - 1 + nvab *
     4                  (p5b_1 - noab - 1)))))
!
                   call tce_sort_4(dbl_mb(k_a),dbl_mb(k_as),
     1                  dim5,dim6,dim1,dim2,4,3,2,1,1.0d0)
!
                   if (.not.ma_pop_stack(l_a))
     1                 call errquit('ccsd_t2_8',3,MA_ERR)
!
                   if (p5b .eq. p6b) then
                    alpha = 1.0d0
                   else
                    alpha = 2.0d0
                   end if
                   call dgemm('T','N',dim12,dim34,dim56,alpha,
     2                  dbl_mb(k_as),dim56,dbl_mb(k_bs),dim56,
     3                  1.0d0,dbl_mb(k_cs),dim12)
!
                   if (.not.ma_pop_stack(l_as))
     1                 call errquit('ccsd_t2_8',8,MA_ERR)
!
                   call ga_nbwait(nbh) ! wait until previous put of c is gone before overwriting buffer
!
                   call tce_sort_4(dbl_mb(k_cs),dbl_mb(k_c),
     1                  dim4,dim3,dim2,dim1,2,1,4,3,0.5d0)
!
                   call add_hash_block_nb(d_c,dbl_mb(k_c),dimc,
     1                  int_mb(k_c_offset),(h2b-1+noab*(h1b-1+noab*
     2                  (p4b-noab-1+nvab*(p3b-noab-1)))),nbh)
!
                   if (.not.ma_pop_stack(l_cs))
     1                 call errquit('ccsd_t2_8',11,MA_ERR)
!
                  end if
                 end if
                end if
               end if
              end if
!
             endif ! dima>0
!
            end do
           end do
!
           if (.not.ma_pop_stack(l_bs))
     1              call errquit('ccsd_t2_8',7,MA_ERR)
!
            next = NXTASK(nprocs, 1)
           end if ! next=count
           count = count + 1
!
          endif ! dimb>0
!
         end do
        end do
       end do
      end do
!
      if (.not.ma_pop_stack(l_c))
     1    call errquit('ccsd_t2_8',10,MA_ERR)
!
      next = NXTASK(-nprocs, 1)
      call ga_sync()
      RETURN
      END

      SUBROUTINE ccsd_t2_8_task_dgemm(d_a,k_a_offset,
     &                                d_b,k_b_offset,
     &                                d_c,k_c_offset,
     &                                maxh,maxp)
!     $Id: ccsd_t2.F 27404 2015-08-24 14:20:43Z jhammond $
!     This is a Fortran77 program generated by Tensor Contraction Engine v.1.0
!     Copyright (c) Battelle & Pacific Northwest National Laboratory (2002)
!     i0 ( p3 p4 h1 h2 )_vt + = 1/2 * Sum ( p5 p6 ) * t ( p5 p6 h1 h2 )_t * v ( p3 p4 p5 p6 )_v
      IMPLICIT NONE
#include "global.fh"
#include "mafdecls.fh"
#include "sym.fh"
#include "errquit.fh"
#include "tce.fh"
      integer :: d_a,d_b,d_c
      integer :: k_a_offset,k_b_offset,k_c_offset
      integer :: maxh,maxp,dimhhpp,dimpppp,dimtemp
      integer :: next,nprocs,count
      integer :: p5b,p6b,p3b,p4b,h1b,h2b
      integer :: p5b_1,p6b_1,h1b_1,h2b_1
      integer :: p3b_2,p4b_2,p5b_2,p6b_2
      integer :: dima,dimb,dimc,dim_common,dima_sort,dimb_sort
      double precision, allocatable :: f_a(:)
      double precision, allocatable :: f_b(:)
      double precision, allocatable :: f_c(:)
      double precision, allocatable :: f_t(:)
#ifdef USE_FASTMEM
      !dec$ attributes fastmem :: f_a,f_b,f_c,f_t
#endif
      integer :: e_a,e_b,e_c,e_t
      double precision alpha
      integer p5b_in,p6b_in,me
      integer NXTASK
      external NXTASK
      nprocs = GA_NNODES()
      count = 0
      next = NXTASK(nprocs, 1)

      me = ga_nodeid()

      dimhhpp = maxh*maxh*maxp*maxp
      dimpppp = maxp*maxp*maxp*maxp
      dimtemp = max(dimpppp,dimhhpp)

      allocate(f_a(1:dimhhpp),stat=e_a)
      allocate(f_b(1:dimpppp),stat=e_b)
      allocate(f_c(1:dimhhpp),stat=e_c)
      allocate(f_t(1:dimtemp),stat=e_t)
      if (e_a.ne.0) call errquit("alloc a",dimhhpp,MA_ERR)
      if (e_b.ne.0) call errquit("alloc b",dimpppp,MA_ERR)
      if (e_c.ne.0) call errquit("alloc c",dimhhpp,MA_ERR)
      if (e_t.ne.0) call errquit("alloc t",dimtemp,MA_ERR)
      DO p3b = noab+1,noab+nvab
       DO p4b = p3b,noab+nvab
        DO h1b = 1,noab
         DO h2b = h1b,noab
          IF ((.not.restricted).or.
     &        ( int_mb(k_spin+p3b-1)+int_mb(k_spin+p4b-1)
     &         +int_mb(k_spin+h1b-1)+int_mb(k_spin+h2b-1).ne.8)) THEN
           IF (int_mb(k_spin+p3b-1)+int_mb(k_spin+p4b-1) .eq.
     &         int_mb(k_spin+h1b-1)+int_mb(k_spin+h2b-1)) THEN
            IF (ieor(int_mb(k_sym+p3b-1),ieor(int_mb(k_sym+p4b-1),
     &          ieor(int_mb(k_sym+h1b-1),int_mb(k_sym+h2b-1))))
     &                 .eq. ieor(irrep_v,irrep_t)) THEN
             IF (next.eq.count) THEN
              dima_sort = int_mb(k_range+h1b-1)
     &                  * int_mb(k_range+h2b-1)
              dimb_sort = int_mb(k_range+p3b-1)
     &                  * int_mb(k_range+p4b-1)
              dimc = int_mb(k_range+p3b-1) * int_mb(k_range+p4b-1)
     &             * int_mb(k_range+h1b-1) * int_mb(k_range+h2b-1)
              CALL DFILL(dimc,0.0d0,f_c,1)
              DO p5b_in =me,me+nvab-1
                 p5b=mod(p5b_in,nvab)+noab+1
               DO p6b_in=me,me+nvab+noab-p5b
                  p6b=mod(p6b_in,noab+nvab-p5b+1)+p5b
                IF (int_mb(k_spin+p5b-1)+int_mb(k_spin+p6b-1) .eq.
     &              int_mb(k_spin+h1b-1)+int_mb(k_spin+h2b-1)) THEN
                 IF (ieor(int_mb(k_sym+p5b-1),ieor(int_mb(k_sym+p6b-1),
     &               ieor(int_mb(k_sym+h1b-1),int_mb(k_sym+h2b-1))))
     &                      .eq. irrep_t) THEN
                  CALL TCE_RESTRICTED_4(p5b,p6b,h1b,h2b,
     &                                  p5b_1,p6b_1,h1b_1,h2b_1)
                  CALL TCE_RESTRICTED_4(p3b,p4b,p5b,p6b,
     &                                  p3b_2,p4b_2,p5b_2,p6b_2)
                  dim_common = int_mb(k_range+p5b-1)
     &                       * int_mb(k_range+p6b-1)
                  dima = dim_common * dima_sort
                  dimb = dim_common * dimb_sort
                  IF ((dima .gt. 0) .and. (dimb .gt. 0)) THEN
                   CALL GET_HASH_BLOCK(d_a,f_t,dima,
     &                  int_mb(k_a_offset),(h2b_1-1+noab*(h1b_1-1+noab*
     &                  (p6b_1-noab-1+nvab*(p5b_1-noab-1)))))
                   CALL TCE_SORT_4(f_t,f_a,
     &                  int_mb(k_range+p5b-1),int_mb(k_range+p6b-1),
     &                  int_mb(k_range+h1b-1),int_mb(k_range+h2b-1),
     &                  4,3,2,1,1.0d0)
                   if(.not.intorb) then
                    CALL GET_HASH_BLOCK(d_b,f_t,dimb,
     &                   int_mb(k_b_offset),(p6b_2-1+(noab+nvab)*
     &                   (p5b_2-1+(noab+nvab)*(p4b_2-1+(noab+nvab)*
     &                   (p3b_2-1)))))
                   else
                    CALL GET_HASH_BLOCK_I(d_b,f_t,dimb,
     &                   int_mb(k_b_offset),(p6b_2-1+(noab+nvab)*
     &                   (p5b_2-1+(noab+nvab)*(p4b_2-1+(noab+nvab)*
     &                   (p3b_2-1)))),p6b_2,p5b_2,p4b_2,p3b_2)
                   end if
                   CALL TCE_SORT_4(f_t,f_b,
     &                  int_mb(k_range+p3b-1),int_mb(k_range+p4b-1),
     &                  int_mb(k_range+p5b-1),int_mb(k_range+p6b-1),
     &                  2,1,4,3,1.0d0)
                   if (p5b .eq. p6b) then
                    alpha = 1.0d0
                   else
                    alpha = 2.0d0
                   end if
                   CALL DGEMM('T','N',dima_sort,dimb_sort,dim_common,
     &                  alpha,f_a,dim_common,f_b,
     &                  dim_common,1.0d0,f_c,dima_sort)
                  END IF
                 END IF
                END IF
               END DO
              END DO
              CALL TCE_SORT_4(f_c,f_t,
     &             int_mb(k_range+p4b-1),int_mb(k_range+p3b-1),
     &             int_mb(k_range+h2b-1),int_mb(k_range+h1b-1),
     &             2,1,4,3,0.5d0)
              CALL ADD_HASH_BLOCK(d_c,f_t,dimc,
     &             int_mb(k_c_offset),(h2b-1+noab*(h1b-1+noab*
     &             (p4b-noab-1+nvab*(p3b-noab-1)))))
              next = NXTASK(nprocs, 1)
             END IF
             count = count + 1
            END IF
           END IF
          END IF
         END DO
        END DO
       END DO
      END DO
      next = NXTASK(-nprocs, 1)
      call GA_SYNC()
      deallocate(f_a,stat=e_a)
      deallocate(f_b,stat=e_b)
      deallocate(f_c,stat=e_c)
      deallocate(f_t,stat=e_t)
      if (e_a.ne.0) call errquit("free a",0,MA_ERR)
      if (e_b.ne.0) call errquit("free b",1,MA_ERR)
      if (e_c.ne.0) call errquit("free c",2,MA_ERR)
      if (e_t.ne.0) call errquit("free t",3,MA_ERR)
      RETURN
      END


      SUBROUTINE ccsd_t2_8_task_loops(d_a,k_a_offset,
     &                                d_b,k_b_offset,
     &                                d_c,k_c_offset,
     &                                maxh,maxp)
!     $Id: ccsd_t2.F 27404 2015-08-24 14:20:43Z jhammond $
!     This is a Fortran77 program generated by Tensor Contraction Engine v.1.0
!     Copyright (c) Battelle & Pacific Northwest National Laboratory (2002)
!     i0 ( p3 p4 h1 h2 )_vt + = 1/2 * Sum ( p5 p6 ) * t ( p5 p6 h1 h2 )_t * v ( p3 p4 p5 p6 )_v
      IMPLICIT NONE
#include "global.fh"
#include "mafdecls.fh"
#include "sym.fh"
#include "errquit.fh"
#include "tce.fh"
      integer :: d_a,d_b,d_c
      integer :: k_a_offset,k_b_offset,k_c_offset
      integer :: maxh,maxp,dimhhpp,dimpppp,dimtemp
      integer :: next,nprocs,count
      integer :: p5b,p6b,p3b,p4b,h1b,h2b
      integer :: p5b_1,p6b_1,h1b_1,h2b_1
      integer :: p3b_2,p4b_2,p5b_2,p6b_2
      integer :: dima,dimb,dimc,dim_common,dima_sort,dimb_sort
      double precision, allocatable :: f_a(:)
      double precision, allocatable :: f_b(:)
      double precision, allocatable :: f_c(:)
#ifdef USE_FASTMEM
      !dec$ attributes fastmem :: f_a,f_b,f_c
#endif
      integer :: e_a,e_b,e_c
      double precision alpha
      integer p5b_in,p6b_in,me
      integer NXTASK
      external NXTASK
      nprocs = GA_NNODES()
      count = 0
      next = NXTASK(nprocs, 1)

      me = ga_nodeid()

      dimhhpp = maxh*maxh*maxp*maxp
      dimpppp = maxp*maxp*maxp*maxp
      dimtemp = max(dimpppp,dimhhpp)

      allocate(f_a(1:dimhhpp),stat=e_a)
      allocate(f_b(1:dimpppp),stat=e_b)
      allocate(f_c(1:dimhhpp),stat=e_c)
      if (e_a.ne.0) call errquit("alloc a",dimhhpp,MA_ERR)
      if (e_b.ne.0) call errquit("alloc b",dimpppp,MA_ERR)
      if (e_c.ne.0) call errquit("alloc c",dimhhpp,MA_ERR)
      DO p3b = noab+1,noab+nvab
       DO p4b = p3b,noab+nvab
        DO h1b = 1,noab
         DO h2b = h1b,noab
          IF ((.not.restricted).or.
     &        ( int_mb(k_spin+p3b-1)+int_mb(k_spin+p4b-1)
     &         +int_mb(k_spin+h1b-1)+int_mb(k_spin+h2b-1).ne.8)) THEN
           IF (int_mb(k_spin+p3b-1)+int_mb(k_spin+p4b-1) .eq.
     &         int_mb(k_spin+h1b-1)+int_mb(k_spin+h2b-1)) THEN
            IF (ieor(int_mb(k_sym+p3b-1),ieor(int_mb(k_sym+p4b-1),
     &          ieor(int_mb(k_sym+h1b-1),int_mb(k_sym+h2b-1))))
     &                 .eq. ieor(irrep_v,irrep_t)) THEN
             IF (next.eq.count) THEN
              dima_sort = int_mb(k_range+h1b-1)
     &                  * int_mb(k_range+h2b-1)
              dimb_sort = int_mb(k_range+p3b-1)
     &                  * int_mb(k_range+p4b-1)
              dimc = int_mb(k_range+p3b-1) * int_mb(k_range+p4b-1)
     &             * int_mb(k_range+h1b-1) * int_mb(k_range+h2b-1)
              CALL DFILL(dimc,0.0d0,f_c,1)
              DO p5b_in =me,me+nvab-1
                 p5b=mod(p5b_in,nvab)+noab+1
               DO p6b_in=me,me+nvab+noab-p5b
                  p6b=mod(p6b_in,noab+nvab-p5b+1)+p5b
                IF (int_mb(k_spin+p5b-1)+int_mb(k_spin+p6b-1) .eq.
     &              int_mb(k_spin+h1b-1)+int_mb(k_spin+h2b-1)) THEN
                 IF (ieor(int_mb(k_sym+p5b-1),ieor(int_mb(k_sym+p6b-1),
     &               ieor(int_mb(k_sym+h1b-1),int_mb(k_sym+h2b-1))))
     &                      .eq. irrep_t) THEN
                  CALL TCE_RESTRICTED_4(p5b,p6b,h1b,h2b,
     &                                  p5b_1,p6b_1,h1b_1,h2b_1)
                  CALL TCE_RESTRICTED_4(p3b,p4b,p5b,p6b,
     &                                  p3b_2,p4b_2,p5b_2,p6b_2)
                  dim_common = int_mb(k_range+p5b-1)
     &                       * int_mb(k_range+p6b-1)
                  dima = dim_common * dima_sort
                  dimb = dim_common * dimb_sort
                  IF ((dima .gt. 0) .and. (dimb .gt. 0)) THEN
                   CALL GET_HASH_BLOCK(d_a,f_a,dima,
     &                  int_mb(k_a_offset),(h2b_1-1+noab*(h1b_1-1+noab*
     &                  (p6b_1-noab-1+nvab*(p5b_1-noab-1)))))
                   if(.not.intorb) then
                    CALL GET_HASH_BLOCK(d_b,f_b,dimb,
     &                   int_mb(k_b_offset),(p6b_2-1+(noab+nvab)*
     &                   (p5b_2-1+(noab+nvab)*(p4b_2-1+(noab+nvab)*
     &                   (p3b_2-1)))))
                   else
                    CALL GET_HASH_BLOCK_I(d_b,f_b,dimb,
     &                   int_mb(k_b_offset),(p6b_2-1+(noab+nvab)*
     &                   (p5b_2-1+(noab+nvab)*(p4b_2-1+(noab+nvab)*
     &                   (p3b_2-1)))),p6b_2,p5b_2,p4b_2,p3b_2)
                   end if
                   if (p5b .eq. p6b) then
                    alpha = 1.0d0
                   else
                    alpha = 2.0d0
                   end if
                   call t2_p8(int_mb(k_range+h1b-1),
     &                        int_mb(k_range+h2b-1),
     &                        int_mb(k_range+p3b-1),
     &                        int_mb(k_range+p4b-1),
     &                        int_mb(k_range+p5b-1),
     &                        int_mb(k_range+p6b-1),
     &                        f_a,f_b,f_c,
     &                        0.5d0*alpha)
                  END IF
                 END IF
                END IF
               END DO
              END DO
              CALL ADD_HASH_BLOCK(d_c,f_c,dimc,
     &             int_mb(k_c_offset),(h2b-1+noab*(h1b-1+noab*
     &             (p4b-noab-1+nvab*(p3b-noab-1)))))
              next = NXTASK(nprocs, 1)
             END IF
             count = count + 1
            END IF
           END IF
          END IF
         END DO
        END DO
       END DO
      END DO
      next = NXTASK(-nprocs, 1)
      call GA_SYNC()
      deallocate(f_a,stat=e_a)
      deallocate(f_b,stat=e_b)
      deallocate(f_c,stat=e_c)
      if (e_a.ne.0) call errquit("free a",0,MA_ERR)
      if (e_b.ne.0) call errquit("free b",0,MA_ERR)
      if (e_c.ne.0) call errquit("free t",0,MA_ERR)
      RETURN
      END


      integer function ccsd_t2_8_count()
      IMPLICIT NONE
#include "global.fh"
#include "mafdecls.fh"
#include "sym.fh"
#include "errquit.fh"
#include "tce.fh"
      integer :: n
      integer :: p5b,p6b,p3b,p4b,h1b,h2b
      n = 0
      DO p3b = noab+1,noab+nvab
       DO p4b = p3b,noab+nvab
        DO h1b = 1,noab
         DO h2b = h1b,noab
          IF ((.not.restricted).or.
     &        ( int_mb(k_spin+p3b-1)+int_mb(k_spin+p4b-1)
     &         +int_mb(k_spin+h1b-1)+int_mb(k_spin+h2b-1).ne.8)) THEN
           IF (int_mb(k_spin+p3b-1)+int_mb(k_spin+p4b-1) .eq.
     &         int_mb(k_spin+h1b-1)+int_mb(k_spin+h2b-1)) THEN
            IF (ieor(int_mb(k_sym+p3b-1),ieor(int_mb(k_sym+p4b-1),
     &          ieor(int_mb(k_sym+h1b-1),int_mb(k_sym+h2b-1))))
     &                 .eq. ieor(irrep_v,irrep_t)) THEN
             !DO p5b = noab+1,noab+nvab
             ! DO p6b = p5b,noab+nvab
             !  IF (int_mb(k_spin+p5b-1)+int_mb(k_spin+p6b-1) .eq.
     &       !      int_mb(k_spin+h1b-1)+int_mb(k_spin+h2b-1)) THEN
             !   IF (ieor(int_mb(k_sym+p5b-1),ieor(int_mb(k_sym+p6b-1),
     &       !       ieor(int_mb(k_sym+h1b-1),int_mb(k_sym+h2b-1))))
     &       !              .eq. irrep_t) THEN
                 n = n+1
             !   END IF
             !  END IF
             ! END DO
             !END DO
            END IF
           END IF
          END IF
         END DO
        END DO
       END DO
      END DO
      ccsd_t2_8_count = n
      RETURN
      END

      subroutine ccsd_t2_8_make_list(num_tasks, task_list)
      IMPLICIT NONE
#include "global.fh"
#include "mafdecls.fh"
#include "sym.fh"
#include "errquit.fh"
#include "tce.fh"
      integer, intent(in) :: num_tasks
      integer, intent(inout) :: task_list(4,num_tasks)
      integer :: p5b,p6b,p3b,p4b,h1b,h2b
      integer :: i
      i = 0
      DO p3b = noab+1,noab+nvab
       DO p4b = p3b,noab+nvab
        DO h1b = 1,noab
         DO h2b = h1b,noab
          IF ((.not.restricted).or.
     &        ( int_mb(k_spin+p3b-1)+int_mb(k_spin+p4b-1)
     &         +int_mb(k_spin+h1b-1)+int_mb(k_spin+h2b-1).ne.8)) THEN
           IF (int_mb(k_spin+p3b-1)+int_mb(k_spin+p4b-1) .eq.
     &         int_mb(k_spin+h1b-1)+int_mb(k_spin+h2b-1)) THEN
            IF (ieor(int_mb(k_sym+p3b-1),ieor(int_mb(k_sym+p4b-1),
     &          ieor(int_mb(k_sym+h1b-1),int_mb(k_sym+h2b-1))))
     &                 .eq. ieor(irrep_v,irrep_t)) THEN
             !DO p5b = noab+1,noab+nvab
             ! DO p6b = p5b,noab+nvab
             !  IF (int_mb(k_spin+p5b-1)+int_mb(k_spin+p6b-1) .eq.
     &       !      int_mb(k_spin+h1b-1)+int_mb(k_spin+h2b-1)) THEN
             !   IF (ieor(int_mb(k_sym+p5b-1),ieor(int_mb(k_sym+p6b-1),
     &       !       ieor(int_mb(k_sym+h1b-1),int_mb(k_sym+h2b-1))))
     &       !              .eq. irrep_t) THEN
                  i = i + 1
                  task_list(1,i) = p3b
                  task_list(2,i) = p4b
                  task_list(3,i) = h1b
                  task_list(4,i) = h2b
             !     task_list(5,i) = p5b
             !     task_list(6,i) = p6b
             !   END IF
             !  END IF
             ! END DO
             !END DO
            END IF
           END IF
          END IF
         END DO
        END DO
       END DO
      END DO
      RETURN
      END

#if defined(USE_OPENMP) && defined(USE_OPENMP_TASKS)

      SUBROUTINE ccsd_t2_8_loops_exec(d_a,k_a_offset,
     &                                d_b,k_b_offset,
     &                                d_c,k_c_offset,
     &                                maxh,maxp,
     &                                num_tasks,task_list)
      IMPLICIT NONE
#include "global.fh"
#include "mafdecls.fh"
#include "sym.fh"
#include "errquit.fh"
#include "tce.fh"
      integer, intent(in) :: d_a,d_b,d_c
      integer, intent(in) :: k_a_offset,k_b_offset,k_c_offset
      integer, intent(in) :: maxh,maxp
      integer, intent(in) :: num_tasks
      integer, intent(in) :: task_list(4,num_tasks)
      integer :: dimhhpp,dimpppp
      integer :: p5b,p6b,p3b,p4b,h1b,h2b
      integer :: p5b_1,p6b_1,h1b_1,h2b_1
      integer :: p3b_2,p4b_2,p5b_2,p6b_2
      integer :: dima,dimb,dimc,dim_common,dima_sort,dimb_sort
      double precision, allocatable :: f_a(:)
      double precision, allocatable :: f_b(:)
      double precision, allocatable :: f_c(:)
#ifdef USE_FASTMEM
      !dec$ attributes fastmem :: f_a,f_b,f_c
#endif
      integer :: e_a,e_b,e_c
      double precision :: alpha
      integer :: p5b_in,p6b_in
      integer :: me,np
      integer :: i

      me = ga_nodeid()
      np = ga_nnodes()

      dimhhpp = maxh*maxh*maxp*maxp
      dimpppp = maxp*maxp*maxp*maxp
!$omp parallel private(f_a,f_b,f_c,e_a,e_b,e_c)
      allocate(f_a(1:dimhhpp),stat=e_a)
      allocate(f_b(1:dimpppp),stat=e_b)
      allocate(f_c(1:dimhhpp),stat=e_c)
      if (e_a.ne.0) call errquit("alloc a",dimhhpp,MA_ERR)
      if (e_b.ne.0) call errquit("alloc b",dimpppp,MA_ERR)
      if (e_c.ne.0) call errquit("alloc c",dimhhpp,MA_ERR)
!$omp master
      do i = 1, num_tasks
        if (mod(i,np).eq.me) then
!$omp task private(p3b,p4b,h1b,h2b,p5b_in,p5b,p6b_in,p6b)
!$omp&     private(p5b_1,p6b_1,h1b_1,h2b_1,p3b_2,p4b_2,p5b_2,p6b_2)
!$omp&     private(dima,dimb,dimc,dim_common,dima_sort,dimb_sort)
!$omp&     private(alpha)
          p3b = task_list(1,i)
          p4b = task_list(2,i)
          h1b = task_list(3,i)
          h2b = task_list(4,i)
          dima_sort = int_mb(k_range+h1b-1)
     &              * int_mb(k_range+h2b-1)
          dimb_sort = int_mb(k_range+p3b-1)
     &              * int_mb(k_range+p4b-1)
          dimc = int_mb(k_range+p3b-1) * int_mb(k_range+p4b-1)
     &         * int_mb(k_range+h1b-1) * int_mb(k_range+h2b-1)
          CALL DFILL(dimc,0.0d0,f_c,1)
          DO p5b_in =me,me+nvab-1
             p5b=mod(p5b_in,nvab)+noab+1
           DO p6b_in=me,me+nvab+noab-p5b
              p6b=mod(p6b_in,noab+nvab-p5b+1)+p5b
            IF (int_mb(k_spin+p5b-1)+int_mb(k_spin+p6b-1) .eq.
     &          int_mb(k_spin+h1b-1)+int_mb(k_spin+h2b-1)) THEN
             IF (ieor(int_mb(k_sym+p5b-1),ieor(int_mb(k_sym+p6b-1),
     &           ieor(int_mb(k_sym+h1b-1),int_mb(k_sym+h2b-1))))
     &                  .eq. irrep_t) THEN
              CALL TCE_RESTRICTED_4(p5b,p6b,h1b,h2b,
     &                              p5b_1,p6b_1,h1b_1,h2b_1)
              CALL TCE_RESTRICTED_4(p3b,p4b,p5b,p6b,
     &                              p3b_2,p4b_2,p5b_2,p6b_2)
              dim_common = int_mb(k_range+p5b-1)
     &                   * int_mb(k_range+p6b-1)
              dima = dim_common * dima_sort
              dimb = dim_common * dimb_sort
              IF ((dima .gt. 0) .and. (dimb .gt. 0)) THEN
               CALL GET_HASH_BLOCK_R(d_a,f_a,dima,
     &              int_mb(k_a_offset),(h2b_1-1+noab*(h1b_1-1+noab*
     &              (p6b_1-noab-1+nvab*(p5b_1-noab-1)))))
               if(.not.intorb) then
                CALL GET_HASH_BLOCK_R(d_b,f_b,dimb,
     &               int_mb(k_b_offset),(p6b_2-1+(noab+nvab)*
     &               (p5b_2-1+(noab+nvab)*(p4b_2-1+(noab+nvab)*
     &               (p3b_2-1)))))
               else
                CALL GET_HASH_BLOCK_I_R(d_b,f_b,dimb,
     &               int_mb(k_b_offset),(p6b_2-1+(noab+nvab)*
     &               (p5b_2-1+(noab+nvab)*(p4b_2-1+(noab+nvab)*
     &               (p3b_2-1)))),p6b_2,p5b_2,p4b_2,p3b_2)
               end if
               if (p5b .eq. p6b) then
                alpha = 1.0d0
               else
                alpha = 2.0d0
               end if
               call t2_p8(int_mb(k_range+h1b-1),
     &                    int_mb(k_range+h2b-1),
     &                    int_mb(k_range+p3b-1),
     &                    int_mb(k_range+p4b-1),
     &                    int_mb(k_range+p5b-1),
     &                    int_mb(k_range+p6b-1),
     &                    f_a,f_b,f_c,
     &                    0.5d0*alpha)
              END IF
             END IF
            END IF
           END DO
          END DO
          CALL ADD_HASH_BLOCK_R(d_c,f_c,dimc,
     &         int_mb(k_c_offset),(h2b-1+noab*(h1b-1+noab*
     &         (p4b-noab-1+nvab*(p3b-noab-1)))))
!$omp end task
        endif
      enddo
!$omp taskwait
      call GA_SYNC()
!$omp end master
      deallocate(f_a,stat=e_a)
      deallocate(f_b,stat=e_b)
      deallocate(f_c,stat=e_c)
      if (e_a.ne.0) call errquit("free a",0,MA_ERR)
      if (e_b.ne.0) call errquit("free b",1,MA_ERR)
      if (e_c.ne.0) call errquit("free c",2,MA_ERR)
!$omp end parallel
      RETURN
      END


      SUBROUTINE ccsd_t2_8_loops_driver(d_a,k_a_offset,
     &                                  d_b,k_b_offset,
     &                                  d_c,k_c_offset,
     &                                  maxh,maxp)
!     $Id: ccsd_t2.F 27404 2015-08-24 14:20:43Z jhammond $
!     This is a Fortran77 program generated by Tensor Contraction Engine v.1.0
!     Copyright (c) Battelle & Pacific Northwest National Laboratory (2002)
!     i0 ( p3 p4 h1 h2 )_vt + = 1/2 * Sum ( p5 p6 ) * t ( p5 p6 h1 h2 )_t * v ( p3 p4 p5 p6 )_v
      IMPLICIT NONE
#include "global.fh"
#include "mafdecls.fh"
#include "sym.fh"
#include "errquit.fh"
#include "tce.fh"
      integer :: d_a,d_b,d_c
      integer :: k_a_offset,k_b_offset,k_c_offset
      integer :: maxh,maxp
      integer :: num_tasks
      integer, allocatable :: task_list(:,:)
      integer :: e_tl
      integer :: ccsd_t2_8_count
      external :: ccsd_t2_8_count
      num_tasks = ccsd_t2_8_count()
      allocate(task_list(4,1:num_tasks),stat=e_tl)
      if (e_tl.ne.0) call errquit("alloc task_list",num_tasks,MA_ERR)
      call ccsd_t2_8_make_list(num_tasks, task_list)
      call ccsd_t2_8_loops_exec(d_a,k_a_offset,
     &                          d_b,k_b_offset,
     &                          d_c,k_c_offset,
     &                          maxh,maxp,
     &                          num_tasks,task_list)
      deallocate(task_list,stat=e_tl)
      if (e_tl.ne.0) call errquit("free task_list",num_tasks,MA_ERR)
      RETURN
      END


      SUBROUTINE ccsd_t2_8_dgemm_exec(d_a,k_a_offset,
     &                                d_b,k_b_offset,
     &                                d_c,k_c_offset,
     &                                maxh,maxp,
     &                                num_tasks,task_list)
      IMPLICIT NONE
#include "global.fh"
#include "mafdecls.fh"
#include "sym.fh"
#include "errquit.fh"
#include "tce.fh"
      integer, intent(in) :: d_a,d_b,d_c
      integer, intent(in) :: k_a_offset,k_b_offset,k_c_offset
      integer, intent(in) :: maxh,maxp
      integer, intent(in) :: num_tasks
      integer, intent(in) :: task_list(4,num_tasks)
      integer :: dimhhpp,dimpppp,dimtemp
      integer :: p5b,p6b,p3b,p4b,h1b,h2b
      integer :: p5b_1,p6b_1,h1b_1,h2b_1
      integer :: p3b_2,p4b_2,p5b_2,p6b_2
      integer :: dima,dimb,dimc,dim_common,dima_sort,dimb_sort
      double precision, allocatable :: f_a(:)
      double precision, allocatable :: f_b(:)
      double precision, allocatable :: f_c(:)
      double precision, allocatable :: f_t(:)
#ifdef USE_FASTMEM
      !dec$ attributes fastmem :: f_a,f_b,f_c,f_t
#endif
      integer :: e_a,e_b,e_c,e_t
      double precision :: alpha
      integer :: p5b_in,p6b_in
      integer :: me,np
      integer :: i

      me = ga_nodeid()
      np = ga_nnodes()

      dimhhpp = maxh*maxh*maxp*maxp
      dimpppp = maxp*maxp*maxp*maxp
      dimtemp = max(dimpppp,dimhhpp)
!$omp parallel private(f_a,f_b,f_c,f_t,e_a,e_b,e_c,e_t)
      allocate(f_a(1:dimhhpp),stat=e_a)
      allocate(f_b(1:dimpppp),stat=e_b)
      allocate(f_c(1:dimhhpp),stat=e_c)
      allocate(f_t(1:dimtemp),stat=e_t)
      if (e_a.ne.0) call errquit("MA a",dimhhpp,MA_ERR)
      if (e_b.ne.0) call errquit("MA b",dimpppp,MA_ERR)
      if (e_c.ne.0) call errquit("MA c",dimhhpp,MA_ERR)
      if (e_t.ne.0) call errquit("MA t",dimhhpp,MA_ERR)
!$omp master
      do i = 1, num_tasks
        if (mod(i,np).eq.me) then
!$omp task private(p3b,p4b,h1b,h2b,p5b_in,p5b,p6b_in,p6b)
!$omp&     private(p5b_1,p6b_1,h1b_1,h2b_1,p3b_2,p4b_2,p5b_2,p6b_2)
!$omp&     private(dima,dimb,dimc,dim_common,dima_sort,dimb_sort)
!$omp&     private(alpha)
          p3b = task_list(1,i)
          p4b = task_list(2,i)
          h1b = task_list(3,i)
          h2b = task_list(4,i)
          dima_sort = int_mb(k_range+h1b-1)
     &              * int_mb(k_range+h2b-1)
          dimb_sort = int_mb(k_range+p3b-1)
     &              * int_mb(k_range+p4b-1)
          dimc = int_mb(k_range+p3b-1) * int_mb(k_range+p4b-1)
     &         * int_mb(k_range+h1b-1) * int_mb(k_range+h2b-1)
          CALL DFILL(dimc,0.0d0,f_c,1)
          DO p5b_in =me,me+nvab-1
             p5b=mod(p5b_in,nvab)+noab+1
           DO p6b_in=me,me+nvab+noab-p5b
              p6b=mod(p6b_in,noab+nvab-p5b+1)+p5b
            IF (int_mb(k_spin+p5b-1)+int_mb(k_spin+p6b-1) .eq.
     &          int_mb(k_spin+h1b-1)+int_mb(k_spin+h2b-1)) THEN
             IF (ieor(int_mb(k_sym+p5b-1),ieor(int_mb(k_sym+p6b-1),
     &           ieor(int_mb(k_sym+h1b-1),int_mb(k_sym+h2b-1))))
     &                  .eq. irrep_t) THEN
              CALL TCE_RESTRICTED_4(p5b,p6b,h1b,h2b,
     &                              p5b_1,p6b_1,h1b_1,h2b_1)
              CALL TCE_RESTRICTED_4(p3b,p4b,p5b,p6b,
     &                              p3b_2,p4b_2,p5b_2,p6b_2)
              dim_common = int_mb(k_range+p5b-1)
     &                   * int_mb(k_range+p6b-1)
              dima = dim_common * dima_sort
              dimb = dim_common * dimb_sort
              IF ((dima .gt. 0) .and. (dimb .gt. 0)) THEN
               CALL GET_HASH_BLOCK_R(d_a,f_t,dima,
     &              int_mb(k_a_offset),(h2b_1-1+noab*(h1b_1-1+noab*
     &              (p6b_1-noab-1+nvab*(p5b_1-noab-1)))))
               CALL TCE_SORT_4(f_t,f_a,
     &              int_mb(k_range+p5b-1),int_mb(k_range+p6b-1),
     &              int_mb(k_range+h1b-1),int_mb(k_range+h2b-1),
     &              4,3,2,1,1.0d0)
               if(.not.intorb) then
                CALL GET_HASH_BLOCK_R(d_b,f_t,dimb,
     &               int_mb(k_b_offset),(p6b_2-1+(noab+nvab)*
     &               (p5b_2-1+(noab+nvab)*(p4b_2-1+(noab+nvab)*
     &               (p3b_2-1)))))
               else
                CALL GET_HASH_BLOCK_I_R(d_b,f_t,dimb,
     &               int_mb(k_b_offset),(p6b_2-1+(noab+nvab)*
     &               (p5b_2-1+(noab+nvab)*(p4b_2-1+(noab+nvab)*
     &               (p3b_2-1)))),p6b_2,p5b_2,p4b_2,p3b_2)
               end if
               CALL TCE_SORT_4(f_t,f_b,
     &              int_mb(k_range+p3b-1),int_mb(k_range+p4b-1),
     &              int_mb(k_range+p5b-1),int_mb(k_range+p6b-1),
     &              2,1,4,3,1.0d0)
               if (p5b .eq. p6b) then
                alpha = 1.0d0
               else
                alpha = 2.0d0
               end if
               CALL DGEMM('T','N',dima_sort,dimb_sort,dim_common,
     &              alpha,f_a,dim_common,f_b,
     &              dim_common,1.0d0,f_c,dima_sort)
              END IF
             END IF
            END IF
           END DO
          END DO
          CALL TCE_SORT_4(f_c,f_t,
     &         int_mb(k_range+p4b-1),int_mb(k_range+p3b-1),
     &         int_mb(k_range+h2b-1),int_mb(k_range+h1b-1),
     &         2,1,4,3,0.5d0)
          CALL ADD_HASH_BLOCK_R(d_c,f_t,dimc,
     &         int_mb(k_c_offset),(h2b-1+noab*(h1b-1+noab*
     &         (p4b-noab-1+nvab*(p3b-noab-1)))))
!$omp end task
        endif
      enddo
!$omp taskwait
      call GA_SYNC()
!$omp end master
      deallocate(f_a,stat=e_a)
      deallocate(f_b,stat=e_b)
      deallocate(f_c,stat=e_c)
      if (e_a.ne.0) call errquit("MA pops a",0,MA_ERR)
      if (e_b.ne.0) call errquit("MA pops b",1,MA_ERR)
      if (e_c.ne.0) call errquit("MA pops c",2,MA_ERR)
!$omp end parallel
      RETURN
      END


      SUBROUTINE ccsd_t2_8_dgemm_driver(d_a,k_a_offset,
     &                                  d_b,k_b_offset,
     &                                  d_c,k_c_offset,
     &                                  maxh,maxp)
!     $Id: ccsd_t2.F 27404 2015-08-24 14:20:43Z jhammond $
!     This is a Fortran77 program generated by Tensor Contraction Engine v.1.0
!     Copyright (c) Battelle & Pacific Northwest National Laboratory (2002)
!     i0 ( p3 p4 h1 h2 )_vt + = 1/2 * Sum ( p5 p6 ) * t ( p5 p6 h1 h2 )_t * v ( p3 p4 p5 p6 )_v
      IMPLICIT NONE
#include "global.fh"
#include "mafdecls.fh"
#include "sym.fh"
#include "errquit.fh"
#include "tce.fh"
      integer :: d_a,d_b,d_c
      integer :: k_a_offset,k_b_offset,k_c_offset
      integer :: maxh,maxp
      integer :: num_tasks
      integer, allocatable :: task_list(:,:)
      integer :: e_tl
      integer :: ccsd_t2_8_count
      external :: ccsd_t2_8_count
      num_tasks = ccsd_t2_8_count()
      allocate(task_list(4,1:num_tasks),stat=e_tl)
      if (e_tl.ne.0) call errquit("alloc task_list",num_tasks,MA_ERR)
      call ccsd_t2_8_make_list(num_tasks, task_list)
      call ccsd_t2_8_dgemm_exec(d_a,k_a_offset,
     &                          d_b,k_b_offset,
     &                          d_c,k_c_offset,
     &                          maxh,maxp,
     &                          num_tasks,task_list)
      deallocate(task_list,stat=e_tl)
      if (e_tl.ne.0) call errquit("free task_list",num_tasks,MA_ERR)
      RETURN
      END

#endif

#ifdef USE_TCE_CUBLAS
      SUBROUTINE ccsd_t2_8_cublas(d_a,k_a_offset,
     &                            d_b,k_b_offset,
     &                            d_c,k_c_offset,
     &                            maxh,maxp)
!     i0 ( p3 p4 h1 h2 )_vt + = 1/2 * Sum ( p5 p6 ) * t ( p5 p6 h1 h2 )_t * v ( p3 p4 p5 p6 )_v
      use iso_fortran_env
      use cudafor
      use cublas, only : cublasHandle, cublascreate, cublasdestroy,
     &                   cublassetstream
      IMPLICIT NONE
#include "global.fh"
#include "mafdecls.fh"
#include "sym.fh"
#include "errquit.fh"
#include "tce.fh"
      INTEGER, intent(in) :: d_a,d_b,d_c
      INTEGER, intent(in) :: k_a_offset,k_b_offset,k_c_offset
      INTEGER, intent(in) :: maxh,maxp
      INTEGER :: dimhhpp,dimpppp
      INTEGER next,nprocs,count
      INTEGER p5b,p6b,p3b,p4b,h1b,h2b
      INTEGER p5b_1,p6b_1,h1b_1,h2b_1
      INTEGER p3b_2,p4b_2,p5b_2,p6b_2
      integer p5b_in,p6b_in
      INTEGER dima,dimb,dimc,dim_common,dima_sort,dimb_sort
      double precision, allocatable, pinned :: f_a(:,:), f_b(:,:), f_c(:,:)
      double precision, allocatable, device :: x_a(:,:), x_b(:,:), x_c(:,:)
      integer :: e_a
      double precision :: alpha
      INTEGER NXTASK
      EXTERNAL NXTASK

      integer :: err, shi
      integer(kind=cuda_stream_kind) :: stream(2)
      type(cublasHandle) :: handle(2)

      integer :: phase, oldphase
      integer, parameter :: numphases = 2

      do shi=1,numphases
        err = cudaStreamCreate(stream(shi))
        if (err.ne.0) call errquit('cudaStreamCreate',err,UNKNOWN_ERR)
        err = cublasCreate(handle(shi))
        if (err.ne.0) call errquit('cublasCreate',err,UNKNOWN_ERR)
        err = cublasSetStream(handle(shi), stream(shi))
        if (err.ne.0) call errquit('cublasSetStream',err,UNKNOWN_ERR)
      end do

      nprocs = GA_NNODES()
      count = 0
      next = NXTASK(nprocs, 1)

      dimhhpp = maxh*maxh*maxp*maxp
      dimpppp = maxp*maxp*maxp*maxp

      allocate(f_a(1:dimhhpp,numphases), f_b(1:dimpppp,numphases),
     &         f_c(1:dimhhpp,numphases), stat=e_a)
      if (e_a.ne.0) call errquit("MA Halloc",2*dimhhpp+1*dimpppp,MA_ERR)
      allocate(x_a(1:dimhhpp,numphases), x_b(1:dimpppp,numphases),
     &         x_c(1:dimhhpp,numphases), stat=e_a)
      if (e_a.ne.0) call errquit("MA Galloc",2*dimhhpp+1*dimpppp,MA_ERR)

      phase = 1
      oldphase = 2

      DO p3b = noab+1,noab+nvab
       DO p4b = p3b,noab+nvab
        DO h1b = 1,noab
         DO h2b = h1b,noab
          IF ((.not.restricted).or.
     &        ( int_mb(k_spin+p3b-1)+int_mb(k_spin+p4b-1)
     &         +int_mb(k_spin+h1b-1)+int_mb(k_spin+h2b-1).ne.8)) THEN
           IF (int_mb(k_spin+p3b-1)+int_mb(k_spin+p4b-1) .eq.
     &         int_mb(k_spin+h1b-1)+int_mb(k_spin+h2b-1)) THEN
            IF (ieor(int_mb(k_sym+p3b-1),ieor(int_mb(k_sym+p4b-1),
     &          ieor(int_mb(k_sym+h1b-1),int_mb(k_sym+h2b-1))))
     &                 .eq. ieor(irrep_v,irrep_t)) THEN
             IF (next.eq.count) THEN
              dima_sort = int_mb(k_range+h1b-1)
     &                  * int_mb(k_range+h2b-1)
              dimb_sort = int_mb(k_range+p3b-1)
     &                  * int_mb(k_range+p4b-1)
              dimc = int_mb(k_range+p3b-1) * int_mb(k_range+p4b-1)
     &             * int_mb(k_range+h1b-1) * int_mb(k_range+h2b-1)
              !CALL DFILL(dimc,0.0d0,f_c,1)
              !x_c(1:dimc) = 0.0d0 !f_c(1:dimc)
              x_c = 0.0d0 ! just nuke the whole buffer to be safe
              DO p5b_in =ga_nodeid(),ga_nodeid()+nvab-1
                p5b=mod(p5b_in,nvab)+noab+1
                DO p6b_in=ga_nodeid(),ga_nodeid()+nvab+noab-p5b
                 p6b=mod(p6b_in,noab+nvab-p5b+1)+p5b
                IF (int_mb(k_spin+p5b-1)+int_mb(k_spin+p6b-1) .eq.
     &              int_mb(k_spin+h1b-1)+int_mb(k_spin+h2b-1)) THEN
                 IF (ieor(int_mb(k_sym+p5b-1),ieor(int_mb(k_sym+p6b-1),
     &               ieor(int_mb(k_sym+h1b-1),int_mb(k_sym+h2b-1))))
     &                      .eq. irrep_t) THEN
                  CALL TCE_RESTRICTED_4(p5b,p6b,h1b,h2b,
     &                                  p5b_1,p6b_1,h1b_1,h2b_1)
                  CALL TCE_RESTRICTED_4(p3b,p4b,p5b,p6b,
     &                                  p3b_2,p4b_2,p5b_2,p6b_2)
                  dim_common = int_mb(k_range+p5b-1)
     &                       * int_mb(k_range+p6b-1)
                  dima = dim_common * dima_sort
                  dimb = dim_common * dimb_sort
                  IF ((dima .gt. 0) .and. (dimb .gt. 0)) THEN
                   err = cudaStreamSynchronize(stream(oldphase))
                   if (err.ne.0) then
                     call errquit('cudaStreamSync',err,UNKNOWN_ERR)
                   endif
                   CALL GET_HASH_BLOCK(d_a,f_a(:,phase),dima,
     &                  int_mb(k_a_offset),(h2b_1-1+noab*(h1b_1-1+noab*
     &                  (p6b_1-noab-1+nvab*(p5b_1-noab-1)))))
                   !print*,'cudaMemcpyAsync A'
                   !x_a(1:dima) = f_a(1:dima)
                   err = cudaMemcpyAsync(x_a(:,phase),f_a(:,phase),dima,stream(phase))
                   if (err.ne.0) then
                     call errquit('cudaMemcpyAsync',err,UNKNOWN_ERR)
                   endif
                   if(.not.intorb) then
                    CALL GET_HASH_BLOCK(d_b,f_b(:,phase),dimb,
     &                   int_mb(k_b_offset),(p6b_2-1+(noab+nvab)*
     &                   (p5b_2-1+(noab+nvab)*(p4b_2-1+(noab+nvab)*
     &                   (p3b_2-1)))))
                   else
                    CALL GET_HASH_BLOCK_I(d_b,f_b(:,phase),dimb,
     &                   int_mb(k_b_offset),(p6b_2-1+(noab+nvab)*
     &                   (p5b_2-1+(noab+nvab)*(p4b_2-1+(noab+nvab)*
     &                   (p3b_2-1)))),p6b_2,p5b_2,p4b_2,p3b_2)
                   end if
                   if (p5b .eq. p6b) then
                    alpha = 1.0d0
                   else
                    alpha = 2.0d0
                   end if
                   !print*,'cudaMemcpyAsync B'
                   !x_b(1:dimb) = f_b(1:dimb)
                   err = cudaMemcpyAsync(x_b(:,phase),f_b(:,phase),dimb,stream(phase))
                   if (err.ne.0) then
                     call errquit('cudaMemcpyAsync',err,UNKNOWN_ERR)
                   endif
                   block
                     use cublas, only : cublasDgemm_v2, CUBLAS_OP_N
                     integer(INT32), parameter :: cu_op_n = CUBLAS_OP_N
                     integer(kind=INT32) :: h21d, p43d, p65d
                     h21d = int_mb(k_range+h1b-1)*int_mb(k_range+h2b-1)
                     p43d = int_mb(k_range+p3b-1)*int_mb(k_range+p4b-1)
                     p65d = int_mb(k_range+p5b-1)*int_mb(k_range+p6b-1)
                     !print*,'cublasDgemm_v2',h21d,p43d,p65d,dima,dimb,dimc
                     err = cublasDgemm_v2(handle(phase),cu_op_n,cu_op_n,
     &                                    h21d,p43d,p65d,
     &                           0.5d0*alpha,x_a(:,phase),h21d,
     &                                       x_b(:,phase),p65d,
     &                           1.0d0,      x_c(:,phase),h21d)
                     if (err.ne.0) then
                       call errquit('cublasDgemm_v2',err,UNKNOWN_ERR)
                     endif
                     !err = cudaStreamSynchronize(stream(phase))
                     !if (err.ne.0) then
                     !  call errquit('cudaStreamSync',err,UNKNOWN_ERR)
                     !endif
                   end block
                   if (phase.eq.1) then
                     oldphase = 1
                     phase = 2
                   else if (phase.eq.2) then
                     oldphase = 2
                     phase = 1
                   end if
                  END IF
                 END IF
                END IF
               END DO
              END DO
              !print*,'cudaMemcpyAsync C (out)'
              !f_c(1:dimc) = x_c(1:dimc)
              do shi=1,numphases
                err = cudaMemcpyAsync(f_c(:,shi),x_c(:,shi),dimc,stream(shi))
                if (err.ne.0) then
                  call errquit('cudaMemcpyAsync',err,UNKNOWN_ERR)
                endif
                err = cudaStreamSynchronize(stream(shi))
                if (err.ne.0) then
                  call errquit('cudaStreamSync',err,UNKNOWN_ERR)
                endif
                CALL ADD_HASH_BLOCK(d_c,f_c(:,shi),dimc,
     &               int_mb(k_c_offset),(h2b-1+noab*(h1b-1+noab*
     &               (p4b-noab-1+nvab*(p3b-noab-1)))))
              end do
              next = NXTASK(nprocs, 1)
             END IF
             count = count + 1
            END IF
           END IF
          END IF
         END DO
        END DO
       END DO
      END DO
      next = NXTASK(-nprocs, 1)
      call GA_SYNC()

      deallocate(f_a,f_b,f_c,stat=e_a)
      if (e_a.ne.0) call errquit("MA Hfree",e_a,MA_ERR)
      deallocate(x_a,x_b,x_c,stat=e_a)
      if (e_a.ne.0) call errquit("MA Gfree",e_a,MA_ERR)
      do shi=1,numphases
        err = cublasDestroy(handle(shi))
        if (err.ne.0) call errquit('cublasDestroy',err,UNKNOWN_ERR)
        err = cudaStreamDestroy(stream(shi))
        if (err.ne.0) call errquit('cudaStreamDestroy',err,UNKNOWN_ERR)
      end do
      END

#endif


