      SUBROUTINE new_ga4ind_N5(rtdb,d_v2,
     1                                kax_v2_alpha_offset,
     1                                size_2e)
C     $Id$
C     This is a Fortran77 program generated by Tensor Contraction Engine v.1.0
C     Copyright (c) Battelle & Pacific Northwest National Laboratory (2002)
C     t ( p1 p2 h3 h4 )_t
      IMPLICIT NONE
#include "rtdb.fh"
#include "global.fh"
#include "mafdecls.fh"
#include "stdio.fh"
#include "util.fh"
#include "bas.fh"
#include "schwarz.fh"
#include "sym.fh"
#include "sf.fh"
#include "errquit.fh"
#include "tce.fh"
#include "tce_main.fh"
c
c written by K. Kowalski
c
c
c     max. number of p2 groups =200
c
c
      integer rtdb                 ! Run-time database
      integer d_v2                 ! MO integrals
      integer kax_v2_alpha_offset  ! MO integrals offset
      integer size_2e              ! 2e file size
c
      INTEGER azone1,azone2,azone3,azone4
      INTEGER g1b,g2b,g3b,g4b
      INTEGER igi1,igi2,igi3,igi4
      INTEGER ii,i,j,k,l,N,ipos1,ipos2,ipos3,ipos4
      INTEGER size_4a,l_4a,k_4a
      INTEGER size_aaaa
      INTEGER d_agaa,size_agaa,l_offset_agaa,k_offset_agaa
      INTEGER d_ggaa,size_ggaa,l_offset_ggaa,k_offset_ggaa
      INTEGER d_ggga,size_ggga,l_offset_ggga,k_offset_ggga
      INTEGER l_loc_aaaa,k_loc_aaaa,size_loc_aaaa
      INTEGER l_loc_agaa,k_loc_agaa,size_loc_agaa
      INTEGER l_loc_ggaa,k_loc_ggaa,size_loc_ggaa
      INTEGER l_loc_ggga,k_loc_ggga,size_loc_ggga
      INTEGER l_loc_gggg,k_loc_gggg,size_loc_gggg
c
      integer key_aaaa,key_agaa,key_ggaa,key_ggga
      integer offset_aaaa,offset_agaa,offset_ggaa,offset_ggga
      integer key_gggg,offset_gggg
c
      integer max_size_temp,sumx
c
      integer tot_azone1_sh,tot_azone2_sh
      integer tot_azone3_sh,tot_azone4_sh
      integer tot_zone(1000)  !it was d.prec.
c
      integer iha,ihb !number of corr. alpha, beta holes
      integer ipa,ipb !number of corr. alpha, beta particles
c
      integer mu,nu,rho,sigma
      integer mu_lo,mu_hi
      integer nu_lo,nu_hi
      integer rho_lo,rho_hi
      integer sigma_lo,sigma_hi
      integer mu_range
      integer nu_range
      integer rho_range
      integer sigma_range
      integer mu1,nu1,rho1,sigma1
      integer shift_mu,shift_nu
      integer shift_rho,shift_sigma
      integer work1,work2          ! Work array sizes
      integer l_work1,k_work1      ! Work array 1
      integer l_work2,k_work2      ! Work array 2
      integer imu1,inu1,irho1,isigma1
c
      integer l_movecs_orb,k_movecs_orb
c
      integer l_integral,l_coeff
      integer k_integral,k_coeff
      integer l_aux,k_aux,size_aux
      integer l_aux2,k_aux2,size_aux2
      integer l_aux3,k_aux3,size_aux3
      integer istart
      integer size_ic,size_icc,size_integral,size_coeff,max_na
c
      integer INDEX_PAIR,icol,irow
c
ccx      double precision tot_zone(1000)
c 
      integer l_4af_offset,k_4af_offset,d_4af
      integer sf_chunk,request
      integer key_4af,offset_4af,size_4af
      character*255 filename
c 
      logical parallel
c
      INTEGER length
      INTEGER next
      INTEGER nprocs
      INTEGER count
      integer nnn, ilo,ihi,jlo,jhi
      integer nxtask
      external nxtask
      logical nodezero
      logical idiskl
c
c
      nodezero=(ga_nodeid().eq.0)
c
c
      max_size_temp=imaxsize**4
c
      do ii=1,1000
       tot_zone(ii)=0.0d0
      enddo
      if(atpart.gt.1000)
     &  call errquit('tce_zones: atpart too big',1,MA_ERR)
      sumx=0
      do ii=1,atpart
       tot_zone(ii)=sumx
       sumx=sumx+nalength(ii)
      enddo
c
c
c this module is called only if intorb = .true.
c N is the number of correlated orbitals
        N = nmo(1) - nfc(1) - nfv(1)
        iha = nocc(1)-nfc(1)
        ihb = nocc(ipol)-nfc(ipol)
        ipa = nmo(1)-nocc(1)-nfv(1)
        ipb = nmo(ipol)-nocc(ipol)-nfv(ipol)
c
c     pre-compute size_loc_agaa & size_loc_aaaa
c
      size_loc_agaa=0
      size_loc_aaaa=0
      DO azone2 = 1,atpart
         DO azone1 = 1,azone2
            nnn=nalength(azone1)*nalength(azone2)
            DO g3b = 1,noa+nva
               DO azone3 = 1,atpart
                  size_loc_agaa= max(size_loc_agaa,
     V                 nnn*
     1                 nalength(azone3)*int_mb(k_range_alpha+g3b-1))
                  DO azone4=1,atpart
                     
                     size_loc_aaaa=max(size_loc_aaaa,
     V                    nnn*
     1                    nalength(azone3)*nalength(azone4))
                  enddo
               enddo
            enddo
         enddo
      enddo
c     pre-compute size_loc_ggaa & size_loc_ggga
c
      size_loc_ggaa=0
      size_loc_ggga=0
      DO azone2 = 1,atpart
         DO g2b = 1,noa+nva
            DO g3b = 1,noa+nva
               DO g4b = g3b,noa+nva
                  size_loc_ggga= max(size_loc_ggga,
     N                 nalength(azone2)*int_mb(k_range_alpha+g2b-1)*
     1 int_mb(k_range_alpha+g3b-1)*int_mb(k_range_alpha+g4b-1))

                  DO azone1=1,atpart ! azone1
                     size_loc_ggaa=max(size_loc_ggaa,
     N                    nalength(azone1)*nalength(azone2)*
     1  int_mb(k_range_alpha+g3b-1)*int_mb(k_range_alpha+g4b-1))

                  enddo
               enddo
            enddo
         enddo
      enddo

c
c     Offset for 4a file
c
      sf_chunk=(imaxsize)**4
      call tce_4a_offset(l_4af_offset,k_4af_offset,size_4af)

      call tce_gacreate_sloc(d_4af, size_4af, 
     S     size_loc_aaaa, 'd_4af')
ccx      call ga_zero(d_4af)

c
c alpha orbitals only
c
      if (.not.ma_push_get(mt_dbl,nbf*(iha+ipa)
     1  ,"sorted MO coeffs",
     2  l_movecs_orb,k_movecs_orb))
     3  call errquit('tce_mo2e_zone: MA problem 1',0,
     2    BASIS_ERR)
c      call dcopy(nbf*(iha+ipa),0.0d0, 0,dbl_mb(k_movecs_orb), 1)
      call dcopy(nbf*iha,
     c     dbl_mb(k_movecs_sorted),1,
     C     dbl_mb(k_movecs_orb),1)
      call dcopy(nbf*ipa,
     c     dbl_mb(k_movecs_sorted+(iha+ihb)*nbf),1,
     C     dbl_mb(k_movecs_orb+iha*nbf),1)
c
c
      call int_mem_2e4c(work1,work2)
      if (.not.ma_push_get(mt_dbl,work1,'work1',l_work1,k_work1))
     1  call errquit('tce_ao2e: MA problem work1',0,MA_ERR)
      if (.not.ma_push_get(mt_dbl,work2,'work2',l_work2,k_work2))
     1  call errquit('tce_ao2e: MA problem work2',1,MA_ERR)
c
c
c 
c 4af file formed here
c
c
       if(nodezero) then
          write(6,'(A,F20.2,A)') ' starting step 0 at ',
     C         util_wallsec(), ' secs '
          call util_flush(6)
       endif
      nprocs = GA_NNODES()
      count = 0
      call  ga_distribution(d_4af,ga_nodeid(),ilo,ihi,jlo,jhi)
      if(jlo.gt.0) then
cold      next = NXTASK(nprocs, 1)
      DO azone1 = 1,atpart      !nu
      DO azone2 = azone1,atpart !mu
      DO azone3 = 1,atpart      !sigma
      DO azone4 = azone3,atpart !rho
         size_4a = nalength(azone1)*nalength(azone2)*
     1            nalength(azone3)*nalength(azone4)
         key_4af=azone4 - 1 + atpart * (azone3 - 1 +
     &          atpart * (azone2 - 1 + atpart * (azone1 - 1)))
        call tce_hash(int_mb(k_4af_offset),key_4af,offset_4af)
       if((ilo.le.offset_4af+size_4a).and.
     A      (ihi.ge.offset_4af+1)) then
cold      IF (next.eq.count) THEN
c ---------------------------
        if(.not.ma_push_get(mt_dbl,size_4a,'4a',l_4a,k_4a))
     1     call errquit('tce_4af_zones1: MA problem',0,MA_ERR)
        call dfill(size_4a, 0.0d0, dbl_mb(k_4a), 1)
         shift_mu = 0
         do mu    = a2length(azone2)+1,a2length(azone2+1)
            if (.not.bas_cn2bfr(ao_bas_han,mu,mu_lo,mu_hi))
     1      call errquit('tce_ao2e: basis fn range problem 1',0,
     2      BASIS_ERR)
            mu_range = mu_hi - mu_lo + 1
         shift_nu = 0
         do nu    = a2length(azone1)+1,a2length(azone1+1)
            if (.not.bas_cn2bfr(ao_bas_han,nu,nu_lo,nu_hi))
     1      call errquit('tce_ao2e: basis fn range problem 1',0,
     2      BASIS_ERR)
            nu_range = nu_hi - nu_lo + 1
         shift_rho = 0
         do rho   = a2length(azone4)+1,a2length(azone4+1)
            if (.not.bas_cn2bfr(ao_bas_han,rho,rho_lo,rho_hi))
     1      call errquit('tce_ao2e: basis fn range problem 1',0,
     2      BASIS_ERR)
            rho_range = rho_hi - rho_lo + 1
         shift_sigma = 0
         do sigma = a2length(azone3)+1,a2length(azone3+1)
            if (.not.bas_cn2bfr(ao_bas_han,sigma,sigma_lo,sigma_hi))
     1      call errquit('tce_ao2e: basis fn range problem 1',0,
     2      BASIS_ERR)
            sigma_range = sigma_hi - sigma_lo + 1
            if (schwarz_shell(rho,sigma)*schwarz_shell(mu,nu)
     1          .ge. tol2e) then
            call int_2e4c(ao_bas_han,mu,nu,ao_bas_han,rho,sigma,
     1           work2,dbl_mb(k_work2),work1,dbl_mb(k_work1))
c
            i=0
            do mu1     = 1,mu_range
               imu1=mu1+shift_mu
               do nu1     = 1,nu_range
                  inu1=nu1+shift_nu
                  do rho1    = 1,rho_range
                     irho1=rho1+shift_rho
                     do sigma1  = 1,sigma_range
                        i=i+1
                        isigma1=sigma1+shift_sigma
c     (isigma1,irho1|inu1, imu1)
                        ipos1=(((imu1-1)*nalength(azone1)+inu1-1)*
     1                       nalength(azone4)+irho1-1)*nalength(azone3)
     2                       +isigma1
                        dbl_mb(k_4a+ipos1-1)=dbl_mb(k_work1+i-1)
                     enddo
                  enddo
               enddo
            enddo
            end if !schwarz  screening
         shift_sigma = shift_sigma + sigma_range
         enddo !sigma
         shift_rho   = shift_rho + rho_range
         enddo !rho
         shift_nu    = shift_nu + nu_range
         enddo !nu
         shift_mu    = shift_mu + mu_range
         enddo !mu
c
c fixing offsets and sf_writing
        call ga_put(d_4af,offset_4af+1,offset_4af+size_4a,1,1,
     1    dbl_mb(k_4a),1)
c closing l_4a file
        if (.not.ma_pop_stack(l_4a))
     1   call errquit('tcc_mo2e_4af2: l_4a',15,MA_ERR)
c ---------------------------
cold      next = NXTASK(nprocs, 1)
      END IF
      count = count + 1
      ENDDO !azone4
      ENDDO !azone3
      ENDDO !azone2
      ENDDO !azone1
      endif
c
cold      next = NXTASK(-nprocs, 1)
      call ga_sync()
c
c
c     open offset l_agaa
      call tce_offset_agaa(l_offset_agaa,k_offset_agaa,size_agaa)  
c     open offset l_ggaa
      call tce_offset_ggaa(l_offset_ggaa,k_offset_ggaa,size_ggaa)
c     open offset l_ggga
      call tce_offset_ggga(l_offset_ggga,k_offset_ggga,size_ggga)
c
      max_na=0
      do i=1,atpart
       if(nalength(i).gt.max_na) max_na=nalength(i)
      enddo
      size_icc=tile_dim*max_na
c
       if (.not.ma_push_get(mt_dbl,size_icc,'l_coeff',
     1  l_coeff,k_coeff))
     1  call errquit('tce_4s: MA problem l_coeff',0,MA_ERR)
c
c
c
c
c
c     step1
c
c     open ga d_agaa (size_agaa)
       if(nodezero) then
          write(6,'(A,F20.2,A)') ' starting step 1 at ',
     C         util_wallsec(), ' secs '
          call util_flush(6)
       endif
       
       call tce_gacreate_sloc(d_agaa, size_agaa,
     S      size_loc_agaa, 'd_agaa')

      call  ga_distribution(d_agaa,ga_nodeid(),ilo,ihi,jlo,jhi)
      if(jlo.gt.0) then
       if (.not.ma_push_get(mt_dbl,size_loc_agaa,'loc_agaa',
     1 l_loc_agaa,k_loc_agaa))
     1 call errquit('step1:1',0,MA_ERR)
        if (.not.ma_push_get(mt_dbl,size_loc_aaaa,'loc_aaaa',
     1  l_loc_aaaa,k_loc_aaaa))
     1  call errquit('step1:2',0,MA_ERR)
         if (.not.ma_push_get(mt_dbl,
     M   max(size_loc_aaaa,size_loc_agaa),'auxaaaa',
     1   l_aux,k_aux))
     1   call errquit('step1:3',0,MA_ERR)

      nprocs = GA_NNODES()
      count = 0
cold      next = NXTASK(nprocs, 1)
c do parallel 
      DO azone2 = 1,atpart
      DO azone1 = 1,azone2
      DO g3b = 1,noa+nva
      DO azone3 = 1,atpart
       size_loc_agaa= nalength(azone1)*nalength(azone2)*
     1 nalength(azone3)*int_mb(k_range_alpha+g3b-1)
       key_agaa=azone3-1+atpart*(g3b-1+
     1  (noa+nva)*(azone1-1+atpart*(azone2-1)))
       call tce_hash_n(int_mb(k_offset_agaa),key_agaa,offset_agaa)
       if((ilo.le.offset_agaa+size_loc_agaa).and.
     A      (ihi.ge.offset_agaa+1)) then
cold      IF (next.eq.count) THEN
       call dfill(size_loc_agaa,0.0d0, dbl_mb(k_loc_agaa), 1)
c open k_aux (
c     declare (k_aux) ( all-az4 az3 | az1 az2)
      size_aux2=nbf*nalength(azone3)*nalength(azone1)
     1         *nalength(azone2)
       if (.not.ma_push_get(mt_dbl,size_aux2,'loc_qm2',
     1 l_aux2,k_aux2))
     1 call errquit('step2:1m4',0,MA_ERR)
      istart=0
c
       DO azone4=1,atpart
        size_aux3=nalength(azone1)*nalength(azone2)*
     1  nalength(azone3)*nalength(azone4)
       if (.not.ma_push_get(mt_dbl,size_aux3,'loc_qm3',
     1 l_aux3,k_aux3))
     1 call errquit('Xtep2:1m4',0,MA_ERR)
        if(azone4.le.azone3) then ! azone4 <= azone3
         key_aaaa=azone3-1+atpart*(azone4-1+
     &          atpart*(azone2-1+atpart*(azone1-1)))
         call tce_hash(int_mb(k_4af_offset),key_aaaa,offset_aaaa)
c k_aux3: (az4 az3| az1 az2) -> (az2 az3|az1 az4)
         call ga_get(d_4af,offset_aaaa+1,offset_aaaa+size_aux3,1,1,
     1    dbl_mb(k_aux3),1)
c transposition (az4 az3|az1 az2) --> (az2 az3|az1 az4)
        call TCE_SORT_4KG_(dbl_mb(k_aux3),dbl_mb(k_aux2+istart),
     1   nalength(azone4),nalength(azone3),
     1   nalength(azone1),nalength(azone2),4,2,3,1,1.0d0)
        istart=istart+size_aux3
        else    ! azone4 > azone3
         key_aaaa=azone4-1+atpart*(azone3-1+
     &          atpart*(azone2-1+atpart*(azone1-1)))
         call tce_hash(int_mb(k_4af_offset),key_aaaa,offset_aaaa)
         call ga_get(d_4af,offset_aaaa+1,offset_aaaa+size_aux3,1,1,
     1    dbl_mb(k_aux3),1)
c        k_aux3: (az3 az4|az1 az2) -> (az2 az3|az1 az4)
        call TCE_SORT_4KG_(dbl_mb(k_aux3),dbl_mb(k_aux2+istart),
     1   nalength(azone3),nalength(azone4),
     1   nalength(azone1),nalength(azone2),4,1,3,2,1.0d0)
        istart=istart+size_aux3
        end if  ! azone4 <= azone3
        if (.not.ma_pop_stack(l_aux3))
     1  call errquit('f4ind:QA1',15,MA_ERR)
       ENDDO  !azone4
c big dgemm here (az2 az3|az1 all-az4)(all-az4 g3)=(az2 az3|az1 g3)
       if (.not.ma_push_get(mt_dbl,size_loc_agaa,'loc_qm3',
     1 l_aux3,k_aux3))
     1 call errquit('Xtep2:1m4',0,MA_ERR)
       call dgemm('N','N',
     1  nalength(azone2)*nalength(azone3)*nalength(azone1),
     2  int_mb(k_range_alpha+g3b-1),
     3  nbf,
     4  1.0d0,
     5  dbl_mb(k_aux2),
     1  nalength(azone2)*nalength(azone3)*nalength(azone1),
     7  dbl_mb(k_movecs_orb+int_mb(k_offset_alpha+g3b-1)*nbf),
     8  nbf,0.0d0,
     9  dbl_mb(k_aux3),
     1  nalength(azone2)*nalength(azone3)*nalength(azone1))
c TRANSPOSITION
       CALL TCE_SORT_4KG_(dbl_mb(k_aux3),dbl_mb(k_loc_agaa),
     &  nalength(azone2),nalength(azone3),
     &  nalength(azone1),int_mb(k_range_alpha+g3b-1),
     &  2,4,3,1,1.0d0)
        if (.not.ma_pop_stack(l_aux3))
     1  call errquit('f4ind:QA1',15,MA_ERR)
       call ga_put(d_agaa,offset_agaa+1,offset_agaa+size_loc_agaa,1,1,
     1  dbl_mb(k_loc_agaa),1)
c
        if (.not.ma_pop_stack(l_aux2))
     1  call errquit('g4ind:QA1',15,MA_ERR)
c
cold      next = NXTASK(nprocs, 1)
      END IF
      count = count + 1
      ENDDO !azone3
      ENDDO !g3b
      ENDDO !azone1
      ENDDO !azone2
        if (.not.ma_pop_stack(l_aux))
     1  call errquit('g4ind:MA1',15,MA_ERR)
        if (.not.ma_pop_stack(l_loc_aaaa))
     1  call errquit('g4ind:MA1',15,MA_ERR)
       if (.not.ma_pop_stack(l_loc_agaa))
     1 call errquit('g4ind:MA1',15,MA_ERR)
cold      next = NXTASK(-nprocs, 1)
      endif
      call ga_sync()      
c     delete d_4af
      call deletefile(d_4af)
c
c
c
c
c
c
c
c     step2
c
c     open ga d_ggaa (size_ggaa)
       if(nodezero) then
          write(6,'(A,F20.2,A)') ' starting step 2 at ',
     C         util_wallsec(), ' secs '
          call util_flush(6)
       endif
      call tce_gacreate_sloc(d_ggaa, size_ggaa,
     S     size_loc_ggaa, 'd_ggaa')
c
      nprocs = GA_NNODES()
      count = 0
cold      next = NXTASK(nprocs, 1)
      call  ga_distribution(d_ggaa,ga_nodeid(),ilo,ihi,jlo,jhi)
      if(jlo.gt.0) then
c do parallel
      DO azone2 = 1,atpart
      DO azone1 = 1,azone2
      DO g3b = 1,noa+nva
      DO g4b = g3b,noa+nva
cold      IF (next.eq.count) THEN
       key_ggaa=g4b-1+(noa+nva)*(g3b-1+
     &  (noa+nva)*(azone1-1+atpart*(azone2-1)))
       call tce_hash_n(int_mb(k_offset_ggaa),key_ggaa,offset_ggaa)
       size_loc_ggaa= nalength(azone1)*nalength(azone2)*
     1 int_mb(k_range_alpha+g3b-1)*int_mb(k_range_alpha+g4b-1)
       if((ilo.le.offset_ggaa+size_loc_ggaa).and.
     A      (ihi.ge.offset_ggaa+1)) then
       if (.not.ma_push_get(mt_dbl,size_loc_ggaa,'loc_ggaa',
     1 l_loc_ggaa,k_loc_ggaa))
     1 call errquit('step2:1',0,MA_ERR)
      call dfill(size_loc_ggaa,0.0d0, dbl_mb(k_loc_ggaa), 1)
c
c     declare (k_aux) ( nbf(az3) g3b | az1 az2)
      size_aux=nbf*int_mb(k_range_alpha+g3b-1)*nalength(azone1)
     1         *nalength(azone2)
       if (.not.ma_push_get(mt_dbl,size_aux,'loc_all-a-gaa',
     1 l_aux,k_aux))
     1 call errquit('step2:1m4',0,MA_ERR)
      istart=0
c
       DO azone3=1,atpart
        size_loc_agaa=nalength(azone1)*nalength(azone2)*
     1  int_mb(k_range_alpha+g3b-1)*nalength(azone3)
        key_agaa=azone3-1+atpart*(g3b-1+
     1   (noa+nva)*(azone1-1+atpart*(azone2-1)))
        call tce_hash_n(int_mb(k_offset_agaa),key_agaa,offset_agaa)
       if (.not.ma_push_get(mt_dbl,size_loc_agaa,'loc_agaa',
     1  l_aux2,k_aux2))
     1  call errquit('step2:1m4uu',0,MA_ERR)
        call ga_get(d_agaa,offset_agaa+1,offset_agaa+size_loc_agaa,1,1,
     1   dbl_mb(k_aux2),1)
        call TCE_SORT_4KG_(dbl_mb(k_aux2),dbl_mb(k_aux+istart),
     1   nalength(azone3),int_mb(k_range_alpha+g3b-1),
     1   nalength(azone1),nalength(azone2),4,2,3,1,1.0d0)
        istart=istart+size_loc_agaa
        if (.not.ma_pop_stack(l_aux2))
     1  call errquit('g4ind:MA1xo',16,MA_ERR)
c stored as (az2 g3b az1 all-az3)
c
       ENDDO
c 
c   do global dgemm (az2 g3b az1 all-az3) C(all-az3 g4) => 
c      (az2 g3b az1 g4)
c
       if (.not.ma_push_get(mt_dbl,size_loc_ggaa,'aux2',
     1  l_aux2,k_aux2))
     1 call errquit('step2:1m4z5',0,MA_ERR)
c
       call dgemm('N','N',
     1  nalength(azone2)*int_mb(k_range_alpha+g3b-1)*nalength(azone1),
     2  int_mb(k_range_alpha+g4b-1),
     3  nbf,
     4  1.0d0,
     5  dbl_mb(k_aux),
     6  nalength(azone2)*int_mb(k_range_alpha+g3b-1)*nalength(azone1),
     7  dbl_mb(k_movecs_orb+int_mb(k_offset_alpha+g4b-1)*nbf),
     8  nbf,0.0d0,
     9  dbl_mb(k_aux2),
     1  nalength(azone2)*int_mb(k_range_alpha+g3b-1)*nalength(azone1))
c
        call TCE_SORT_4KG_(dbl_mb(k_aux2),dbl_mb(k_loc_ggaa),
     1   nalength(azone2),int_mb(k_range_alpha+g3b-1),
     1   nalength(azone1),int_mb(k_range_alpha+g4b-1),
     1   4,2,3,1,1.0d0)
c
        if (.not.ma_pop_stack(l_aux2))
     1  call errquit('g4ind:MA1x9',16,MA_ERR)
c
c   delete k_aux
       if (.not.ma_pop_stack(l_aux))
     1 call errquit('g4ind:MAu3',15,MA_ERR)
c     
       call ga_put(d_ggaa,offset_ggaa+1,offset_ggaa+size_loc_ggaa,1,1,
     1  dbl_mb(k_loc_ggaa),1)
       if (.not.ma_pop_stack(l_loc_ggaa))
     1 call errquit('g4ind:MA1',15,MA_ERR)
cold      next = NXTASK(nprocs, 1)
      END IF
      count = count + 1
      ENDDO !g4b
      ENDDO !g3b
      ENDDO !azone1
      ENDDO !azone2
cold      next = NXTASK(-nprocs, 1)
      endif
      call ga_sync()
c     delete d_agaa
      call deletefile(d_agaa)
c
c
c
c
c
c
c
c
c     step3
c
c     open ga d_ggga (size_ggga)
       if(nodezero) then
          write(6,'(A,F20.2,A)') ' starting step 3 at ',
     C         util_wallsec(), ' secs '
          call util_flush(6)
       endif

      call tce_gacreate_sloc(d_ggga, size_ggga,
     S     size_loc_ggga, 'd_ggga')
c
      nprocs = GA_NNODES()
      count = 0
cold      next = NXTASK(nprocs, 1)
      call  ga_distribution(d_ggga,ga_nodeid(),ilo,ihi,jlo,jhi)
#ifdef DBG
          write(6,'(A,I3,A,I9,A,I9,A,I9,A,I9)') 
     M         ' me ',ga_nodeid(),' ilo ',ilo,' ihi ',ihi,
     A         ' jlo ',jlo,' jhi ',jhi          
          call util_flush(6)
#endif
      if(jlo.gt.0) then
c do parallel
      DO azone2 = 1,atpart
      DO g2b = 1,noa+nva
      DO g3b = 1,noa+nva
      DO g4b = g3b,noa+nva
cold      IF (next.eq.count) THEN
       size_loc_ggga= nalength(azone2)*int_mb(k_range_alpha+g2b-1)*
     1 int_mb(k_range_alpha+g3b-1)*int_mb(k_range_alpha+g4b-1)
       key_ggga=g4b-1+(noa+nva)*(g3b-1+
     &  (noa+nva)*(g2b-1+(noa+nva)*(azone2-1)))
       call tce_hash_n(int_mb(k_offset_ggga),key_ggga,offset_ggga)
c     do only if ilo <= offset_ggga+size_loc_ggga & ihi>=offset_ggga+1
       if((ilo.le.offset_ggga+size_loc_ggga).and.
     A      (ihi.ge.offset_ggga+1)) then
#ifdef DBG
          write(6,'(A,I3,A,I9,A,I9,A,I9,A,I9)') 
     M         ' me ',ga_nodeid(),' ilo ',ilo,' ihi ',ihi,
     A         ' olo ',offset_ggga+1,' ohi ',offset_ggga+size_loc_ggga
          call util_flush(6)
#endif
       if (.not.ma_push_get(mt_dbl,size_loc_ggga,'loc_ggga',
     1 l_loc_ggga,k_loc_ggga))
     1 call errquit('step3:1',0,MA_ERR)
       call dfill(size_loc_ggga,0.0d0, dbl_mb(k_loc_ggga), 1)
c     declare (k_aux) ( g4 g3 |  az2 all-az1)
      size_aux2=int_mb(k_range_alpha+g4b-1)*
     1         int_mb(k_range_alpha+g3b-1)*
     1         nalength(azone2)*
     1         nbf
      if (.not.ma_push_get(mt_dbl,size_aux2,'loc_all-a-gaa',
     1 l_aux2,k_aux2))
     1 call errquit('step2:1m4',0,MA_ERR)
      istart=0
c
       DO azone1=1,atpart ! azone1
        if(azone2.le.azone1) then ! azone2 <= azone1
         size_loc_ggaa= nalength(azone1)*nalength(azone2)*
     1   int_mb(k_range_alpha+g3b-1)*int_mb(k_range_alpha+g4b-1)
         key_ggaa=g4b-1+(noa+nva)*(g3b-1+
     &   (noa+nva)*(azone2-1+atpart*(azone1-1)))
         call tce_hash(int_mb(k_offset_ggaa),key_ggaa,offset_ggaa)
         call ga_get(d_ggaa,offset_ggaa+1,offset_ggaa+size_loc_ggaa,1,1,
     1   dbl_mb(k_aux2+istart),1)
         istart=istart+size_loc_ggaa
c k_aux accumulates (g4 g3 |az2 az1)
        else ! azone2 <= azone1
         size_loc_ggaa= nalength(azone1)*nalength(azone2)*
     1   int_mb(k_range_alpha+g3b-1)*int_mb(k_range_alpha+g4b-1)
         key_ggaa=g4b-1+(noa+nva)*(g3b-1+
     &   (noa+nva)*(azone1-1+atpart*(azone2-1)))
         call tce_hash(int_mb(k_offset_ggaa),key_ggaa,offset_ggaa)
c open k_aux3
         if (.not.ma_push_get(mt_dbl,size_loc_ggaa,'auxaaaa',
     1   l_aux3,k_aux3))
     1   call errquit('step3:3',0,MA_ERR)
         call ga_get(d_ggaa,offset_ggaa+1,offset_ggaa+size_loc_ggaa,1,1,
     1   dbl_mb(k_aux3),1)
c k_aux3: (g4 g3|az1 az2) => (g4 g3|az2 az1-all)
         CALL TCE_SORT_4KG_(dbl_mb(k_aux3),dbl_mb(k_aux2+istart),
     &   int_mb(k_range_alpha+g4b-1),int_mb(k_range_alpha+g3b-1),
     &   nalength(azone1),nalength(azone2),
     &   1,2,4,3,1.0d0)
         istart=istart+size_loc_ggaa
c 
         if (.not.ma_pop_stack(l_aux3))
     1   call errquit('g4Znd:MA1',15,MA_ERR)
        end if ! azone2 <= azone1
       ENDDO ! azone1
c ([g4]=>[g3]|[azone2]all-azone1])*C_(all-azone1[g2])
        if (.not.ma_push_get(mt_dbl,size_loc_ggga,'loc_qyaa',
     1   l_aux,k_aux))
     1  call errquit('step3:1ma',0,MA_ERR)
c
         call dgemm('N','N',
     1   int_mb(k_range_alpha+g4b-1)*int_mb(k_range_alpha+g3b-1)*
     1   nalength(azone2),                                        !m
     1   int_mb(k_range_alpha+g2b-1),                             !n
     3   nbf,                                                     !k
     4   1.0d0,dbl_mb(k_aux2),
     5   int_mb(k_range_alpha+g4b-1)*int_mb(k_range_alpha+g3b-1)*
     5   nalength(azone2),
     6   dbl_mb(k_movecs_orb+int_mb(k_offset_alpha+g2b-1)*nbf),nbf,
     7   0.0d0,dbl_mb(k_aux),
     8   int_mb(k_range_alpha+g4b-1)*int_mb(k_range_alpha+g3b-1)*
     8   nalength(azone2))
C TRANSPOSITION HERE (g4=>g3|az2 g2) => (g4=>g3|g2 az2)
       CALL TCE_SORT_4KG_(dbl_mb(k_aux),dbl_mb(k_loc_ggga),
     & int_mb(k_range_alpha+g4b-1),int_mb(k_range_alpha+g3b-1),
     & nalength(azone2),int_mb(k_range_alpha+g2b-1),
     & 1,2,4,3,1.0d0)
       call ga_put(d_ggga,offset_ggga+1,offset_ggga+size_loc_ggga,1,1,
     1  dbl_mb(k_loc_ggga),1)
       if (.not.ma_pop_stack(l_aux))
     1  call errquit('g4ind:MA1',15,MA_ERR)
       if (.not.ma_pop_stack(l_aux2))
     1  call errquit('g4Pnd:MA1',15,MA_ERR)
       if (.not.ma_pop_stack(l_loc_ggga))
     1 call errquit('g4ind:MA1',15,MA_ERR)
c
cold      next = NXTASK(nprocs, 1)
      END IF
      count = count + 1
      ENDDO !g4b
      ENDDO !g3b
      ENDDO !g2b
      ENDDO !azone2
      endif
cood      next = NXTASK(-nprocs, 1)
      call ga_sync()
c     delete d_ggaa
      call deletefile(d_ggaa)
       if(nodezero) then
          write(6,'(A,F20.2,A)') ' starting step 4 at ',
     C         util_wallsec(), ' secs '
          call util_flush(6)
       endif
c
c
c
c
c
c
c
c
c
c
c     step4
c
      call  ga_distribution(d_v2,ga_nodeid(),ilo,ihi,jlo,jhi)
      nprocs = GA_NNODES()
      count = 0
cold      next = NXTASK(nprocs, 1)
c do parallel
      if(jlo.gt.0) then
      DO g1b = 1,noa+nva
      DO g2b = g1b,noa+nva
      DO g3b = 1,noa+nva
      DO g4b = g3b,noa+nva
c
       IF (int_mb(k_spin_alpha+g3b-1)+int_mb(k_spin_alpha+g4b-1).eq.
     & int_mb(k_spin_alpha+g1b-1)+int_mb(k_spin_alpha+g2b-1)) THEN
       IF (ieor(int_mb(k_sym_alpha+g3b-1),ieor(int_mb(k_sym_alpha+g4b-1)
     & ,ieor(int_mb(k_sym_alpha+g1b-1),int_mb(k_sym_alpha+g2b-1)))) .eq.
     & irrep_v) THEN
       IROW=INDEX_PAIR(g4b,g3b)
       ICOL=INDEX_PAIR(g2b,g1b)
       IF(IROW.GE.ICOL) THEN
c
       size_loc_gggg= int_mb(k_range_alpha+g1b-1)*
     1 int_mb(k_range_alpha+g2b-1)*
     1 int_mb(k_range_alpha+g3b-1)*int_mb(k_range_alpha+g4b-1)
       key_gggg=g2b - 1 + (noa+nva) *
     &(g1b - 1 + (noa+nva) * (g4b-
     & 1 + (noa+nva) * (g3b - 1)))
       call tce_hash_v2(int_mb(k_v2_alpha_offset),key_gggg,offset_gggg)
       if((ilo.le.offset_gggg+size_loc_gggg).and.
     A      (ihi.ge.offset_gggg+1)) then
cold      IF (next.eq.count) THEN
       if (.not.ma_push_get(mt_dbl,size_loc_gggg,'loc_gggg',
     1 l_loc_gggg,k_loc_gggg))
     1 call errquit('step4:1',0,MA_ERR)
      call dfill(size_loc_gggg,0.0d0, dbl_mb(k_loc_gggg), 1)
c k_aux2: (g4 g3| g2 all-az2)
      size_aux2=int_mb(k_range_alpha+g4b-1)*
     1         int_mb(k_range_alpha+g3b-1)*
     1         int_mb(k_range_alpha+g2b-1)*
     1         nbf
      if (.not.ma_push_get(mt_dbl,size_aux2,'loc_all-a-gaa',
     1 l_aux2,k_aux2))
     1 call errquit('step4:1m4',0,MA_ERR)
      istart=0
       DO azone2=1,atpart
        size_loc_ggga=nalength(azone2)*int_mb(k_range_alpha+g2b-1)*
     1  int_mb(k_range_alpha+g3b-1)*int_mb(k_range_alpha+g4b-1)
        key_ggga=g4b-1+(noa+nva)*(g3b-1+
     &  (noa+nva)*(g2b-1+(noa+nva)*(azone2-1)))
        call tce_hash_n(int_mb(k_offset_ggga),key_ggga,offset_ggga)
        call ga_get(d_ggga,offset_ggga+1,offset_ggga+size_loc_ggga,1,1,
     1   dbl_mb(k_aux2+istart),1)
        istart=istart+size_loc_ggga
c
       ENDDO !azone2
c
        call dgemm('N','N',
     1   int_mb(k_range_alpha+g4b-1)*int_mb(k_range_alpha+g3b-1)*
     1   int_mb(k_range_alpha+g2b-1),                             !m
     1   int_mb(k_range_alpha+g1b-1),                             !n
     3   nbf,                                                     !k
     4   1.0d0,dbl_mb(k_aux2),
     5   int_mb(k_range_alpha+g4b-1)*int_mb(k_range_alpha+g3b-1)*
     5   int_mb(k_range_alpha+g2b-1),
     6   dbl_mb(k_movecs_orb+int_mb(k_offset_alpha+g1b-1)*nbf),
     7   nbf,
     7   0.0d0,dbl_mb(k_loc_gggg),
     8   int_mb(k_range_alpha+g4b-1)*int_mb(k_range_alpha+g3b-1)*
     8   int_mb(k_range_alpha+g2b-1))
c
       call ga_put(d_v2,offset_gggg+1,offset_gggg+size_loc_gggg,1,1,
     1  dbl_mb(k_loc_gggg),1)

       if (.not.ma_pop_stack(l_aux2))
     1 call errquit('g4ppq:MA1',15,MA_ERR)
       if (.not.ma_pop_stack(l_loc_gggg))
     1 call errquit('g4ind:MA1',15,MA_ERR)
cold      next = NXTASK(nprocs, 1)
      END IF
      count = count + 1
       END IF
       END IF
       END IF
      ENDDO !g4b
      ENDDO !g3b
      ENDDO !g2b
      ENDDO !g1b
cold      next = NXTASK(-nprocs, 1)
      endif
      call ga_sync()
c     delete d_ggga
      call deletefile(d_ggga)

       if(nodezero) then
          write(6,'(A,F20.2,A)') ' done step 4 at ',
     C         util_wallsec(), ' secs '
          call util_flush(6)
       endif
c
c
c
c
c     delete l_coeff 
      if (.not.ma_pop_stack(l_coeff))
     1  call errquit('tcc_off_4a: MA problem',15,MA_ERR)
c     delete l_ggga
      if (.not.ma_pop_stack(l_offset_ggga))
     1  call errquit('ga4ind:ggga',15,MA_ERR)
c     delete l_ggaa
      if (.not.ma_pop_stack(l_offset_ggaa))
     1  call errquit('ga4ind:ggaa',15,MA_ERR)
c     delete l_agaa    
      if (.not.ma_pop_stack(l_offset_agaa))
     1  call errquit('ga4ind:agaa',15,MA_ERR)
c
      if (.not.ma_pop_stack(l_work2))
     1  call errquit('tcc_ao2e: MA problem',14,MA_ERR)
c
      if (.not.ma_pop_stack(l_work1))
     1  call errquit('tcc_ao2e: MA problem',15,MA_ERR)
c
      if (.not.ma_pop_stack(l_movecs_orb))
     1  call errquit('tcc_ao2e: MA problem',15,MA_ERR)
c
      if (.not.ma_pop_stack(l_4af_offset))
     1  call errquit('ga4ind:4a',15,MA_ERR)
c
c
      RETURN
      END
c
c
c
c
c
c
c
c
      SUBROUTINE tce_offset_agaa(l_a_offset,k_a_offset,size)
      IMPLICIT NONE
#include "global.fh"
#include "mafdecls.fh"
#include "sym.fh"
#include "errquit.fh"
#include "tce.fh"
#include "tce_main.fh"
      INTEGER l_a_offset
      INTEGER k_a_offset
      INTEGER size
      INTEGER length
      INTEGER addr
      INTEGER g3b,azone1,azone2,azone3
c ([az3],[g3]|[az1]<=[az2])
      length = 0
      DO azone2 = 1,atpart      
      DO azone1 = 1,azone2
      DO g3b = 1,noa+nva
      DO azone3 = 1,atpart
      length = length + 1
      END DO
      END DO
      END DO
      END DO
      IF (.not.MA_PUSH_GET(mt_int,2*length+1,'noname',l_a_offset,k_a_off
     &set)) CALL ERRQUIT('tce_t2_offset',0,MA_ERR)
      int_mb(k_a_offset) = length
      addr = 0
      size = 0
      DO azone2 = 1,atpart      
      DO azone1 = 1,azone2 
      DO g3b = 1,noa+nva
      DO azone3 = 1,atpart
      addr = addr + 1
      int_mb(k_a_offset+addr) = azone3 - 1 + atpart * (g3b - 1 +
     &  (noa+nva) * (azone1 - 1 + atpart * (azone2 - 1)))
      int_mb(k_a_offset+length+addr) = size
      size = size + nalength(azone2) * nalength(azone1) *
     &  int_mb(k_range_alpha+g3b-1) * nalength(azone3)
      END DO
      END DO
      END DO
      END DO
      RETURN
      END
c
c
c
      SUBROUTINE tce_offset_ggaa(l_a_offset,k_a_offset,size)
      IMPLICIT NONE
#include "global.fh"
#include "mafdecls.fh"
#include "sym.fh"
#include "errquit.fh"
#include "tce.fh"
#include "tce_main.fh"
      INTEGER l_a_offset
      INTEGER k_a_offset
      INTEGER size
      INTEGER length
      INTEGER addr
      INTEGER g3b,g4b,azone1,azone2
c ([g4]=>[g3]|[az1]<=[az2])
      length = 0
      DO azone2 = 1,atpart
      DO azone1 = 1,azone2
      DO g3b = 1,noa+nva
      DO g4b = g3b,noa+nva
      length = length + 1
      END DO
      END DO
      END DO
      END DO
      IF (.not.MA_PUSH_GET(mt_int,2*length+1,'noname',l_a_offset,k_a_off
     &set)) CALL ERRQUIT('tce_t2_offset',0,MA_ERR)
      int_mb(k_a_offset) = length
      addr = 0
      size = 0
      DO azone2 = 1,atpart
      DO azone1 = 1,azone2
      DO g3b = 1,noa+nva
      DO g4b = g3b,noa+nva
      addr = addr + 1
      int_mb(k_a_offset+addr) = g4b - 1 + (noa+nva) * (g3b - 1 +
     &  (noa+nva) * (azone1 - 1 + atpart * (azone2 - 1)))
      int_mb(k_a_offset+length+addr) = size
      size = size + nalength(azone2) * nalength(azone1) *
     &  int_mb(k_range_alpha+g3b-1) * int_mb(k_range_alpha+g4b-1)
      END DO
      END DO
      END DO
      END DO
      RETURN
      END
c
c
c
      SUBROUTINE tce_offset_ggga(l_a_offset,k_a_offset,size)
      IMPLICIT NONE
#include "global.fh"
#include "mafdecls.fh"
#include "sym.fh"
#include "errquit.fh"
#include "tce.fh"
#include "tce_main.fh"
      INTEGER l_a_offset
      INTEGER k_a_offset
      INTEGER size
      INTEGER length
      INTEGER addr
      INTEGER g3b,g4b,g2b,azone2
c ([g4]=>[g3]|[g2][az2])
      length = 0
      DO azone2 = 1,atpart
      DO g2b = 1,noa+nva
      DO g3b = 1,noa+nva
      DO g4b = g3b,noa+nva
      length = length + 1
      END DO
      END DO
      END DO
      END DO
      IF (.not.MA_PUSH_GET(mt_int,2*length+1,'noname',l_a_offset,k_a_off
     &set)) CALL ERRQUIT('tce_t2_offset',0,MA_ERR)
      int_mb(k_a_offset) = length
      addr = 0
      size = 0
      DO azone2 = 1,atpart
      DO g2b = 1,noa+nva
      DO g3b = 1,noa+nva
      DO g4b = g3b,noa+nva
      addr = addr + 1
      int_mb(k_a_offset+addr) = g4b - 1 + (noa+nva) * (g3b - 1 +
     &  (noa+nva) * (g2b - 1 + (noa+nva) * (azone2 - 1)))
      int_mb(k_a_offset+length+addr) = size
      size = size + nalength(azone2) * int_mb(k_range_alpha+g2b-1) *
     &  int_mb(k_range_alpha+g3b-1) * int_mb(k_range_alpha+g4b-1)
      END DO
      END DO
      END DO
      END DO
      RETURN
      END
      subroutine tce_gacreate_sloc(g_a, size, size_loc, gname)
      implicit none
#include "global.fh"
#include "mafdecls.fh"
#include "errquit.fh"
#include "stdio.fh"
      integer g_a
      character*(*) gname
      integer size
      integer size_loc
c
      if (.not.ga_create(mt_dbl,size,1,gname,
     1     size_loc,1,g_a)) then
         write(LuOut,*) ' available GA memory ',
     1        ga_memory_avail(),' bytes'
         call errquit ('tce_gacreate: failed ga_create size/nproc bytes'
     S      ,   (size*ma_sizeof(mt_dbl,1,mt_byte))/ga_nnodes(),
     1        GA_ERR)
      endif
      return
      end
