      SUBROUTINE OFFSET_eomccsdt_density1_1_1(l_a_offset,k_a_offset,size
     &)
C     $Id$
C     This is a Fortran77 program generated by Tensor Contraction Engine v.1.0
C     Copyright (c) Battelle & Pacific Northwest National Laboratory (2002)
C     i1 ( h2 p1 )_yx
      IMPLICIT NONE
#include "global.fh"
#include "mafdecls.fh"
#include "sym.fh"
#include "errquit.fh"
#include "tce.fh"
      INTEGER l_a_offset
      INTEGER k_a_offset
      INTEGER size
      INTEGER length
      INTEGER addr
      INTEGER h2b
      INTEGER p1b
      length = 0
      DO h2b = 1,noab
      DO p1b = noab+1,noab+nvab
      IF (int_mb(k_spin+h2b-1) .eq. int_mb(k_spin+p1b-1)) THEN
      IF (ieor(int_mb(k_sym+h2b-1),int_mb(k_sym+p1b-1)) .eq. ieor(irrep_
     &y,irrep_x)) THEN
      IF ((.not.restricted).or.(int_mb(k_spin+h2b-1)+int_mb(k_spin+p1b-1
     &).ne.4)) THEN
      length = length + 1
      END IF
      END IF
      END IF
      END DO
      END DO
      IF (.not.MA_PUSH_GET(mt_int,2*length+1,'noname',l_a_offset,k_a_off
     &set)) CALL ERRQUIT('eomccsdt_density1_1_1',0,MA_ERR)
      int_mb(k_a_offset) = length
      addr = 0
      size = 0
      DO h2b = 1,noab
      DO p1b = noab+1,noab+nvab
      IF (int_mb(k_spin+h2b-1) .eq. int_mb(k_spin+p1b-1)) THEN
      IF (ieor(int_mb(k_sym+h2b-1),int_mb(k_sym+p1b-1)) .eq. ieor(irrep_
     &y,irrep_x)) THEN
      IF ((.not.restricted).or.(int_mb(k_spin+h2b-1)+int_mb(k_spin+p1b-1
     &).ne.4)) THEN
      addr = addr + 1
      int_mb(k_a_offset+addr) = p1b - noab - 1 + nvab * (h2b - 1)
      int_mb(k_a_offset+length+addr) = size
      size = size + int_mb(k_range+h2b-1) * int_mb(k_range+p1b-1)
      END IF
      END IF
      END IF
      END DO
      END DO
      RETURN
      END
      SUBROUTINE OFFSET_eomccsdt_density1_2_1(l_a_offset,k_a_offset,size
     &)
C     $Id$
C     This is a Fortran77 program generated by Tensor Contraction Engine v.1.0
C     Copyright (c) Battelle & Pacific Northwest National Laboratory (2002)
C     i1 ( )_dx
      IMPLICIT NONE
#include "global.fh"
#include "mafdecls.fh"
#include "sym.fh"
#include "errquit.fh"
#include "tce.fh"
      INTEGER l_a_offset
      INTEGER k_a_offset
      INTEGER size
      INTEGER length
      INTEGER addr
      length = 0
      IF (0 .eq. ieor(irrep_d,irrep_x)) THEN
      length = length + 1
      END IF
      IF (.not.MA_PUSH_GET(mt_int,2*length+1,'noname',l_a_offset,k_a_off
     &set)) CALL ERRQUIT('eomccsdt_density1_2_1',0,MA_ERR)
      int_mb(k_a_offset) = length
      addr = 0
      size = 0
      IF (0 .eq. ieor(irrep_d,irrep_x)) THEN
      addr = addr + 1
      int_mb(k_a_offset+addr) = 0
      int_mb(k_a_offset+length+addr) = size
      size = 1
      END IF
      RETURN
      END
      SUBROUTINE OFFSET_eomccsdt_density1_2_2_1(l_a_offset,k_a_offset,si
     &ze)
C     $Id$
C     This is a Fortran77 program generated by Tensor Contraction Engine v.1.0
C     Copyright (c) Battelle & Pacific Northwest National Laboratory (2002)
C     i2 ( )_dt
      IMPLICIT NONE
#include "global.fh"
#include "mafdecls.fh"
#include "sym.fh"
#include "errquit.fh"
#include "tce.fh"
      INTEGER l_a_offset
      INTEGER k_a_offset
      INTEGER size
      INTEGER length
      INTEGER addr
      length = 0
      IF (0 .eq. ieor(irrep_d,irrep_t)) THEN
      length = length + 1
      END IF
      IF (.not.MA_PUSH_GET(mt_int,2*length+1,'noname',l_a_offset,k_a_off
     &set)) CALL ERRQUIT('eomccsdt_density1_2_2_1',0,MA_ERR)
      int_mb(k_a_offset) = length
      addr = 0
      size = 0
      IF (0 .eq. ieor(irrep_d,irrep_t)) THEN
      addr = addr + 1
      int_mb(k_a_offset+addr) = 0
      int_mb(k_a_offset+length+addr) = size
      size = 1
      END IF
      RETURN
      END
      SUBROUTINE OFFSET_eomccsdt_density1_3_1(l_a_offset,k_a_offset,size
     &)
C     $Id$
C     This is a Fortran77 program generated by Tensor Contraction Engine v.1.0
C     Copyright (c) Battelle & Pacific Northwest National Laboratory (2002)
C     i1 ( h2 h1 )_yx
      IMPLICIT NONE
#include "global.fh"
#include "mafdecls.fh"
#include "sym.fh"
#include "errquit.fh"
#include "tce.fh"
      INTEGER l_a_offset
      INTEGER k_a_offset
      INTEGER size
      INTEGER length
      INTEGER addr
      INTEGER h2b
      INTEGER h1b
      length = 0
      DO h2b = 1,noab
      DO h1b = 1,noab
      IF (int_mb(k_spin+h2b-1) .eq. int_mb(k_spin+h1b-1)) THEN
      IF (ieor(int_mb(k_sym+h2b-1),int_mb(k_sym+h1b-1)) .eq. ieor(irrep_
     &y,irrep_x)) THEN
      IF ((.not.restricted).or.(int_mb(k_spin+h2b-1)+int_mb(k_spin+h1b-1
     &).ne.4)) THEN
      length = length + 1
      END IF
      END IF
      END IF
      END DO
      END DO
      IF (.not.MA_PUSH_GET(mt_int,2*length+1,'noname',l_a_offset,k_a_off
     &set)) CALL ERRQUIT('eomccsdt_density1_3_1',0,MA_ERR)
      int_mb(k_a_offset) = length
      addr = 0
      size = 0
      DO h2b = 1,noab
      DO h1b = 1,noab
      IF (int_mb(k_spin+h2b-1) .eq. int_mb(k_spin+h1b-1)) THEN
      IF (ieor(int_mb(k_sym+h2b-1),int_mb(k_sym+h1b-1)) .eq. ieor(irrep_
     &y,irrep_x)) THEN
      IF ((.not.restricted).or.(int_mb(k_spin+h2b-1)+int_mb(k_spin+h1b-1
     &).ne.4)) THEN
      addr = addr + 1
      int_mb(k_a_offset+addr) = h1b - 1 + noab * (h2b - 1)
      int_mb(k_a_offset+length+addr) = size
      size = size + int_mb(k_range+h2b-1) * int_mb(k_range+h1b-1)
      END IF
      END IF
      END IF
      END DO
      END DO
      RETURN
      END
      SUBROUTINE OFFSET_eomccsdt_density1_3_4_1(l_a_offset,k_a_offset,si
     &ze)
C     $Id$
C     This is a Fortran77 program generated by Tensor Contraction Engine v.1.0
C     Copyright (c) Battelle & Pacific Northwest National Laboratory (2002)
C     i2 ( h2 h1 )_yt
      IMPLICIT NONE
#include "global.fh"
#include "mafdecls.fh"
#include "sym.fh"
#include "errquit.fh"
#include "tce.fh"
      INTEGER l_a_offset
      INTEGER k_a_offset
      INTEGER size
      INTEGER length
      INTEGER addr
      INTEGER h2b
      INTEGER h1b
      length = 0
      DO h2b = 1,noab
      DO h1b = 1,noab
      IF (int_mb(k_spin+h2b-1) .eq. int_mb(k_spin+h1b-1)) THEN
      IF (ieor(int_mb(k_sym+h2b-1),int_mb(k_sym+h1b-1)) .eq. ieor(irrep_
     &y,irrep_t)) THEN
      IF ((.not.restricted).or.(int_mb(k_spin+h2b-1)+int_mb(k_spin+h1b-1
     &).ne.4)) THEN
      length = length + 1
      END IF
      END IF
      END IF
      END DO
      END DO
      IF (.not.MA_PUSH_GET(mt_int,2*length+1,'noname',l_a_offset,k_a_off
     &set)) CALL ERRQUIT('eomccsdt_density1_3_4_1',0,MA_ERR)
      int_mb(k_a_offset) = length
      addr = 0
      size = 0
      DO h2b = 1,noab
      DO h1b = 1,noab
      IF (int_mb(k_spin+h2b-1) .eq. int_mb(k_spin+h1b-1)) THEN
      IF (ieor(int_mb(k_sym+h2b-1),int_mb(k_sym+h1b-1)) .eq. ieor(irrep_
     &y,irrep_t)) THEN
      IF ((.not.restricted).or.(int_mb(k_spin+h2b-1)+int_mb(k_spin+h1b-1
     &).ne.4)) THEN
      addr = addr + 1
      int_mb(k_a_offset+addr) = h1b - 1 + noab * (h2b - 1)
      int_mb(k_a_offset+length+addr) = size
      size = size + int_mb(k_range+h2b-1) * int_mb(k_range+h1b-1)
      END IF
      END IF
      END IF
      END DO
      END DO
      RETURN
      END
      SUBROUTINE OFFSET_eomccsdt_density1_3_5_1(l_a_offset,k_a_offset,si
     &ze)
C     $Id$
C     This is a Fortran77 program generated by Tensor Contraction Engine v.1.0
C     Copyright (c) Battelle & Pacific Northwest National Laboratory (2002)
C     i2 ( h2 p3 )_yx
      IMPLICIT NONE
#include "global.fh"
#include "mafdecls.fh"
#include "sym.fh"
#include "errquit.fh"
#include "tce.fh"
      INTEGER l_a_offset
      INTEGER k_a_offset
      INTEGER size
      INTEGER length
      INTEGER addr
      INTEGER h2b
      INTEGER p3b
      length = 0
      DO h2b = 1,noab
      DO p3b = noab+1,noab+nvab
      IF (int_mb(k_spin+h2b-1) .eq. int_mb(k_spin+p3b-1)) THEN
      IF (ieor(int_mb(k_sym+h2b-1),int_mb(k_sym+p3b-1)) .eq. ieor(irrep_
     &y,irrep_x)) THEN
      IF ((.not.restricted).or.(int_mb(k_spin+h2b-1)+int_mb(k_spin+p3b-1
     &).ne.4)) THEN
      length = length + 1
      END IF
      END IF
      END IF
      END DO
      END DO
      IF (.not.MA_PUSH_GET(mt_int,2*length+1,'noname',l_a_offset,k_a_off
     &set)) CALL ERRQUIT('eomccsdt_density1_3_5_1',0,MA_ERR)
      int_mb(k_a_offset) = length
      addr = 0
      size = 0
      DO h2b = 1,noab
      DO p3b = noab+1,noab+nvab
      IF (int_mb(k_spin+h2b-1) .eq. int_mb(k_spin+p3b-1)) THEN
      IF (ieor(int_mb(k_sym+h2b-1),int_mb(k_sym+p3b-1)) .eq. ieor(irrep_
     &y,irrep_x)) THEN
      IF ((.not.restricted).or.(int_mb(k_spin+h2b-1)+int_mb(k_spin+p3b-1
     &).ne.4)) THEN
      addr = addr + 1
      int_mb(k_a_offset+addr) = p3b - noab - 1 + nvab * (h2b - 1)
      int_mb(k_a_offset+length+addr) = size
      size = size + int_mb(k_range+h2b-1) * int_mb(k_range+p3b-1)
      END IF
      END IF
      END IF
      END DO
      END DO
      RETURN
      END
      SUBROUTINE OFFSET_eomccsdt_density1_3_6_1(l_a_offset,k_a_offset,si
     &ze)
C     $Id$
C     This is a Fortran77 program generated by Tensor Contraction Engine v.1.0
C     Copyright (c) Battelle & Pacific Northwest National Laboratory (2002)
C     i2 ( h2 h5 p3 p4 )_yx
      IMPLICIT NONE
#include "global.fh"
#include "mafdecls.fh"
#include "sym.fh"
#include "errquit.fh"
#include "tce.fh"
      INTEGER l_a_offset
      INTEGER k_a_offset
      INTEGER size
      INTEGER length
      INTEGER addr
      INTEGER h2b
      INTEGER h5b
      INTEGER p3b
      INTEGER p4b
      length = 0
      DO h2b = 1,noab
      DO h5b = h2b,noab
      DO p3b = noab+1,noab+nvab
      DO p4b = p3b,noab+nvab
      IF (int_mb(k_spin+h2b-1)+int_mb(k_spin+h5b-1) .eq. int_mb(k_spin+p
     &3b-1)+int_mb(k_spin+p4b-1)) THEN
      IF (ieor(int_mb(k_sym+h2b-1),ieor(int_mb(k_sym+h5b-1),ieor(int_mb(
     &k_sym+p3b-1),int_mb(k_sym+p4b-1)))) .eq. ieor(irrep_y,irrep_x)) TH
     &EN
      IF ((.not.restricted).or.(int_mb(k_spin+h2b-1)+int_mb(k_spin+h5b-1
     &)+int_mb(k_spin+p3b-1)+int_mb(k_spin+p4b-1).ne.8)) THEN
      length = length + 1
      END IF
      END IF
      END IF
      END DO
      END DO
      END DO
      END DO
      IF (.not.MA_PUSH_GET(mt_int,2*length+1,'noname',l_a_offset,k_a_off
     &set)) CALL ERRQUIT('eomccsdt_density1_3_6_1',0,MA_ERR)
      int_mb(k_a_offset) = length
      addr = 0
      size = 0
      DO h2b = 1,noab
      DO h5b = h2b,noab
      DO p3b = noab+1,noab+nvab
      DO p4b = p3b,noab+nvab
      IF (int_mb(k_spin+h2b-1)+int_mb(k_spin+h5b-1) .eq. int_mb(k_spin+p
     &3b-1)+int_mb(k_spin+p4b-1)) THEN
      IF (ieor(int_mb(k_sym+h2b-1),ieor(int_mb(k_sym+h5b-1),ieor(int_mb(
     &k_sym+p3b-1),int_mb(k_sym+p4b-1)))) .eq. ieor(irrep_y,irrep_x)) TH
     &EN
      IF ((.not.restricted).or.(int_mb(k_spin+h2b-1)+int_mb(k_spin+h5b-1
     &)+int_mb(k_spin+p3b-1)+int_mb(k_spin+p4b-1).ne.8)) THEN
      addr = addr + 1
      int_mb(k_a_offset+addr) = p4b - noab - 1 + nvab * (p3b - noab - 1 
     &+ nvab * (h5b - 1 + noab * (h2b - 1)))
      int_mb(k_a_offset+length+addr) = size
      size = size + int_mb(k_range+h2b-1) * int_mb(k_range+h5b-1) * int_
     &mb(k_range+p3b-1) * int_mb(k_range+p4b-1)
      END IF
      END IF
      END IF
      END DO
      END DO
      END DO
      END DO
      RETURN
      END
      SUBROUTINE OFFSET_eomccsdt_density1_4_1(l_a_offset,k_a_offset,size
     &)
C     $Id$
C     This is a Fortran77 program generated by Tensor Contraction Engine v.1.0
C     Copyright (c) Battelle & Pacific Northwest National Laboratory (2002)
C     i1 ( p1 h3 )_dx
      IMPLICIT NONE
#include "global.fh"
#include "mafdecls.fh"
#include "sym.fh"
#include "errquit.fh"
#include "tce.fh"
      INTEGER l_a_offset
      INTEGER k_a_offset
      INTEGER size
      INTEGER length
      INTEGER addr
      INTEGER p1b
      INTEGER h3b
      length = 0
      DO p1b = noab+1,noab+nvab
      DO h3b = 1,noab
      IF (int_mb(k_spin+p1b-1) .eq. int_mb(k_spin+h3b-1)) THEN
      IF (ieor(int_mb(k_sym+p1b-1),int_mb(k_sym+h3b-1)) .eq. ieor(irrep_
     &d,irrep_x)) THEN
      IF ((.not.restricted).or.(int_mb(k_spin+p1b-1)+int_mb(k_spin+h3b-1
     &).ne.4)) THEN
      length = length + 1
      END IF
      END IF
      END IF
      END DO
      END DO
      IF (.not.MA_PUSH_GET(mt_int,2*length+1,'noname',l_a_offset,k_a_off
     &set)) CALL ERRQUIT('eomccsdt_density1_4_1',0,MA_ERR)
      int_mb(k_a_offset) = length
      addr = 0
      size = 0
      DO p1b = noab+1,noab+nvab
      DO h3b = 1,noab
      IF (int_mb(k_spin+p1b-1) .eq. int_mb(k_spin+h3b-1)) THEN
      IF (ieor(int_mb(k_sym+p1b-1),int_mb(k_sym+h3b-1)) .eq. ieor(irrep_
     &d,irrep_x)) THEN
      IF ((.not.restricted).or.(int_mb(k_spin+p1b-1)+int_mb(k_spin+h3b-1
     &).ne.4)) THEN
      addr = addr + 1
      int_mb(k_a_offset+addr) = h3b - 1 + noab * (p1b - noab - 1)
      int_mb(k_a_offset+length+addr) = size
      size = size + int_mb(k_range+p1b-1) * int_mb(k_range+h3b-1)
      END IF
      END IF
      END IF
      END DO
      END DO
      RETURN
      END
      SUBROUTINE OFFSET_eomccsdt_density1_4_2_1(l_a_offset,k_a_offset,si
     &ze)
C     $Id$
C     This is a Fortran77 program generated by Tensor Contraction Engine v.1.0
C     Copyright (c) Battelle & Pacific Northwest National Laboratory (2002)
C     i2 ( p1 h3 )_dt
      IMPLICIT NONE
#include "global.fh"
#include "mafdecls.fh"
#include "sym.fh"
#include "errquit.fh"
#include "tce.fh"
      INTEGER l_a_offset
      INTEGER k_a_offset
      INTEGER size
      INTEGER length
      INTEGER addr
      INTEGER p1b
      INTEGER h3b
      length = 0
      DO p1b = noab+1,noab+nvab
      DO h3b = 1,noab
      IF (int_mb(k_spin+p1b-1) .eq. int_mb(k_spin+h3b-1)) THEN
      IF (ieor(int_mb(k_sym+p1b-1),int_mb(k_sym+h3b-1)) .eq. ieor(irrep_
     &d,irrep_t)) THEN
      IF ((.not.restricted).or.(int_mb(k_spin+p1b-1)+int_mb(k_spin+h3b-1
     &).ne.4)) THEN
      length = length + 1
      END IF
      END IF
      END IF
      END DO
      END DO
      IF (.not.MA_PUSH_GET(mt_int,2*length+1,'noname',l_a_offset,k_a_off
     &set)) CALL ERRQUIT('eomccsdt_density1_4_2_1',0,MA_ERR)
      int_mb(k_a_offset) = length
      addr = 0
      size = 0
      DO p1b = noab+1,noab+nvab
      DO h3b = 1,noab
      IF (int_mb(k_spin+p1b-1) .eq. int_mb(k_spin+h3b-1)) THEN
      IF (ieor(int_mb(k_sym+p1b-1),int_mb(k_sym+h3b-1)) .eq. ieor(irrep_
     &d,irrep_t)) THEN
      IF ((.not.restricted).or.(int_mb(k_spin+p1b-1)+int_mb(k_spin+h3b-1
     &).ne.4)) THEN
      addr = addr + 1
      int_mb(k_a_offset+addr) = h3b - 1 + noab * (p1b - noab - 1)
      int_mb(k_a_offset+length+addr) = size
      size = size + int_mb(k_range+p1b-1) * int_mb(k_range+h3b-1)
      END IF
      END IF
      END IF
      END DO
      END DO
      RETURN
      END
      SUBROUTINE OFFSET_eomccsdt_density1_5_10_1(l_a_offset,k_a_offset,s
     &ize)
C     $Id$
C     This is a Fortran77 program generated by Tensor Contraction Engine v.1.0
C     Copyright (c) Battelle & Pacific Northwest National Laboratory (2002)
C     i2 ( p11 h10 )_yt
      IMPLICIT NONE
#include "global.fh"
#include "mafdecls.fh"
#include "sym.fh"
#include "errquit.fh"
#include "tce.fh"
      INTEGER l_a_offset
      INTEGER k_a_offset
      INTEGER size
      INTEGER length
      INTEGER addr
      INTEGER p11b
      INTEGER h10b
      length = 0
      DO p11b = noab+1,noab+nvab
      DO h10b = 1,noab
      IF (int_mb(k_spin+p11b-1) .eq. int_mb(k_spin+h10b-1)) THEN
      IF (ieor(int_mb(k_sym+p11b-1),int_mb(k_sym+h10b-1)) .eq. ieor(irre
     &p_y,irrep_t)) THEN
      IF ((.not.restricted).or.(int_mb(k_spin+p11b-1)+int_mb(k_spin+h10b
     &-1).ne.4)) THEN
      length = length + 1
      END IF
      END IF
      END IF
      END DO
      END DO
      IF (.not.MA_PUSH_GET(mt_int,2*length+1,'noname',l_a_offset,k_a_off
     &set)) CALL ERRQUIT('eomccsdt_density1_5_10_1',0,MA_ERR)
      int_mb(k_a_offset) = length
      addr = 0
      size = 0
      DO p11b = noab+1,noab+nvab
      DO h10b = 1,noab
      IF (int_mb(k_spin+p11b-1) .eq. int_mb(k_spin+h10b-1)) THEN
      IF (ieor(int_mb(k_sym+p11b-1),int_mb(k_sym+h10b-1)) .eq. ieor(irre
     &p_y,irrep_t)) THEN
      IF ((.not.restricted).or.(int_mb(k_spin+p11b-1)+int_mb(k_spin+h10b
     &-1).ne.4)) THEN
      addr = addr + 1
      int_mb(k_a_offset+addr) = h10b - 1 + noab * (p11b - noab - 1)
      int_mb(k_a_offset+length+addr) = size
      size = size + int_mb(k_range+p11b-1) * int_mb(k_range+h10b-1)
      END IF
      END IF
      END IF
      END DO
      END DO
      RETURN
      END
      SUBROUTINE OFFSET_eomccsdt_density1_5_10_2_1(l_a_offset,k_a_offset
     &,size)
C     $Id$
C     This is a Fortran77 program generated by Tensor Contraction Engine v.1.0
C     Copyright (c) Battelle & Pacific Northwest National Laboratory (2002)
C     i3 ( h1 h2 h10 p8 )_yt
      IMPLICIT NONE
#include "global.fh"
#include "mafdecls.fh"
#include "sym.fh"
#include "errquit.fh"
#include "tce.fh"
      INTEGER l_a_offset
      INTEGER k_a_offset
      INTEGER size
      INTEGER length
      INTEGER addr
      INTEGER h1b
      INTEGER h2b
      INTEGER h10b
      INTEGER p8b
      length = 0
      DO h1b = 1,noab
      DO h2b = h1b,noab
      DO h10b = 1,noab
      DO p8b = noab+1,noab+nvab
      IF (int_mb(k_spin+h1b-1)+int_mb(k_spin+h2b-1) .eq. int_mb(k_spin+h
     &10b-1)+int_mb(k_spin+p8b-1)) THEN
      IF (ieor(int_mb(k_sym+h1b-1),ieor(int_mb(k_sym+h2b-1),ieor(int_mb(
     &k_sym+h10b-1),int_mb(k_sym+p8b-1)))) .eq. ieor(irrep_y,irrep_t)) T
     &HEN
      IF ((.not.restricted).or.(int_mb(k_spin+h1b-1)+int_mb(k_spin+h2b-1
     &)+int_mb(k_spin+h10b-1)+int_mb(k_spin+p8b-1).ne.8)) THEN
      length = length + 1
      END IF
      END IF
      END IF
      END DO
      END DO
      END DO
      END DO
      IF (.not.MA_PUSH_GET(mt_int,2*length+1,'noname',l_a_offset,k_a_off
     &set)) CALL ERRQUIT('eomccsdt_density1_5_10_2_1',0,MA_ERR)
      int_mb(k_a_offset) = length
      addr = 0
      size = 0
      DO h1b = 1,noab
      DO h2b = h1b,noab
      DO h10b = 1,noab
      DO p8b = noab+1,noab+nvab
      IF (int_mb(k_spin+h1b-1)+int_mb(k_spin+h2b-1) .eq. int_mb(k_spin+h
     &10b-1)+int_mb(k_spin+p8b-1)) THEN
      IF (ieor(int_mb(k_sym+h1b-1),ieor(int_mb(k_sym+h2b-1),ieor(int_mb(
     &k_sym+h10b-1),int_mb(k_sym+p8b-1)))) .eq. ieor(irrep_y,irrep_t)) T
     &HEN
      IF ((.not.restricted).or.(int_mb(k_spin+h1b-1)+int_mb(k_spin+h2b-1
     &)+int_mb(k_spin+h10b-1)+int_mb(k_spin+p8b-1).ne.8)) THEN
      addr = addr + 1
      int_mb(k_a_offset+addr) = p8b - noab - 1 + nvab * (h10b - 1 + noab
     & * (h2b - 1 + noab * (h1b - 1)))
      int_mb(k_a_offset+length+addr) = size
      size = size + int_mb(k_range+h1b-1) * int_mb(k_range+h2b-1) * int_
     &mb(k_range+h10b-1) * int_mb(k_range+p8b-1)
      END IF
      END IF
      END IF
      END DO
      END DO
      END DO
      END DO
      RETURN
      END
      SUBROUTINE OFFSET_eomccsdt_density1_5_10_2_2_1(l_a_offset,k_a_offs
     &et,size)
C     $Id$
C     This is a Fortran77 program generated by Tensor Contraction Engine v.1.0
C     Copyright (c) Battelle & Pacific Northwest National Laboratory (2002)
C     i4 ( h1 h2 h7 p5 p6 p8 )_y
      IMPLICIT NONE
#include "global.fh"
#include "mafdecls.fh"
#include "sym.fh"
#include "errquit.fh"
#include "tce.fh"
      INTEGER l_a_offset
      INTEGER k_a_offset
      INTEGER size
      INTEGER length
      INTEGER addr
      INTEGER h1b
      INTEGER h2b
      INTEGER h7b
      INTEGER p5b
      INTEGER p6b
      INTEGER p8b
      length = 0
      DO h1b = 1,noab
      DO h2b = h1b,noab
      DO h7b = h2b,noab
      DO p5b = noab+1,noab+nvab
      DO p6b = p5b,noab+nvab
      DO p8b = p6b,noab+nvab
      IF (int_mb(k_spin+h1b-1)+int_mb(k_spin+h2b-1)+int_mb(k_spin+h7b-1)
     & .eq. int_mb(k_spin+p5b-1)+int_mb(k_spin+p6b-1)+int_mb(k_spin+p8b-
     &1)) THEN
      IF (ieor(int_mb(k_sym+h1b-1),ieor(int_mb(k_sym+h2b-1),ieor(int_mb(
     &k_sym+h7b-1),ieor(int_mb(k_sym+p5b-1),ieor(int_mb(k_sym+p6b-1),int
     &_mb(k_sym+p8b-1)))))) .eq. irrep_y) THEN
      IF ((.not.restricted).or.(int_mb(k_spin+h1b-1)+int_mb(k_spin+h2b-1
     &)+int_mb(k_spin+h7b-1)+int_mb(k_spin+p5b-1)+int_mb(k_spin+p6b-1)+i
     &nt_mb(k_spin+p8b-1).ne.12)) THEN
      length = length + 1
      END IF
      END IF
      END IF
      END DO
      END DO
      END DO
      END DO
      END DO
      END DO
      IF (.not.MA_PUSH_GET(mt_int,2*length+1,'noname',l_a_offset,k_a_off
     &set)) CALL ERRQUIT('eomccsdt_density1_5_10_2_2_1',0,MA_ERR)
      int_mb(k_a_offset) = length
      addr = 0
      size = 0
      DO h1b = 1,noab
      DO h2b = h1b,noab
      DO h7b = h2b,noab
      DO p5b = noab+1,noab+nvab
      DO p6b = p5b,noab+nvab
      DO p8b = p6b,noab+nvab
      IF (int_mb(k_spin+h1b-1)+int_mb(k_spin+h2b-1)+int_mb(k_spin+h7b-1)
     & .eq. int_mb(k_spin+p5b-1)+int_mb(k_spin+p6b-1)+int_mb(k_spin+p8b-
     &1)) THEN
      IF (ieor(int_mb(k_sym+h1b-1),ieor(int_mb(k_sym+h2b-1),ieor(int_mb(
     &k_sym+h7b-1),ieor(int_mb(k_sym+p5b-1),ieor(int_mb(k_sym+p6b-1),int
     &_mb(k_sym+p8b-1)))))) .eq. irrep_y) THEN
      IF ((.not.restricted).or.(int_mb(k_spin+h1b-1)+int_mb(k_spin+h2b-1
     &)+int_mb(k_spin+h7b-1)+int_mb(k_spin+p5b-1)+int_mb(k_spin+p6b-1)+i
     &nt_mb(k_spin+p8b-1).ne.12)) THEN
      addr = addr + 1
      int_mb(k_a_offset+addr) = p8b - noab - 1 + nvab * (p6b - noab - 1 
     &+ nvab * (p5b - noab - 1 + nvab * (h7b - 1 + noab * (h2b - 1 + noa
     &b * (h1b - 1)))))
      int_mb(k_a_offset+length+addr) = size
      size = size + int_mb(k_range+h1b-1) * int_mb(k_range+h2b-1) * int_
     &mb(k_range+h7b-1) * int_mb(k_range+p5b-1) * int_mb(k_range+p6b-1) 
     &* int_mb(k_range+p8b-1)
      END IF
      END IF
      END IF
      END DO
      END DO
      END DO
      END DO
      END DO
      END DO
      RETURN
      END
      SUBROUTINE OFFSET_eomccsdt_density1_5_10_3_1(l_a_offset,k_a_offset
     &,size)
C     $Id$
C     This is a Fortran77 program generated by Tensor Contraction Engine v.1.0
C     Copyright (c) Battelle & Pacific Northwest National Laboratory (2002)
C     i3 ( h5 h6 h7 h10 p3 p4 )_yt
      IMPLICIT NONE
#include "global.fh"
#include "mafdecls.fh"
#include "sym.fh"
#include "errquit.fh"
#include "tce.fh"
      INTEGER l_a_offset
      INTEGER k_a_offset
      INTEGER size
      INTEGER length
      INTEGER addr
      INTEGER h5b
      INTEGER h6b
      INTEGER h7b
      INTEGER h10b
      INTEGER p3b
      INTEGER p4b
      length = 0
      DO h5b = 1,noab
      DO h6b = h5b,noab
      DO h7b = h6b,noab
      DO h10b = 1,noab
      DO p3b = noab+1,noab+nvab
      DO p4b = p3b,noab+nvab
      IF (int_mb(k_spin+h5b-1)+int_mb(k_spin+h6b-1)+int_mb(k_spin+h7b-1)
     & .eq. int_mb(k_spin+h10b-1)+int_mb(k_spin+p3b-1)+int_mb(k_spin+p4b
     &-1)) THEN
      IF (ieor(int_mb(k_sym+h5b-1),ieor(int_mb(k_sym+h6b-1),ieor(int_mb(
     &k_sym+h7b-1),ieor(int_mb(k_sym+h10b-1),ieor(int_mb(k_sym+p3b-1),in
     &t_mb(k_sym+p4b-1)))))) .eq. ieor(irrep_y,irrep_t)) THEN
      IF ((.not.restricted).or.(int_mb(k_spin+h5b-1)+int_mb(k_spin+h6b-1
     &)+int_mb(k_spin+h7b-1)+int_mb(k_spin+h10b-1)+int_mb(k_spin+p3b-1)+
     &int_mb(k_spin+p4b-1).ne.12)) THEN
      length = length + 1
      END IF
      END IF
      END IF
      END DO
      END DO
      END DO
      END DO
      END DO
      END DO
      IF (.not.MA_PUSH_GET(mt_int,2*length+1,'noname',l_a_offset,k_a_off
     &set)) CALL ERRQUIT('eomccsdt_density1_5_10_3_1',0,MA_ERR)
      int_mb(k_a_offset) = length
      addr = 0
      size = 0
      DO h5b = 1,noab
      DO h6b = h5b,noab
      DO h7b = h6b,noab
      DO h10b = 1,noab
      DO p3b = noab+1,noab+nvab
      DO p4b = p3b,noab+nvab
      IF (int_mb(k_spin+h5b-1)+int_mb(k_spin+h6b-1)+int_mb(k_spin+h7b-1)
     & .eq. int_mb(k_spin+h10b-1)+int_mb(k_spin+p3b-1)+int_mb(k_spin+p4b
     &-1)) THEN
      IF (ieor(int_mb(k_sym+h5b-1),ieor(int_mb(k_sym+h6b-1),ieor(int_mb(
     &k_sym+h7b-1),ieor(int_mb(k_sym+h10b-1),ieor(int_mb(k_sym+p3b-1),in
     &t_mb(k_sym+p4b-1)))))) .eq. ieor(irrep_y,irrep_t)) THEN
      IF ((.not.restricted).or.(int_mb(k_spin+h5b-1)+int_mb(k_spin+h6b-1
     &)+int_mb(k_spin+h7b-1)+int_mb(k_spin+h10b-1)+int_mb(k_spin+p3b-1)+
     &int_mb(k_spin+p4b-1).ne.12)) THEN
      addr = addr + 1
      int_mb(k_a_offset+addr) = p4b - noab - 1 + nvab * (p3b - noab - 1 
     &+ nvab * (h10b - 1 + noab * (h7b - 1 + noab * (h6b - 1 + noab * (h
     &5b - 1)))))
      int_mb(k_a_offset+length+addr) = size
      size = size + int_mb(k_range+h5b-1) * int_mb(k_range+h6b-1) * int_
     &mb(k_range+h7b-1) * int_mb(k_range+h10b-1) * int_mb(k_range+p3b-1)
     & * int_mb(k_range+p4b-1)
      END IF
      END IF
      END IF
      END DO
      END DO
      END DO
      END DO
      END DO
      END DO
      RETURN
      END
      SUBROUTINE OFFSET_eomccsdt_density1_5_11_1(l_a_offset,k_a_offset,s
     &ize)
C     $Id$
C     This is a Fortran77 program generated by Tensor Contraction Engine v.1.0
C     Copyright (c) Battelle & Pacific Northwest National Laboratory (2002)
C     i2 ( h5 h6 h7 h10 p3 p4 )_yx
      IMPLICIT NONE
#include "global.fh"
#include "mafdecls.fh"
#include "sym.fh"
#include "errquit.fh"
#include "tce.fh"
      INTEGER l_a_offset
      INTEGER k_a_offset
      INTEGER size
      INTEGER length
      INTEGER addr
      INTEGER h5b
      INTEGER h6b
      INTEGER h7b
      INTEGER h10b
      INTEGER p3b
      INTEGER p4b
      length = 0
      DO h5b = 1,noab
      DO h6b = h5b,noab
      DO h7b = h6b,noab
      DO h10b = 1,noab
      DO p3b = noab+1,noab+nvab
      DO p4b = p3b,noab+nvab
      IF (int_mb(k_spin+h5b-1)+int_mb(k_spin+h6b-1)+int_mb(k_spin+h7b-1)
     & .eq. int_mb(k_spin+h10b-1)+int_mb(k_spin+p3b-1)+int_mb(k_spin+p4b
     &-1)) THEN
      IF (ieor(int_mb(k_sym+h5b-1),ieor(int_mb(k_sym+h6b-1),ieor(int_mb(
     &k_sym+h7b-1),ieor(int_mb(k_sym+h10b-1),ieor(int_mb(k_sym+p3b-1),in
     &t_mb(k_sym+p4b-1)))))) .eq. ieor(irrep_y,irrep_x)) THEN
      IF ((.not.restricted).or.(int_mb(k_spin+h5b-1)+int_mb(k_spin+h6b-1
     &)+int_mb(k_spin+h7b-1)+int_mb(k_spin+h10b-1)+int_mb(k_spin+p3b-1)+
     &int_mb(k_spin+p4b-1).ne.12)) THEN
      length = length + 1
      END IF
      END IF
      END IF
      END DO
      END DO
      END DO
      END DO
      END DO
      END DO
      IF (.not.MA_PUSH_GET(mt_int,2*length+1,'noname',l_a_offset,k_a_off
     &set)) CALL ERRQUIT('eomccsdt_density1_5_11_1',0,MA_ERR)
      int_mb(k_a_offset) = length
      addr = 0
      size = 0
      DO h5b = 1,noab
      DO h6b = h5b,noab
      DO h7b = h6b,noab
      DO h10b = 1,noab
      DO p3b = noab+1,noab+nvab
      DO p4b = p3b,noab+nvab
      IF (int_mb(k_spin+h5b-1)+int_mb(k_spin+h6b-1)+int_mb(k_spin+h7b-1)
     & .eq. int_mb(k_spin+h10b-1)+int_mb(k_spin+p3b-1)+int_mb(k_spin+p4b
     &-1)) THEN
      IF (ieor(int_mb(k_sym+h5b-1),ieor(int_mb(k_sym+h6b-1),ieor(int_mb(
     &k_sym+h7b-1),ieor(int_mb(k_sym+h10b-1),ieor(int_mb(k_sym+p3b-1),in
     &t_mb(k_sym+p4b-1)))))) .eq. ieor(irrep_y,irrep_x)) THEN
      IF ((.not.restricted).or.(int_mb(k_spin+h5b-1)+int_mb(k_spin+h6b-1
     &)+int_mb(k_spin+h7b-1)+int_mb(k_spin+h10b-1)+int_mb(k_spin+p3b-1)+
     &int_mb(k_spin+p4b-1).ne.12)) THEN
      addr = addr + 1
      int_mb(k_a_offset+addr) = p4b - noab - 1 + nvab * (p3b - noab - 1 
     &+ nvab * (h10b - 1 + noab * (h7b - 1 + noab * (h6b - 1 + noab * (h
     &5b - 1)))))
      int_mb(k_a_offset+length+addr) = size
      size = size + int_mb(k_range+h5b-1) * int_mb(k_range+h6b-1) * int_
     &mb(k_range+h7b-1) * int_mb(k_range+h10b-1) * int_mb(k_range+p3b-1)
     & * int_mb(k_range+p4b-1)
      END IF
      END IF
      END IF
      END DO
      END DO
      END DO
      END DO
      END DO
      END DO
      RETURN
      END
      SUBROUTINE OFFSET_eomccsdt_density1_5_12_1(l_a_offset,k_a_offset,s
     &ize)
C     $Id$
C     This is a Fortran77 program generated by Tensor Contraction Engine v.1.0
C     Copyright (c) Battelle & Pacific Northwest National Laboratory (2002)
C     i2 ( h5 h6 p3 p4 )_yx
      IMPLICIT NONE
#include "global.fh"
#include "mafdecls.fh"
#include "sym.fh"
#include "errquit.fh"
#include "tce.fh"
      INTEGER l_a_offset
      INTEGER k_a_offset
      INTEGER size
      INTEGER length
      INTEGER addr
      INTEGER h5b
      INTEGER h6b
      INTEGER p3b
      INTEGER p4b
      length = 0
      DO h5b = 1,noab
      DO h6b = h5b,noab
      DO p3b = noab+1,noab+nvab
      DO p4b = p3b,noab+nvab
      IF (int_mb(k_spin+h5b-1)+int_mb(k_spin+h6b-1) .eq. int_mb(k_spin+p
     &3b-1)+int_mb(k_spin+p4b-1)) THEN
      IF (ieor(int_mb(k_sym+h5b-1),ieor(int_mb(k_sym+h6b-1),ieor(int_mb(
     &k_sym+p3b-1),int_mb(k_sym+p4b-1)))) .eq. ieor(irrep_y,irrep_x)) TH
     &EN
      IF ((.not.restricted).or.(int_mb(k_spin+h5b-1)+int_mb(k_spin+h6b-1
     &)+int_mb(k_spin+p3b-1)+int_mb(k_spin+p4b-1).ne.8)) THEN
      length = length + 1
      END IF
      END IF
      END IF
      END DO
      END DO
      END DO
      END DO
      IF (.not.MA_PUSH_GET(mt_int,2*length+1,'noname',l_a_offset,k_a_off
     &set)) CALL ERRQUIT('eomccsdt_density1_5_12_1',0,MA_ERR)
      int_mb(k_a_offset) = length
      addr = 0
      size = 0
      DO h5b = 1,noab
      DO h6b = h5b,noab
      DO p3b = noab+1,noab+nvab
      DO p4b = p3b,noab+nvab
      IF (int_mb(k_spin+h5b-1)+int_mb(k_spin+h6b-1) .eq. int_mb(k_spin+p
     &3b-1)+int_mb(k_spin+p4b-1)) THEN
      IF (ieor(int_mb(k_sym+h5b-1),ieor(int_mb(k_sym+h6b-1),ieor(int_mb(
     &k_sym+p3b-1),int_mb(k_sym+p4b-1)))) .eq. ieor(irrep_y,irrep_x)) TH
     &EN
      IF ((.not.restricted).or.(int_mb(k_spin+h5b-1)+int_mb(k_spin+h6b-1
     &)+int_mb(k_spin+p3b-1)+int_mb(k_spin+p4b-1).ne.8)) THEN
      addr = addr + 1
      int_mb(k_a_offset+addr) = p4b - noab - 1 + nvab * (p3b - noab - 1 
     &+ nvab * (h6b - 1 + noab * (h5b - 1)))
      int_mb(k_a_offset+length+addr) = size
      size = size + int_mb(k_range+h5b-1) * int_mb(k_range+h6b-1) * int_
     &mb(k_range+p3b-1) * int_mb(k_range+p4b-1)
      END IF
      END IF
      END IF
      END DO
      END DO
      END DO
      END DO
      RETURN
      END
      SUBROUTINE OFFSET_eomccsdt_density1_5_13_1_1(l_a_offset,k_a_offset
     &,size)
C     $Id$
C     This is a Fortran77 program generated by Tensor Contraction Engine v.1.0
C     Copyright (c) Battelle & Pacific Northwest National Laboratory (2002)
C     i3 ( h4 h5 p3 p6 )_yx
      IMPLICIT NONE
#include "global.fh"
#include "mafdecls.fh"
#include "sym.fh"
#include "errquit.fh"
#include "tce.fh"
      INTEGER l_a_offset
      INTEGER k_a_offset
      INTEGER size
      INTEGER length
      INTEGER addr
      INTEGER h4b
      INTEGER h5b
      INTEGER p3b
      INTEGER p6b
      length = 0
      DO h4b = 1,noab
      DO h5b = h4b,noab
      DO p3b = noab+1,noab+nvab
      DO p6b = p3b,noab+nvab
      IF (int_mb(k_spin+h4b-1)+int_mb(k_spin+h5b-1) .eq. int_mb(k_spin+p
     &3b-1)+int_mb(k_spin+p6b-1)) THEN
      IF (ieor(int_mb(k_sym+h4b-1),ieor(int_mb(k_sym+h5b-1),ieor(int_mb(
     &k_sym+p3b-1),int_mb(k_sym+p6b-1)))) .eq. ieor(irrep_y,irrep_x)) TH
     &EN
      IF ((.not.restricted).or.(int_mb(k_spin+h4b-1)+int_mb(k_spin+h5b-1
     &)+int_mb(k_spin+p3b-1)+int_mb(k_spin+p6b-1).ne.8)) THEN
      length = length + 1
      END IF
      END IF
      END IF
      END DO
      END DO
      END DO
      END DO
      IF (.not.MA_PUSH_GET(mt_int,2*length+1,'noname',l_a_offset,k_a_off
     &set)) CALL ERRQUIT('eomccsdt_density1_5_13_1_1',0,MA_ERR)
      int_mb(k_a_offset) = length
      addr = 0
      size = 0
      DO h4b = 1,noab
      DO h5b = h4b,noab
      DO p3b = noab+1,noab+nvab
      DO p6b = p3b,noab+nvab
      IF (int_mb(k_spin+h4b-1)+int_mb(k_spin+h5b-1) .eq. int_mb(k_spin+p
     &3b-1)+int_mb(k_spin+p6b-1)) THEN
      IF (ieor(int_mb(k_sym+h4b-1),ieor(int_mb(k_sym+h5b-1),ieor(int_mb(
     &k_sym+p3b-1),int_mb(k_sym+p6b-1)))) .eq. ieor(irrep_y,irrep_x)) TH
     &EN
      IF ((.not.restricted).or.(int_mb(k_spin+h4b-1)+int_mb(k_spin+h5b-1
     &)+int_mb(k_spin+p3b-1)+int_mb(k_spin+p6b-1).ne.8)) THEN
      addr = addr + 1
      int_mb(k_a_offset+addr) = p6b - noab - 1 + nvab * (p3b - noab - 1 
     &+ nvab * (h5b - 1 + noab * (h4b - 1)))
      int_mb(k_a_offset+length+addr) = size
      size = size + int_mb(k_range+h4b-1) * int_mb(k_range+h5b-1) * int_
     &mb(k_range+p3b-1) * int_mb(k_range+p6b-1)
      END IF
      END IF
      END IF
      END DO
      END DO
      END DO
      END DO
      RETURN
      END
      SUBROUTINE OFFSET_eomccsdt_density1_5_13_1(l_a_offset,k_a_offset,s
     &ize)
C     $Id$
C     This is a Fortran77 program generated by Tensor Contraction Engine v.1.0
C     Copyright (c) Battelle & Pacific Northwest National Laboratory (2002)
C     i2 ( p11 p6 )_yxt
      IMPLICIT NONE
#include "global.fh"
#include "mafdecls.fh"
#include "sym.fh"
#include "errquit.fh"
#include "tce.fh"
      INTEGER l_a_offset
      INTEGER k_a_offset
      INTEGER size
      INTEGER length
      INTEGER addr
      INTEGER p11b
      INTEGER p6b
      length = 0
      DO p11b = noab+1,noab+nvab
      DO p6b = noab+1,noab+nvab
      IF (int_mb(k_spin+p11b-1) .eq. int_mb(k_spin+p6b-1)) THEN
      IF (ieor(int_mb(k_sym+p11b-1),int_mb(k_sym+p6b-1)) .eq. ieor(irrep
     &_y,ieor(irrep_x,irrep_t))) THEN
      IF ((.not.restricted).or.(int_mb(k_spin+p11b-1)+int_mb(k_spin+p6b-
     &1).ne.4)) THEN
      length = length + 1
      END IF
      END IF
      END IF
      END DO
      END DO
      IF (.not.MA_PUSH_GET(mt_int,2*length+1,'noname',l_a_offset,k_a_off
     &set)) CALL ERRQUIT('eomccsdt_density1_5_13_1',0,MA_ERR)
      int_mb(k_a_offset) = length
      addr = 0
      size = 0
      DO p11b = noab+1,noab+nvab
      DO p6b = noab+1,noab+nvab
      IF (int_mb(k_spin+p11b-1) .eq. int_mb(k_spin+p6b-1)) THEN
      IF (ieor(int_mb(k_sym+p11b-1),int_mb(k_sym+p6b-1)) .eq. ieor(irrep
     &_y,ieor(irrep_x,irrep_t))) THEN
      IF ((.not.restricted).or.(int_mb(k_spin+p11b-1)+int_mb(k_spin+p6b-
     &1).ne.4)) THEN
      addr = addr + 1
      int_mb(k_a_offset+addr) = p6b - noab - 1 + nvab * (p11b - noab - 1
     &)
      int_mb(k_a_offset+length+addr) = size
      size = size + int_mb(k_range+p11b-1) * int_mb(k_range+p6b-1)
      END IF
      END IF
      END IF
      END DO
      END DO
      RETURN
      END
      SUBROUTINE OFFSET_eomccsdt_density1_5_1(l_a_offset,k_a_offset,size
     &)
C     $Id$
C     This is a Fortran77 program generated by Tensor Contraction Engine v.1.0
C     Copyright (c) Battelle & Pacific Northwest National Laboratory (2002)
C     i1 ( p11 h10 )_yx
      IMPLICIT NONE
#include "global.fh"
#include "mafdecls.fh"
#include "sym.fh"
#include "errquit.fh"
#include "tce.fh"
      INTEGER l_a_offset
      INTEGER k_a_offset
      INTEGER size
      INTEGER length
      INTEGER addr
      INTEGER p11b
      INTEGER h10b
      length = 0
      DO p11b = noab+1,noab+nvab
      DO h10b = 1,noab
      IF (int_mb(k_spin+p11b-1) .eq. int_mb(k_spin+h10b-1)) THEN
      IF (ieor(int_mb(k_sym+p11b-1),int_mb(k_sym+h10b-1)) .eq. ieor(irre
     &p_y,irrep_x)) THEN
      IF ((.not.restricted).or.(int_mb(k_spin+p11b-1)+int_mb(k_spin+h10b
     &-1).ne.4)) THEN
      length = length + 1
      END IF
      END IF
      END IF
      END DO
      END DO
      IF (.not.MA_PUSH_GET(mt_int,2*length+1,'noname',l_a_offset,k_a_off
     &set)) CALL ERRQUIT('eomccsdt_density1_5_1',0,MA_ERR)
      int_mb(k_a_offset) = length
      addr = 0
      size = 0
      DO p11b = noab+1,noab+nvab
      DO h10b = 1,noab
      IF (int_mb(k_spin+p11b-1) .eq. int_mb(k_spin+h10b-1)) THEN
      IF (ieor(int_mb(k_sym+p11b-1),int_mb(k_sym+h10b-1)) .eq. ieor(irre
     &p_y,irrep_x)) THEN
      IF ((.not.restricted).or.(int_mb(k_spin+p11b-1)+int_mb(k_spin+h10b
     &-1).ne.4)) THEN
      addr = addr + 1
      int_mb(k_a_offset+addr) = h10b - 1 + noab * (p11b - noab - 1)
      int_mb(k_a_offset+length+addr) = size
      size = size + int_mb(k_range+p11b-1) * int_mb(k_range+h10b-1)
      END IF
      END IF
      END IF
      END DO
      END DO
      RETURN
      END
      SUBROUTINE OFFSET_eomccsdt_density1_5_3_1(l_a_offset,k_a_offset,si
     &ze)
C     $Id$
C     This is a Fortran77 program generated by Tensor Contraction Engine v.1.0
C     Copyright (c) Battelle & Pacific Northwest National Laboratory (2002)
C     i2 ( h2 h10 )_yx
      IMPLICIT NONE
#include "global.fh"
#include "mafdecls.fh"
#include "sym.fh"
#include "errquit.fh"
#include "tce.fh"
      INTEGER l_a_offset
      INTEGER k_a_offset
      INTEGER size
      INTEGER length
      INTEGER addr
      INTEGER h2b
      INTEGER h10b
      length = 0
      DO h2b = 1,noab
      DO h10b = 1,noab
      IF (int_mb(k_spin+h2b-1) .eq. int_mb(k_spin+h10b-1)) THEN
      IF (ieor(int_mb(k_sym+h2b-1),int_mb(k_sym+h10b-1)) .eq. ieor(irrep
     &_y,irrep_x)) THEN
      IF ((.not.restricted).or.(int_mb(k_spin+h2b-1)+int_mb(k_spin+h10b-
     &1).ne.4)) THEN
      length = length + 1
      END IF
      END IF
      END IF
      END DO
      END DO
      IF (.not.MA_PUSH_GET(mt_int,2*length+1,'noname',l_a_offset,k_a_off
     &set)) CALL ERRQUIT('eomccsdt_density1_5_3_1',0,MA_ERR)
      int_mb(k_a_offset) = length
      addr = 0
      size = 0
      DO h2b = 1,noab
      DO h10b = 1,noab
      IF (int_mb(k_spin+h2b-1) .eq. int_mb(k_spin+h10b-1)) THEN
      IF (ieor(int_mb(k_sym+h2b-1),int_mb(k_sym+h10b-1)) .eq. ieor(irrep
     &_y,irrep_x)) THEN
      IF ((.not.restricted).or.(int_mb(k_spin+h2b-1)+int_mb(k_spin+h10b-
     &1).ne.4)) THEN
      addr = addr + 1
      int_mb(k_a_offset+addr) = h10b - 1 + noab * (h2b - 1)
      int_mb(k_a_offset+length+addr) = size
      size = size + int_mb(k_range+h2b-1) * int_mb(k_range+h10b-1)
      END IF
      END IF
      END IF
      END DO
      END DO
      RETURN
      END
      SUBROUTINE OFFSET_eomccsdt_density1_5_3_4_1(l_a_offset,k_a_offset,
     &size)
C     $Id$
C     This is a Fortran77 program generated by Tensor Contraction Engine v.1.0
C     Copyright (c) Battelle & Pacific Northwest National Laboratory (2002)
C     i3 ( h2 h10 )_yt
      IMPLICIT NONE
#include "global.fh"
#include "mafdecls.fh"
#include "sym.fh"
#include "errquit.fh"
#include "tce.fh"
      INTEGER l_a_offset
      INTEGER k_a_offset
      INTEGER size
      INTEGER length
      INTEGER addr
      INTEGER h2b
      INTEGER h10b
      length = 0
      DO h2b = 1,noab
      DO h10b = 1,noab
      IF (int_mb(k_spin+h2b-1) .eq. int_mb(k_spin+h10b-1)) THEN
      IF (ieor(int_mb(k_sym+h2b-1),int_mb(k_sym+h10b-1)) .eq. ieor(irrep
     &_y,irrep_t)) THEN
      IF ((.not.restricted).or.(int_mb(k_spin+h2b-1)+int_mb(k_spin+h10b-
     &1).ne.4)) THEN
      length = length + 1
      END IF
      END IF
      END IF
      END DO
      END DO
      IF (.not.MA_PUSH_GET(mt_int,2*length+1,'noname',l_a_offset,k_a_off
     &set)) CALL ERRQUIT('eomccsdt_density1_5_3_4_1',0,MA_ERR)
      int_mb(k_a_offset) = length
      addr = 0
      size = 0
      DO h2b = 1,noab
      DO h10b = 1,noab
      IF (int_mb(k_spin+h2b-1) .eq. int_mb(k_spin+h10b-1)) THEN
      IF (ieor(int_mb(k_sym+h2b-1),int_mb(k_sym+h10b-1)) .eq. ieor(irrep
     &_y,irrep_t)) THEN
      IF ((.not.restricted).or.(int_mb(k_spin+h2b-1)+int_mb(k_spin+h10b-
     &1).ne.4)) THEN
      addr = addr + 1
      int_mb(k_a_offset+addr) = h10b - 1 + noab * (h2b - 1)
      int_mb(k_a_offset+length+addr) = size
      size = size + int_mb(k_range+h2b-1) * int_mb(k_range+h10b-1)
      END IF
      END IF
      END IF
      END DO
      END DO
      RETURN
      END
      SUBROUTINE OFFSET_eomccsdt_density1_5_3_5_1(l_a_offset,k_a_offset,
     &size)
C     $Id$
C     This is a Fortran77 program generated by Tensor Contraction Engine v.1.0
C     Copyright (c) Battelle & Pacific Northwest National Laboratory (2002)
C     i3 ( h2 p3 )_yx
      IMPLICIT NONE
#include "global.fh"
#include "mafdecls.fh"
#include "sym.fh"
#include "errquit.fh"
#include "tce.fh"
      INTEGER l_a_offset
      INTEGER k_a_offset
      INTEGER size
      INTEGER length
      INTEGER addr
      INTEGER h2b
      INTEGER p3b
      length = 0
      DO h2b = 1,noab
      DO p3b = noab+1,noab+nvab
      IF (int_mb(k_spin+h2b-1) .eq. int_mb(k_spin+p3b-1)) THEN
      IF (ieor(int_mb(k_sym+h2b-1),int_mb(k_sym+p3b-1)) .eq. ieor(irrep_
     &y,irrep_x)) THEN
      IF ((.not.restricted).or.(int_mb(k_spin+h2b-1)+int_mb(k_spin+p3b-1
     &).ne.4)) THEN
      length = length + 1
      END IF
      END IF
      END IF
      END DO
      END DO
      IF (.not.MA_PUSH_GET(mt_int,2*length+1,'noname',l_a_offset,k_a_off
     &set)) CALL ERRQUIT('eomccsdt_density1_5_3_5_1',0,MA_ERR)
      int_mb(k_a_offset) = length
      addr = 0
      size = 0
      DO h2b = 1,noab
      DO p3b = noab+1,noab+nvab
      IF (int_mb(k_spin+h2b-1) .eq. int_mb(k_spin+p3b-1)) THEN
      IF (ieor(int_mb(k_sym+h2b-1),int_mb(k_sym+p3b-1)) .eq. ieor(irrep_
     &y,irrep_x)) THEN
      IF ((.not.restricted).or.(int_mb(k_spin+h2b-1)+int_mb(k_spin+p3b-1
     &).ne.4)) THEN
      addr = addr + 1
      int_mb(k_a_offset+addr) = p3b - noab - 1 + nvab * (h2b - 1)
      int_mb(k_a_offset+length+addr) = size
      size = size + int_mb(k_range+h2b-1) * int_mb(k_range+p3b-1)
      END IF
      END IF
      END IF
      END DO
      END DO
      RETURN
      END
      SUBROUTINE OFFSET_eomccsdt_density1_5_3_6_1(l_a_offset,k_a_offset,
     &size)
C     $Id$
C     This is a Fortran77 program generated by Tensor Contraction Engine v.1.0
C     Copyright (c) Battelle & Pacific Northwest National Laboratory (2002)
C     i3 ( h2 h5 p3 p4 )_yx
      IMPLICIT NONE
#include "global.fh"
#include "mafdecls.fh"
#include "sym.fh"
#include "errquit.fh"
#include "tce.fh"
      INTEGER l_a_offset
      INTEGER k_a_offset
      INTEGER size
      INTEGER length
      INTEGER addr
      INTEGER h2b
      INTEGER h5b
      INTEGER p3b
      INTEGER p4b
      length = 0
      DO h2b = 1,noab
      DO h5b = h2b,noab
      DO p3b = noab+1,noab+nvab
      DO p4b = p3b,noab+nvab
      IF (int_mb(k_spin+h2b-1)+int_mb(k_spin+h5b-1) .eq. int_mb(k_spin+p
     &3b-1)+int_mb(k_spin+p4b-1)) THEN
      IF (ieor(int_mb(k_sym+h2b-1),ieor(int_mb(k_sym+h5b-1),ieor(int_mb(
     &k_sym+p3b-1),int_mb(k_sym+p4b-1)))) .eq. ieor(irrep_y,irrep_x)) TH
     &EN
      IF ((.not.restricted).or.(int_mb(k_spin+h2b-1)+int_mb(k_spin+h5b-1
     &)+int_mb(k_spin+p3b-1)+int_mb(k_spin+p4b-1).ne.8)) THEN
      length = length + 1
      END IF
      END IF
      END IF
      END DO
      END DO
      END DO
      END DO
      IF (.not.MA_PUSH_GET(mt_int,2*length+1,'noname',l_a_offset,k_a_off
     &set)) CALL ERRQUIT('eomccsdt_density1_5_3_6_1',0,MA_ERR)
      int_mb(k_a_offset) = length
      addr = 0
      size = 0
      DO h2b = 1,noab
      DO h5b = h2b,noab
      DO p3b = noab+1,noab+nvab
      DO p4b = p3b,noab+nvab
      IF (int_mb(k_spin+h2b-1)+int_mb(k_spin+h5b-1) .eq. int_mb(k_spin+p
     &3b-1)+int_mb(k_spin+p4b-1)) THEN
      IF (ieor(int_mb(k_sym+h2b-1),ieor(int_mb(k_sym+h5b-1),ieor(int_mb(
     &k_sym+p3b-1),int_mb(k_sym+p4b-1)))) .eq. ieor(irrep_y,irrep_x)) TH
     &EN
      IF ((.not.restricted).or.(int_mb(k_spin+h2b-1)+int_mb(k_spin+h5b-1
     &)+int_mb(k_spin+p3b-1)+int_mb(k_spin+p4b-1).ne.8)) THEN
      addr = addr + 1
      int_mb(k_a_offset+addr) = p4b - noab - 1 + nvab * (p3b - noab - 1 
     &+ nvab * (h5b - 1 + noab * (h2b - 1)))
      int_mb(k_a_offset+length+addr) = size
      size = size + int_mb(k_range+h2b-1) * int_mb(k_range+h5b-1) * int_
     &mb(k_range+p3b-1) * int_mb(k_range+p4b-1)
      END IF
      END IF
      END IF
      END DO
      END DO
      END DO
      END DO
      RETURN
      END
      SUBROUTINE OFFSET_eomccsdt_density1_5_4_1(l_a_offset,k_a_offset,si
     &ze)
C     $Id$
C     This is a Fortran77 program generated by Tensor Contraction Engine v.1.0
C     Copyright (c) Battelle & Pacific Northwest National Laboratory (2002)
C     i2 ( h2 h10 )_yt
      IMPLICIT NONE
#include "global.fh"
#include "mafdecls.fh"
#include "sym.fh"
#include "errquit.fh"
#include "tce.fh"
      INTEGER l_a_offset
      INTEGER k_a_offset
      INTEGER size
      INTEGER length
      INTEGER addr
      INTEGER h2b
      INTEGER h10b
      length = 0
      DO h2b = 1,noab
      DO h10b = 1,noab
      IF (int_mb(k_spin+h2b-1) .eq. int_mb(k_spin+h10b-1)) THEN
      IF (ieor(int_mb(k_sym+h2b-1),int_mb(k_sym+h10b-1)) .eq. ieor(irrep
     &_y,irrep_t)) THEN
      IF ((.not.restricted).or.(int_mb(k_spin+h2b-1)+int_mb(k_spin+h10b-
     &1).ne.4)) THEN
      length = length + 1
      END IF
      END IF
      END IF
      END DO
      END DO
      IF (.not.MA_PUSH_GET(mt_int,2*length+1,'noname',l_a_offset,k_a_off
     &set)) CALL ERRQUIT('eomccsdt_density1_5_4_1',0,MA_ERR)
      int_mb(k_a_offset) = length
      addr = 0
      size = 0
      DO h2b = 1,noab
      DO h10b = 1,noab
      IF (int_mb(k_spin+h2b-1) .eq. int_mb(k_spin+h10b-1)) THEN
      IF (ieor(int_mb(k_sym+h2b-1),int_mb(k_sym+h10b-1)) .eq. ieor(irrep
     &_y,irrep_t)) THEN
      IF ((.not.restricted).or.(int_mb(k_spin+h2b-1)+int_mb(k_spin+h10b-
     &1).ne.4)) THEN
      addr = addr + 1
      int_mb(k_a_offset+addr) = h10b - 1 + noab * (h2b - 1)
      int_mb(k_a_offset+length+addr) = size
      size = size + int_mb(k_range+h2b-1) * int_mb(k_range+h10b-1)
      END IF
      END IF
      END IF
      END DO
      END DO
      RETURN
      END
      SUBROUTINE OFFSET_eomccsdt_density1_5_5_1(l_a_offset,k_a_offset,si
     &ze)
C     $Id$
C     This is a Fortran77 program generated by Tensor Contraction Engine v.1.0
C     Copyright (c) Battelle & Pacific Northwest National Laboratory (2002)
C     i2 ( )_yx
      IMPLICIT NONE
#include "global.fh"
#include "mafdecls.fh"
#include "sym.fh"
#include "errquit.fh"
#include "tce.fh"
      INTEGER l_a_offset
      INTEGER k_a_offset
      INTEGER size
      INTEGER length
      INTEGER addr
      length = 0
      IF (0 .eq. ieor(irrep_y,irrep_x)) THEN
      length = length + 1
      END IF
      IF (.not.MA_PUSH_GET(mt_int,2*length+1,'noname',l_a_offset,k_a_off
     &set)) CALL ERRQUIT('eomccsdt_density1_5_5_1',0,MA_ERR)
      int_mb(k_a_offset) = length
      addr = 0
      size = 0
      IF (0 .eq. ieor(irrep_y,irrep_x)) THEN
      addr = addr + 1
      int_mb(k_a_offset+addr) = 0
      int_mb(k_a_offset+length+addr) = size
      size = 1
      END IF
      RETURN
      END
      SUBROUTINE OFFSET_eomccsdt_density1_5_6_1(l_a_offset,k_a_offset,si
     &ze)
C     $Id$
C     This is a Fortran77 program generated by Tensor Contraction Engine v.1.0
C     Copyright (c) Battelle & Pacific Northwest National Laboratory (2002)
C     i2 ( h2 h7 h10 p1 )_yt
      IMPLICIT NONE
#include "global.fh"
#include "mafdecls.fh"
#include "sym.fh"
#include "errquit.fh"
#include "tce.fh"
      INTEGER l_a_offset
      INTEGER k_a_offset
      INTEGER size
      INTEGER length
      INTEGER addr
      INTEGER h2b
      INTEGER h7b
      INTEGER h10b
      INTEGER p1b
      length = 0
      DO h2b = 1,noab
      DO h7b = h2b,noab
      DO h10b = 1,noab
      DO p1b = noab+1,noab+nvab
      IF (int_mb(k_spin+h2b-1)+int_mb(k_spin+h7b-1) .eq. int_mb(k_spin+h
     &10b-1)+int_mb(k_spin+p1b-1)) THEN
      IF (ieor(int_mb(k_sym+h2b-1),ieor(int_mb(k_sym+h7b-1),ieor(int_mb(
     &k_sym+h10b-1),int_mb(k_sym+p1b-1)))) .eq. ieor(irrep_y,irrep_t)) T
     &HEN
      IF ((.not.restricted).or.(int_mb(k_spin+h2b-1)+int_mb(k_spin+h7b-1
     &)+int_mb(k_spin+h10b-1)+int_mb(k_spin+p1b-1).ne.8)) THEN
      length = length + 1
      END IF
      END IF
      END IF
      END DO
      END DO
      END DO
      END DO
      IF (.not.MA_PUSH_GET(mt_int,2*length+1,'noname',l_a_offset,k_a_off
     &set)) CALL ERRQUIT('eomccsdt_density1_5_6_1',0,MA_ERR)
      int_mb(k_a_offset) = length
      addr = 0
      size = 0
      DO h2b = 1,noab
      DO h7b = h2b,noab
      DO h10b = 1,noab
      DO p1b = noab+1,noab+nvab
      IF (int_mb(k_spin+h2b-1)+int_mb(k_spin+h7b-1) .eq. int_mb(k_spin+h
     &10b-1)+int_mb(k_spin+p1b-1)) THEN
      IF (ieor(int_mb(k_sym+h2b-1),ieor(int_mb(k_sym+h7b-1),ieor(int_mb(
     &k_sym+h10b-1),int_mb(k_sym+p1b-1)))) .eq. ieor(irrep_y,irrep_t)) T
     &HEN
      IF ((.not.restricted).or.(int_mb(k_spin+h2b-1)+int_mb(k_spin+h7b-1
     &)+int_mb(k_spin+h10b-1)+int_mb(k_spin+p1b-1).ne.8)) THEN
      addr = addr + 1
      int_mb(k_a_offset+addr) = p1b - noab - 1 + nvab * (h10b - 1 + noab
     & * (h7b - 1 + noab * (h2b - 1)))
      int_mb(k_a_offset+length+addr) = size
      size = size + int_mb(k_range+h2b-1) * int_mb(k_range+h7b-1) * int_
     &mb(k_range+h10b-1) * int_mb(k_range+p1b-1)
      END IF
      END IF
      END IF
      END DO
      END DO
      END DO
      END DO
      RETURN
      END
      SUBROUTINE OFFSET_eomccsdt_density1_5_7_1(l_a_offset,k_a_offset,si
     &ze)
C     $Id$
C     This is a Fortran77 program generated by Tensor Contraction Engine v.1.0
C     Copyright (c) Battelle & Pacific Northwest National Laboratory (2002)
C     i2 ( h6 h7 h8 h10 p4 p5 )_yt
      IMPLICIT NONE
#include "global.fh"
#include "mafdecls.fh"
#include "sym.fh"
#include "errquit.fh"
#include "tce.fh"
      INTEGER l_a_offset
      INTEGER k_a_offset
      INTEGER size
      INTEGER length
      INTEGER addr
      INTEGER h6b
      INTEGER h7b
      INTEGER h8b
      INTEGER h10b
      INTEGER p4b
      INTEGER p5b
      length = 0
      DO h6b = 1,noab
      DO h7b = h6b,noab
      DO h8b = h7b,noab
      DO h10b = 1,noab
      DO p4b = noab+1,noab+nvab
      DO p5b = p4b,noab+nvab
      IF (int_mb(k_spin+h6b-1)+int_mb(k_spin+h7b-1)+int_mb(k_spin+h8b-1)
     & .eq. int_mb(k_spin+h10b-1)+int_mb(k_spin+p4b-1)+int_mb(k_spin+p5b
     &-1)) THEN
      IF (ieor(int_mb(k_sym+h6b-1),ieor(int_mb(k_sym+h7b-1),ieor(int_mb(
     &k_sym+h8b-1),ieor(int_mb(k_sym+h10b-1),ieor(int_mb(k_sym+p4b-1),in
     &t_mb(k_sym+p5b-1)))))) .eq. ieor(irrep_y,irrep_t)) THEN
      IF ((.not.restricted).or.(int_mb(k_spin+h6b-1)+int_mb(k_spin+h7b-1
     &)+int_mb(k_spin+h8b-1)+int_mb(k_spin+h10b-1)+int_mb(k_spin+p4b-1)+
     &int_mb(k_spin+p5b-1).ne.12)) THEN
      length = length + 1
      END IF
      END IF
      END IF
      END DO
      END DO
      END DO
      END DO
      END DO
      END DO
      IF (.not.MA_PUSH_GET(mt_int,2*length+1,'noname',l_a_offset,k_a_off
     &set)) CALL ERRQUIT('eomccsdt_density1_5_7_1',0,MA_ERR)
      int_mb(k_a_offset) = length
      addr = 0
      size = 0
      DO h6b = 1,noab
      DO h7b = h6b,noab
      DO h8b = h7b,noab
      DO h10b = 1,noab
      DO p4b = noab+1,noab+nvab
      DO p5b = p4b,noab+nvab
      IF (int_mb(k_spin+h6b-1)+int_mb(k_spin+h7b-1)+int_mb(k_spin+h8b-1)
     & .eq. int_mb(k_spin+h10b-1)+int_mb(k_spin+p4b-1)+int_mb(k_spin+p5b
     &-1)) THEN
      IF (ieor(int_mb(k_sym+h6b-1),ieor(int_mb(k_sym+h7b-1),ieor(int_mb(
     &k_sym+h8b-1),ieor(int_mb(k_sym+h10b-1),ieor(int_mb(k_sym+p4b-1),in
     &t_mb(k_sym+p5b-1)))))) .eq. ieor(irrep_y,irrep_t)) THEN
      IF ((.not.restricted).or.(int_mb(k_spin+h6b-1)+int_mb(k_spin+h7b-1
     &)+int_mb(k_spin+h8b-1)+int_mb(k_spin+h10b-1)+int_mb(k_spin+p4b-1)+
     &int_mb(k_spin+p5b-1).ne.12)) THEN
      addr = addr + 1
      int_mb(k_a_offset+addr) = p5b - noab - 1 + nvab * (p4b - noab - 1 
     &+ nvab * (h10b - 1 + noab * (h8b - 1 + noab * (h7b - 1 + noab * (h
     &6b - 1)))))
      int_mb(k_a_offset+length+addr) = size
      size = size + int_mb(k_range+h6b-1) * int_mb(k_range+h7b-1) * int_
     &mb(k_range+h8b-1) * int_mb(k_range+h10b-1) * int_mb(k_range+p4b-1)
     & * int_mb(k_range+p5b-1)
      END IF
      END IF
      END IF
      END DO
      END DO
      END DO
      END DO
      END DO
      END DO
      RETURN
      END
      SUBROUTINE OFFSET_eomccsdt_density1_5_8_1(l_a_offset,k_a_offset,si
     &ze)
C     $Id$
C     This is a Fortran77 program generated by Tensor Contraction Engine v.1.0
C     Copyright (c) Battelle & Pacific Northwest National Laboratory (2002)
C     i2 ( h4 p3 )_yx
      IMPLICIT NONE
#include "global.fh"
#include "mafdecls.fh"
#include "sym.fh"
#include "errquit.fh"
#include "tce.fh"
      INTEGER l_a_offset
      INTEGER k_a_offset
      INTEGER size
      INTEGER length
      INTEGER addr
      INTEGER h4b
      INTEGER p3b
      length = 0
      DO h4b = 1,noab
      DO p3b = noab+1,noab+nvab
      IF (int_mb(k_spin+h4b-1) .eq. int_mb(k_spin+p3b-1)) THEN
      IF (ieor(int_mb(k_sym+h4b-1),int_mb(k_sym+p3b-1)) .eq. ieor(irrep_
     &y,irrep_x)) THEN
      IF ((.not.restricted).or.(int_mb(k_spin+h4b-1)+int_mb(k_spin+p3b-1
     &).ne.4)) THEN
      length = length + 1
      END IF
      END IF
      END IF
      END DO
      END DO
      IF (.not.MA_PUSH_GET(mt_int,2*length+1,'noname',l_a_offset,k_a_off
     &set)) CALL ERRQUIT('eomccsdt_density1_5_8_1',0,MA_ERR)
      int_mb(k_a_offset) = length
      addr = 0
      size = 0
      DO h4b = 1,noab
      DO p3b = noab+1,noab+nvab
      IF (int_mb(k_spin+h4b-1) .eq. int_mb(k_spin+p3b-1)) THEN
      IF (ieor(int_mb(k_sym+h4b-1),int_mb(k_sym+p3b-1)) .eq. ieor(irrep_
     &y,irrep_x)) THEN
      IF ((.not.restricted).or.(int_mb(k_spin+h4b-1)+int_mb(k_spin+p3b-1
     &).ne.4)) THEN
      addr = addr + 1
      int_mb(k_a_offset+addr) = p3b - noab - 1 + nvab * (h4b - 1)
      int_mb(k_a_offset+length+addr) = size
      size = size + int_mb(k_range+h4b-1) * int_mb(k_range+p3b-1)
      END IF
      END IF
      END IF
      END DO
      END DO
      RETURN
      END
      SUBROUTINE OFFSET_eomccsdt_density1_5_9_1(l_a_offset,k_a_offset,si
     &ze)
C     $Id$
C     This is a Fortran77 program generated by Tensor Contraction Engine v.1.0
C     Copyright (c) Battelle & Pacific Northwest National Laboratory (2002)
C     i2 ( h4 h5 h10 p3 )_yx
      IMPLICIT NONE
#include "global.fh"
#include "mafdecls.fh"
#include "sym.fh"
#include "errquit.fh"
#include "tce.fh"
      INTEGER l_a_offset
      INTEGER k_a_offset
      INTEGER size
      INTEGER length
      INTEGER addr
      INTEGER h4b
      INTEGER h5b
      INTEGER h10b
      INTEGER p3b
      length = 0
      DO h4b = 1,noab
      DO h5b = h4b,noab
      DO h10b = 1,noab
      DO p3b = noab+1,noab+nvab
      IF (int_mb(k_spin+h4b-1)+int_mb(k_spin+h5b-1) .eq. int_mb(k_spin+h
     &10b-1)+int_mb(k_spin+p3b-1)) THEN
      IF (ieor(int_mb(k_sym+h4b-1),ieor(int_mb(k_sym+h5b-1),ieor(int_mb(
     &k_sym+h10b-1),int_mb(k_sym+p3b-1)))) .eq. ieor(irrep_y,irrep_x)) T
     &HEN
      IF ((.not.restricted).or.(int_mb(k_spin+h4b-1)+int_mb(k_spin+h5b-1
     &)+int_mb(k_spin+h10b-1)+int_mb(k_spin+p3b-1).ne.8)) THEN
      length = length + 1
      END IF
      END IF
      END IF
      END DO
      END DO
      END DO
      END DO
      IF (.not.MA_PUSH_GET(mt_int,2*length+1,'noname',l_a_offset,k_a_off
     &set)) CALL ERRQUIT('eomccsdt_density1_5_9_1',0,MA_ERR)
      int_mb(k_a_offset) = length
      addr = 0
      size = 0
      DO h4b = 1,noab
      DO h5b = h4b,noab
      DO h10b = 1,noab
      DO p3b = noab+1,noab+nvab
      IF (int_mb(k_spin+h4b-1)+int_mb(k_spin+h5b-1) .eq. int_mb(k_spin+h
     &10b-1)+int_mb(k_spin+p3b-1)) THEN
      IF (ieor(int_mb(k_sym+h4b-1),ieor(int_mb(k_sym+h5b-1),ieor(int_mb(
     &k_sym+h10b-1),int_mb(k_sym+p3b-1)))) .eq. ieor(irrep_y,irrep_x)) T
     &HEN
      IF ((.not.restricted).or.(int_mb(k_spin+h4b-1)+int_mb(k_spin+h5b-1
     &)+int_mb(k_spin+h10b-1)+int_mb(k_spin+p3b-1).ne.8)) THEN
      addr = addr + 1
      int_mb(k_a_offset+addr) = p3b - noab - 1 + nvab * (h10b - 1 + noab
     & * (h5b - 1 + noab * (h4b - 1)))
      int_mb(k_a_offset+length+addr) = size
      size = size + int_mb(k_range+h4b-1) * int_mb(k_range+h5b-1) * int_
     &mb(k_range+h10b-1) * int_mb(k_range+p3b-1)
      END IF
      END IF
      END IF
      END DO
      END DO
      END DO
      END DO
      RETURN
      END
      SUBROUTINE OFFSET_eomccsdt_density1_6_1(l_a_offset,k_a_offset,size
     &)
C     $Id$
C     This is a Fortran77 program generated by Tensor Contraction Engine v.1.0
C     Copyright (c) Battelle & Pacific Northwest National Laboratory (2002)
C     i1 ( p2 p1 )_yx
      IMPLICIT NONE
#include "global.fh"
#include "mafdecls.fh"
#include "sym.fh"
#include "errquit.fh"
#include "tce.fh"
      INTEGER l_a_offset
      INTEGER k_a_offset
      INTEGER size
      INTEGER length
      INTEGER addr
      INTEGER p2b
      INTEGER p1b
      length = 0
      DO p2b = noab+1,noab+nvab
      DO p1b = noab+1,noab+nvab
      IF (int_mb(k_spin+p2b-1) .eq. int_mb(k_spin+p1b-1)) THEN
      IF (ieor(int_mb(k_sym+p2b-1),int_mb(k_sym+p1b-1)) .eq. ieor(irrep_
     &y,irrep_x)) THEN
      IF ((.not.restricted).or.(int_mb(k_spin+p2b-1)+int_mb(k_spin+p1b-1
     &).ne.4)) THEN
      length = length + 1
      END IF
      END IF
      END IF
      END DO
      END DO
      IF (.not.MA_PUSH_GET(mt_int,2*length+1,'noname',l_a_offset,k_a_off
     &set)) CALL ERRQUIT('eomccsdt_density1_6_1',0,MA_ERR)
      int_mb(k_a_offset) = length
      addr = 0
      size = 0
      DO p2b = noab+1,noab+nvab
      DO p1b = noab+1,noab+nvab
      IF (int_mb(k_spin+p2b-1) .eq. int_mb(k_spin+p1b-1)) THEN
      IF (ieor(int_mb(k_sym+p2b-1),int_mb(k_sym+p1b-1)) .eq. ieor(irrep_
     &y,irrep_x)) THEN
      IF ((.not.restricted).or.(int_mb(k_spin+p2b-1)+int_mb(k_spin+p1b-1
     &).ne.4)) THEN
      addr = addr + 1
      int_mb(k_a_offset+addr) = p1b - noab - 1 + nvab * (p2b - noab - 1)
      int_mb(k_a_offset+length+addr) = size
      size = size + int_mb(k_range+p2b-1) * int_mb(k_range+p1b-1)
      END IF
      END IF
      END IF
      END DO
      END DO
      RETURN
      END
      SUBROUTINE OFFSET_eomccsdt_density1_6_3_1(l_a_offset,k_a_offset,si
     &ze)
C     $Id$
C     This is a Fortran77 program generated by Tensor Contraction Engine v.1.0
C     Copyright (c) Battelle & Pacific Northwest National Laboratory (2002)
C     i2 ( h3 p1 )_yx
      IMPLICIT NONE
#include "global.fh"
#include "mafdecls.fh"
#include "sym.fh"
#include "errquit.fh"
#include "tce.fh"
      INTEGER l_a_offset
      INTEGER k_a_offset
      INTEGER size
      INTEGER length
      INTEGER addr
      INTEGER h3b
      INTEGER p1b
      length = 0
      DO h3b = 1,noab
      DO p1b = noab+1,noab+nvab
      IF (int_mb(k_spin+h3b-1) .eq. int_mb(k_spin+p1b-1)) THEN
      IF (ieor(int_mb(k_sym+h3b-1),int_mb(k_sym+p1b-1)) .eq. ieor(irrep_
     &y,irrep_x)) THEN
      IF ((.not.restricted).or.(int_mb(k_spin+h3b-1)+int_mb(k_spin+p1b-1
     &).ne.4)) THEN
      length = length + 1
      END IF
      END IF
      END IF
      END DO
      END DO
      IF (.not.MA_PUSH_GET(mt_int,2*length+1,'noname',l_a_offset,k_a_off
     &set)) CALL ERRQUIT('eomccsdt_density1_6_3_1',0,MA_ERR)
      int_mb(k_a_offset) = length
      addr = 0
      size = 0
      DO h3b = 1,noab
      DO p1b = noab+1,noab+nvab
      IF (int_mb(k_spin+h3b-1) .eq. int_mb(k_spin+p1b-1)) THEN
      IF (ieor(int_mb(k_sym+h3b-1),int_mb(k_sym+p1b-1)) .eq. ieor(irrep_
     &y,irrep_x)) THEN
      IF ((.not.restricted).or.(int_mb(k_spin+h3b-1)+int_mb(k_spin+p1b-1
     &).ne.4)) THEN
      addr = addr + 1
      int_mb(k_a_offset+addr) = p1b - noab - 1 + nvab * (h3b - 1)
      int_mb(k_a_offset+length+addr) = size
      size = size + int_mb(k_range+h3b-1) * int_mb(k_range+p1b-1)
      END IF
      END IF
      END IF
      END DO
      END DO
      RETURN
      END
      SUBROUTINE OFFSET_eomccsdt_density1_6_4_1(l_a_offset,k_a_offset,si
     &ze)
C     $Id$
C     This is a Fortran77 program generated by Tensor Contraction Engine v.1.0
C     Copyright (c) Battelle & Pacific Northwest National Laboratory (2002)
C     i2 ( p2 p1 )_yt
      IMPLICIT NONE
#include "global.fh"
#include "mafdecls.fh"
#include "sym.fh"
#include "errquit.fh"
#include "tce.fh"
      INTEGER l_a_offset
      INTEGER k_a_offset
      INTEGER size
      INTEGER length
      INTEGER addr
      INTEGER p2b
      INTEGER p1b
      length = 0
      DO p2b = noab+1,noab+nvab
      DO p1b = noab+1,noab+nvab
      IF (int_mb(k_spin+p2b-1) .eq. int_mb(k_spin+p1b-1)) THEN
      IF (ieor(int_mb(k_sym+p2b-1),int_mb(k_sym+p1b-1)) .eq. ieor(irrep_
     &y,irrep_t)) THEN
      IF ((.not.restricted).or.(int_mb(k_spin+p2b-1)+int_mb(k_spin+p1b-1
     &).ne.4)) THEN
      length = length + 1
      END IF
      END IF
      END IF
      END DO
      END DO
      IF (.not.MA_PUSH_GET(mt_int,2*length+1,'noname',l_a_offset,k_a_off
     &set)) CALL ERRQUIT('eomccsdt_density1_6_4_1',0,MA_ERR)
      int_mb(k_a_offset) = length
      addr = 0
      size = 0
      DO p2b = noab+1,noab+nvab
      DO p1b = noab+1,noab+nvab
      IF (int_mb(k_spin+p2b-1) .eq. int_mb(k_spin+p1b-1)) THEN
      IF (ieor(int_mb(k_sym+p2b-1),int_mb(k_sym+p1b-1)) .eq. ieor(irrep_
     &y,irrep_t)) THEN
      IF ((.not.restricted).or.(int_mb(k_spin+p2b-1)+int_mb(k_spin+p1b-1
     &).ne.4)) THEN
      addr = addr + 1
      int_mb(k_a_offset+addr) = p1b - noab - 1 + nvab * (p2b - noab - 1)
      int_mb(k_a_offset+length+addr) = size
      size = size + int_mb(k_range+p2b-1) * int_mb(k_range+p1b-1)
      END IF
      END IF
      END IF
      END DO
      END DO
      RETURN
      END
      SUBROUTINE OFFSET_eomccsdt_density1_6_5_1(l_a_offset,k_a_offset,si
     &ze)
C     $Id$
C     This is a Fortran77 program generated by Tensor Contraction Engine v.1.0
C     Copyright (c) Battelle & Pacific Northwest National Laboratory (2002)
C     i2 ( h4 h5 p1 p3 )_yx
      IMPLICIT NONE
#include "global.fh"
#include "mafdecls.fh"
#include "sym.fh"
#include "errquit.fh"
#include "tce.fh"
      INTEGER l_a_offset
      INTEGER k_a_offset
      INTEGER size
      INTEGER length
      INTEGER addr
      INTEGER h4b
      INTEGER h5b
      INTEGER p1b
      INTEGER p3b
      length = 0
      DO h4b = 1,noab
      DO h5b = h4b,noab
      DO p1b = noab+1,noab+nvab
      DO p3b = p1b,noab+nvab
      IF (int_mb(k_spin+h4b-1)+int_mb(k_spin+h5b-1) .eq. int_mb(k_spin+p
     &1b-1)+int_mb(k_spin+p3b-1)) THEN
      IF (ieor(int_mb(k_sym+h4b-1),ieor(int_mb(k_sym+h5b-1),ieor(int_mb(
     &k_sym+p1b-1),int_mb(k_sym+p3b-1)))) .eq. ieor(irrep_y,irrep_x)) TH
     &EN
      IF ((.not.restricted).or.(int_mb(k_spin+h4b-1)+int_mb(k_spin+h5b-1
     &)+int_mb(k_spin+p1b-1)+int_mb(k_spin+p3b-1).ne.8)) THEN
      length = length + 1
      END IF
      END IF
      END IF
      END DO
      END DO
      END DO
      END DO
      IF (.not.MA_PUSH_GET(mt_int,2*length+1,'noname',l_a_offset,k_a_off
     &set)) CALL ERRQUIT('eomccsdt_density1_6_5_1',0,MA_ERR)
      int_mb(k_a_offset) = length
      addr = 0
      size = 0
      DO h4b = 1,noab
      DO h5b = h4b,noab
      DO p1b = noab+1,noab+nvab
      DO p3b = p1b,noab+nvab
      IF (int_mb(k_spin+h4b-1)+int_mb(k_spin+h5b-1) .eq. int_mb(k_spin+p
     &1b-1)+int_mb(k_spin+p3b-1)) THEN
      IF (ieor(int_mb(k_sym+h4b-1),ieor(int_mb(k_sym+h5b-1),ieor(int_mb(
     &k_sym+p1b-1),int_mb(k_sym+p3b-1)))) .eq. ieor(irrep_y,irrep_x)) TH
     &EN
      IF ((.not.restricted).or.(int_mb(k_spin+h4b-1)+int_mb(k_spin+h5b-1
     &)+int_mb(k_spin+p1b-1)+int_mb(k_spin+p3b-1).ne.8)) THEN
      addr = addr + 1
      int_mb(k_a_offset+addr) = p3b - noab - 1 + nvab * (p1b - noab - 1 
     &+ nvab * (h5b - 1 + noab * (h4b - 1)))
      int_mb(k_a_offset+length+addr) = size
      size = size + int_mb(k_range+h4b-1) * int_mb(k_range+h5b-1) * int_
     &mb(k_range+p1b-1) * int_mb(k_range+p3b-1)
      END IF
      END IF
      END IF
      END DO
      END DO
      END DO
      END DO
      RETURN
      END
      SUBROUTINE OFFSET_eomccsdt_x2_11_10_1(l_a_offset,k_a_offset,size)
C     $Id$
C     This is a Fortran77 program generated by Tensor Contraction Engine v.1.0
C     Copyright (c) Battelle & Pacific Northwest National Laboratory (2002)
C     i2 ( h6 h9 h1 p5 )_vx
      IMPLICIT NONE
#include "global.fh"
#include "mafdecls.fh"
#include "sym.fh"
#include "errquit.fh"
#include "tce.fh"
      INTEGER l_a_offset
      INTEGER k_a_offset
      INTEGER size
      INTEGER length
      INTEGER addr
      INTEGER h6b
      INTEGER h9b
      INTEGER h1b
      INTEGER p5b
      length = 0
      DO h6b = 1,noab
      DO h9b = h6b,noab
      DO h1b = 1,noab
      DO p5b = noab+1,noab+nvab
      IF (int_mb(k_spin+h6b-1)+int_mb(k_spin+h9b-1) .eq. int_mb(k_spin+h
     &1b-1)+int_mb(k_spin+p5b-1)) THEN
      IF (ieor(int_mb(k_sym+h6b-1),ieor(int_mb(k_sym+h9b-1),ieor(int_mb(
     &k_sym+h1b-1),int_mb(k_sym+p5b-1)))) .eq. ieor(irrep_v,irrep_x)) TH
     &EN
      IF ((.not.restricted).or.(int_mb(k_spin+h6b-1)+int_mb(k_spin+h9b-1
     &)+int_mb(k_spin+h1b-1)+int_mb(k_spin+p5b-1).ne.8)) THEN
      length = length + 1
      END IF
      END IF
      END IF
      END DO
      END DO
      END DO
      END DO
      IF (.not.MA_PUSH_GET(mt_int,2*length+1,'noname',l_a_offset,k_a_off
     &set)) CALL ERRQUIT('eomccsdt_x2_11_10_1',0,MA_ERR)
      int_mb(k_a_offset) = length
      addr = 0
      size = 0
      DO h6b = 1,noab
      DO h9b = h6b,noab
      DO h1b = 1,noab
      DO p5b = noab+1,noab+nvab
      IF (int_mb(k_spin+h6b-1)+int_mb(k_spin+h9b-1) .eq. int_mb(k_spin+h
     &1b-1)+int_mb(k_spin+p5b-1)) THEN
      IF (ieor(int_mb(k_sym+h6b-1),ieor(int_mb(k_sym+h9b-1),ieor(int_mb(
     &k_sym+h1b-1),int_mb(k_sym+p5b-1)))) .eq. ieor(irrep_v,irrep_x)) TH
     &EN
      IF ((.not.restricted).or.(int_mb(k_spin+h6b-1)+int_mb(k_spin+h9b-1
     &)+int_mb(k_spin+h1b-1)+int_mb(k_spin+p5b-1).ne.8)) THEN
      addr = addr + 1
      int_mb(k_a_offset+addr) = p5b - noab - 1 + nvab * (h1b - 1 + noab 
     &* (h9b - 1 + noab * (h6b - 1)))
      int_mb(k_a_offset+length+addr) = size
      size = size + int_mb(k_range+h6b-1) * int_mb(k_range+h9b-1) * int_
     &mb(k_range+h1b-1) * int_mb(k_range+p5b-1)
      END IF
      END IF
      END IF
      END DO
      END DO
      END DO
      END DO
      RETURN
      END
      SUBROUTINE OFFSET_eomccsdt_x2_11_1_1(l_a_offset,k_a_offset,size)
C     $Id$
C     This is a Fortran77 program generated by Tensor Contraction Engine v.1.0
C     Copyright (c) Battelle & Pacific Northwest National Laboratory (2002)
C     i2 ( h9 h10 h1 h2 )_v
      IMPLICIT NONE
#include "global.fh"
#include "mafdecls.fh"
#include "sym.fh"
#include "errquit.fh"
#include "tce.fh"
      INTEGER l_a_offset
      INTEGER k_a_offset
      INTEGER size
      INTEGER length
      INTEGER addr
      INTEGER h9b
      INTEGER h10b
      INTEGER h1b
      INTEGER h2b
      length = 0
      DO h9b = 1,noab
      DO h10b = h9b,noab
      DO h1b = 1,noab
      DO h2b = h1b,noab
      IF (int_mb(k_spin+h9b-1)+int_mb(k_spin+h10b-1) .eq. int_mb(k_spin+
     &h1b-1)+int_mb(k_spin+h2b-1)) THEN
      IF (ieor(int_mb(k_sym+h9b-1),ieor(int_mb(k_sym+h10b-1),ieor(int_mb
     &(k_sym+h1b-1),int_mb(k_sym+h2b-1)))) .eq. irrep_v) THEN
      IF ((.not.restricted).or.(int_mb(k_spin+h9b-1)+int_mb(k_spin+h10b-
     &1)+int_mb(k_spin+h1b-1)+int_mb(k_spin+h2b-1).ne.8)) THEN
      length = length + 1
      END IF
      END IF
      END IF
      END DO
      END DO
      END DO
      END DO
      IF (.not.MA_PUSH_GET(mt_int,2*length+1,'noname',l_a_offset,k_a_off
     &set)) CALL ERRQUIT('eomccsdt_x2_11_1_1',0,MA_ERR)
      int_mb(k_a_offset) = length
      addr = 0
      size = 0
      DO h9b = 1,noab
      DO h10b = h9b,noab
      DO h1b = 1,noab
      DO h2b = h1b,noab
      IF (int_mb(k_spin+h9b-1)+int_mb(k_spin+h10b-1) .eq. int_mb(k_spin+
     &h1b-1)+int_mb(k_spin+h2b-1)) THEN
      IF (ieor(int_mb(k_sym+h9b-1),ieor(int_mb(k_sym+h10b-1),ieor(int_mb
     &(k_sym+h1b-1),int_mb(k_sym+h2b-1)))) .eq. irrep_v) THEN
      IF ((.not.restricted).or.(int_mb(k_spin+h9b-1)+int_mb(k_spin+h10b-
     &1)+int_mb(k_spin+h1b-1)+int_mb(k_spin+h2b-1).ne.8)) THEN
      addr = addr + 1
      int_mb(k_a_offset+addr) = h2b - 1 + noab * (h1b - 1 + noab * (h10b
     & - 1 + noab * (h9b - 1)))
      int_mb(k_a_offset+length+addr) = size
      size = size + int_mb(k_range+h9b-1) * int_mb(k_range+h10b-1) * int
     &_mb(k_range+h1b-1) * int_mb(k_range+h2b-1)
      END IF
      END IF
      END IF
      END DO
      END DO
      END DO
      END DO
      RETURN
      END
      SUBROUTINE OFFSET_eomccsdt_x2_11_1_2_1(l_a_offset,k_a_offset,size)
C     $Id$
C     This is a Fortran77 program generated by Tensor Contraction Engine v.1.0
C     Copyright (c) Battelle & Pacific Northwest National Laboratory (2002)
C     i3 ( h9 h10 h1 p6 )_v
      IMPLICIT NONE
#include "global.fh"
#include "mafdecls.fh"
#include "sym.fh"
#include "errquit.fh"
#include "tce.fh"
      INTEGER l_a_offset
      INTEGER k_a_offset
      INTEGER size
      INTEGER length
      INTEGER addr
      INTEGER h9b
      INTEGER h10b
      INTEGER h1b
      INTEGER p6b
      length = 0
      DO h9b = 1,noab
      DO h10b = h9b,noab
      DO h1b = 1,noab
      DO p6b = noab+1,noab+nvab
      IF (int_mb(k_spin+h9b-1)+int_mb(k_spin+h10b-1) .eq. int_mb(k_spin+
     &h1b-1)+int_mb(k_spin+p6b-1)) THEN
      IF (ieor(int_mb(k_sym+h9b-1),ieor(int_mb(k_sym+h10b-1),ieor(int_mb
     &(k_sym+h1b-1),int_mb(k_sym+p6b-1)))) .eq. irrep_v) THEN
      IF ((.not.restricted).or.(int_mb(k_spin+h9b-1)+int_mb(k_spin+h10b-
     &1)+int_mb(k_spin+h1b-1)+int_mb(k_spin+p6b-1).ne.8)) THEN
      length = length + 1
      END IF
      END IF
      END IF
      END DO
      END DO
      END DO
      END DO
      IF (.not.MA_PUSH_GET(mt_int,2*length+1,'noname',l_a_offset,k_a_off
     &set)) CALL ERRQUIT('eomccsdt_x2_11_1_2_1',0,MA_ERR)
      int_mb(k_a_offset) = length
      addr = 0
      size = 0
      DO h9b = 1,noab
      DO h10b = h9b,noab
      DO h1b = 1,noab
      DO p6b = noab+1,noab+nvab
      IF (int_mb(k_spin+h9b-1)+int_mb(k_spin+h10b-1) .eq. int_mb(k_spin+
     &h1b-1)+int_mb(k_spin+p6b-1)) THEN
      IF (ieor(int_mb(k_sym+h9b-1),ieor(int_mb(k_sym+h10b-1),ieor(int_mb
     &(k_sym+h1b-1),int_mb(k_sym+p6b-1)))) .eq. irrep_v) THEN
      IF ((.not.restricted).or.(int_mb(k_spin+h9b-1)+int_mb(k_spin+h10b-
     &1)+int_mb(k_spin+h1b-1)+int_mb(k_spin+p6b-1).ne.8)) THEN
      addr = addr + 1
      int_mb(k_a_offset+addr) = p6b - noab - 1 + nvab * (h1b - 1 + noab 
     &* (h10b - 1 + noab * (h9b - 1)))
      int_mb(k_a_offset+length+addr) = size
      size = size + int_mb(k_range+h9b-1) * int_mb(k_range+h10b-1) * int
     &_mb(k_range+h1b-1) * int_mb(k_range+p6b-1)
      END IF
      END IF
      END IF
      END DO
      END DO
      END DO
      END DO
      RETURN
      END
      SUBROUTINE OFFSET_eomccsdt_x2_11_1(l_a_offset,k_a_offset,size)
C     $Id$
C     This is a Fortran77 program generated by Tensor Contraction Engine v.1.0
C     Copyright (c) Battelle & Pacific Northwest National Laboratory (2002)
C     i1 ( h9 p3 h1 h2 )_vx
      IMPLICIT NONE
#include "global.fh"
#include "mafdecls.fh"
#include "sym.fh"
#include "errquit.fh"
#include "tce.fh"
      INTEGER l_a_offset
      INTEGER k_a_offset
      INTEGER size
      INTEGER length
      INTEGER addr
      INTEGER p3b
      INTEGER h9b
      INTEGER h1b
      INTEGER h2b
      length = 0
      DO p3b = noab+1,noab+nvab
      DO h9b = 1,noab
      DO h1b = 1,noab
      DO h2b = h1b,noab
      IF (int_mb(k_spin+h9b-1)+int_mb(k_spin+p3b-1) .eq. int_mb(k_spin+h
     &1b-1)+int_mb(k_spin+h2b-1)) THEN
      IF (ieor(int_mb(k_sym+h9b-1),ieor(int_mb(k_sym+p3b-1),ieor(int_mb(
     &k_sym+h1b-1),int_mb(k_sym+h2b-1)))) .eq. ieor(irrep_v,irrep_x)) TH
     &EN
      IF ((.not.restricted).or.(int_mb(k_spin+h9b-1)+int_mb(k_spin+p3b-1
     &)+int_mb(k_spin+h1b-1)+int_mb(k_spin+h2b-1).ne.8)) THEN
      length = length + 1
      END IF
      END IF
      END IF
      END DO
      END DO
      END DO
      END DO
      IF (.not.MA_PUSH_GET(mt_int,2*length+1,'noname',l_a_offset,k_a_off
     &set)) CALL ERRQUIT('eomccsdt_x2_11_1',0,MA_ERR)
      int_mb(k_a_offset) = length
      addr = 0
      size = 0
      DO p3b = noab+1,noab+nvab
      DO h9b = 1,noab
      DO h1b = 1,noab
      DO h2b = h1b,noab
      IF (int_mb(k_spin+h9b-1)+int_mb(k_spin+p3b-1) .eq. int_mb(k_spin+h
     &1b-1)+int_mb(k_spin+h2b-1)) THEN
      IF (ieor(int_mb(k_sym+h9b-1),ieor(int_mb(k_sym+p3b-1),ieor(int_mb(
     &k_sym+h1b-1),int_mb(k_sym+h2b-1)))) .eq. ieor(irrep_v,irrep_x)) TH
     &EN
      IF ((.not.restricted).or.(int_mb(k_spin+h9b-1)+int_mb(k_spin+p3b-1
     &)+int_mb(k_spin+h1b-1)+int_mb(k_spin+h2b-1).ne.8)) THEN
      addr = addr + 1
      int_mb(k_a_offset+addr) = h2b - 1 + noab * (h1b - 1 + noab * (h9b 
     &- 1 + noab * (p3b - noab - 1)))
      int_mb(k_a_offset+length+addr) = size
      size = size + int_mb(k_range+p3b-1) * int_mb(k_range+h9b-1) * int_
     &mb(k_range+h1b-1) * int_mb(k_range+h2b-1)
      END IF
      END IF
      END IF
      END DO
      END DO
      END DO
      END DO
      RETURN
      END
      SUBROUTINE OFFSET_eomccsdt_x2_11_3_1(l_a_offset,k_a_offset,size)
C     $Id$
C     This is a Fortran77 program generated by Tensor Contraction Engine v.1.0
C     Copyright (c) Battelle & Pacific Northwest National Laboratory (2002)
C     i2 ( h9 p5 )_f
      IMPLICIT NONE
#include "global.fh"
#include "mafdecls.fh"
#include "sym.fh"
#include "errquit.fh"
#include "tce.fh"
      INTEGER l_a_offset
      INTEGER k_a_offset
      INTEGER size
      INTEGER length
      INTEGER addr
      INTEGER h9b
      INTEGER p5b
      length = 0
      DO h9b = 1,noab
      DO p5b = noab+1,noab+nvab
      IF (int_mb(k_spin+h9b-1) .eq. int_mb(k_spin+p5b-1)) THEN
      IF (ieor(int_mb(k_sym+h9b-1),int_mb(k_sym+p5b-1)) .eq. irrep_f) TH
     &EN
      IF ((.not.restricted).or.(int_mb(k_spin+h9b-1)+int_mb(k_spin+p5b-1
     &).ne.4)) THEN
      length = length + 1
      END IF
      END IF
      END IF
      END DO
      END DO
      IF (.not.MA_PUSH_GET(mt_int,2*length+1,'noname',l_a_offset,k_a_off
     &set)) CALL ERRQUIT('eomccsdt_x2_11_3_1',0,MA_ERR)
      int_mb(k_a_offset) = length
      addr = 0
      size = 0
      DO h9b = 1,noab
      DO p5b = noab+1,noab+nvab
      IF (int_mb(k_spin+h9b-1) .eq. int_mb(k_spin+p5b-1)) THEN
      IF (ieor(int_mb(k_sym+h9b-1),int_mb(k_sym+p5b-1)) .eq. irrep_f) TH
     &EN
      IF ((.not.restricted).or.(int_mb(k_spin+h9b-1)+int_mb(k_spin+p5b-1
     &).ne.4)) THEN
      addr = addr + 1
      int_mb(k_a_offset+addr) = p5b - noab - 1 + nvab * (h9b - 1)
      int_mb(k_a_offset+length+addr) = size
      size = size + int_mb(k_range+h9b-1) * int_mb(k_range+p5b-1)
      END IF
      END IF
      END IF
      END DO
      END DO
      RETURN
      END
      SUBROUTINE OFFSET_eomccsdt_x2_11_4_1(l_a_offset,k_a_offset,size)
C     $Id$
C     This is a Fortran77 program generated by Tensor Contraction Engine v.1.0
C     Copyright (c) Battelle & Pacific Northwest National Laboratory (2002)
C     i2 ( h8 h9 h1 p5 )_v
      IMPLICIT NONE
#include "global.fh"
#include "mafdecls.fh"
#include "sym.fh"
#include "errquit.fh"
#include "tce.fh"
      INTEGER l_a_offset
      INTEGER k_a_offset
      INTEGER size
      INTEGER length
      INTEGER addr
      INTEGER h8b
      INTEGER h9b
      INTEGER h1b
      INTEGER p5b
      length = 0
      DO h8b = 1,noab
      DO h9b = h8b,noab
      DO h1b = 1,noab
      DO p5b = noab+1,noab+nvab
      IF (int_mb(k_spin+h8b-1)+int_mb(k_spin+h9b-1) .eq. int_mb(k_spin+h
     &1b-1)+int_mb(k_spin+p5b-1)) THEN
      IF (ieor(int_mb(k_sym+h8b-1),ieor(int_mb(k_sym+h9b-1),ieor(int_mb(
     &k_sym+h1b-1),int_mb(k_sym+p5b-1)))) .eq. irrep_v) THEN
      IF ((.not.restricted).or.(int_mb(k_spin+h8b-1)+int_mb(k_spin+h9b-1
     &)+int_mb(k_spin+h1b-1)+int_mb(k_spin+p5b-1).ne.8)) THEN
      length = length + 1
      END IF
      END IF
      END IF
      END DO
      END DO
      END DO
      END DO
      IF (.not.MA_PUSH_GET(mt_int,2*length+1,'noname',l_a_offset,k_a_off
     &set)) CALL ERRQUIT('eomccsdt_x2_11_4_1',0,MA_ERR)
      int_mb(k_a_offset) = length
      addr = 0
      size = 0
      DO h8b = 1,noab
      DO h9b = h8b,noab
      DO h1b = 1,noab
      DO p5b = noab+1,noab+nvab
      IF (int_mb(k_spin+h8b-1)+int_mb(k_spin+h9b-1) .eq. int_mb(k_spin+h
     &1b-1)+int_mb(k_spin+p5b-1)) THEN
      IF (ieor(int_mb(k_sym+h8b-1),ieor(int_mb(k_sym+h9b-1),ieor(int_mb(
     &k_sym+h1b-1),int_mb(k_sym+p5b-1)))) .eq. irrep_v) THEN
      IF ((.not.restricted).or.(int_mb(k_spin+h8b-1)+int_mb(k_spin+h9b-1
     &)+int_mb(k_spin+h1b-1)+int_mb(k_spin+p5b-1).ne.8)) THEN
      addr = addr + 1
      int_mb(k_a_offset+addr) = p5b - noab - 1 + nvab * (h1b - 1 + noab 
     &* (h9b - 1 + noab * (h8b - 1)))
      int_mb(k_a_offset+length+addr) = size
      size = size + int_mb(k_range+h8b-1) * int_mb(k_range+h9b-1) * int_
     &mb(k_range+h1b-1) * int_mb(k_range+p5b-1)
      END IF
      END IF
      END IF
      END DO
      END DO
      END DO
      END DO
      RETURN
      END
      SUBROUTINE OFFSET_eomccsdt_x2_11_7_1(l_a_offset,k_a_offset,size)
C     $Id$
C     This is a Fortran77 program generated by Tensor Contraction Engine v.1.0
C     Copyright (c) Battelle & Pacific Northwest National Laboratory (2002)
C     i2 ( h6 h9 h1 h2 )_vx
      IMPLICIT NONE
#include "global.fh"
#include "mafdecls.fh"
#include "sym.fh"
#include "errquit.fh"
#include "tce.fh"
      INTEGER l_a_offset
      INTEGER k_a_offset
      INTEGER size
      INTEGER length
      INTEGER addr
      INTEGER h6b
      INTEGER h9b
      INTEGER h1b
      INTEGER h2b
      length = 0
      DO h6b = 1,noab
      DO h9b = h6b,noab
      DO h1b = 1,noab
      DO h2b = h1b,noab
      IF (int_mb(k_spin+h6b-1)+int_mb(k_spin+h9b-1) .eq. int_mb(k_spin+h
     &1b-1)+int_mb(k_spin+h2b-1)) THEN
      IF (ieor(int_mb(k_sym+h6b-1),ieor(int_mb(k_sym+h9b-1),ieor(int_mb(
     &k_sym+h1b-1),int_mb(k_sym+h2b-1)))) .eq. ieor(irrep_v,irrep_x)) TH
     &EN
      IF ((.not.restricted).or.(int_mb(k_spin+h6b-1)+int_mb(k_spin+h9b-1
     &)+int_mb(k_spin+h1b-1)+int_mb(k_spin+h2b-1).ne.8)) THEN
      length = length + 1
      END IF
      END IF
      END IF
      END DO
      END DO
      END DO
      END DO
      IF (.not.MA_PUSH_GET(mt_int,2*length+1,'noname',l_a_offset,k_a_off
     &set)) CALL ERRQUIT('eomccsdt_x2_11_7_1',0,MA_ERR)
      int_mb(k_a_offset) = length
      addr = 0
      size = 0
      DO h6b = 1,noab
      DO h9b = h6b,noab
      DO h1b = 1,noab
      DO h2b = h1b,noab
      IF (int_mb(k_spin+h6b-1)+int_mb(k_spin+h9b-1) .eq. int_mb(k_spin+h
     &1b-1)+int_mb(k_spin+h2b-1)) THEN
      IF (ieor(int_mb(k_sym+h6b-1),ieor(int_mb(k_sym+h9b-1),ieor(int_mb(
     &k_sym+h1b-1),int_mb(k_sym+h2b-1)))) .eq. ieor(irrep_v,irrep_x)) TH
     &EN
      IF ((.not.restricted).or.(int_mb(k_spin+h6b-1)+int_mb(k_spin+h9b-1
     &)+int_mb(k_spin+h1b-1)+int_mb(k_spin+h2b-1).ne.8)) THEN
      addr = addr + 1
      int_mb(k_a_offset+addr) = h2b - 1 + noab * (h1b - 1 + noab * (h9b 
     &- 1 + noab * (h6b - 1)))
      int_mb(k_a_offset+length+addr) = size
      size = size + int_mb(k_range+h6b-1) * int_mb(k_range+h9b-1) * int_
     &mb(k_range+h1b-1) * int_mb(k_range+h2b-1)
      END IF
      END IF
      END IF
      END DO
      END DO
      END DO
      END DO
      RETURN
      END
      SUBROUTINE OFFSET_eomccsdt_x2_11_7_3_1(l_a_offset,k_a_offset,size)
C     $Id$
C     This is a Fortran77 program generated by Tensor Contraction Engine v.1.0
C     Copyright (c) Battelle & Pacific Northwest National Laboratory (2002)
C     i3 ( h6 h9 h1 p7 )_vx
      IMPLICIT NONE
#include "global.fh"
#include "mafdecls.fh"
#include "sym.fh"
#include "errquit.fh"
#include "tce.fh"
      INTEGER l_a_offset
      INTEGER k_a_offset
      INTEGER size
      INTEGER length
      INTEGER addr
      INTEGER h6b
      INTEGER h9b
      INTEGER h1b
      INTEGER p7b
      length = 0
      DO h6b = 1,noab
      DO h9b = h6b,noab
      DO h1b = 1,noab
      DO p7b = noab+1,noab+nvab
      IF (int_mb(k_spin+h6b-1)+int_mb(k_spin+h9b-1) .eq. int_mb(k_spin+h
     &1b-1)+int_mb(k_spin+p7b-1)) THEN
      IF (ieor(int_mb(k_sym+h6b-1),ieor(int_mb(k_sym+h9b-1),ieor(int_mb(
     &k_sym+h1b-1),int_mb(k_sym+p7b-1)))) .eq. ieor(irrep_v,irrep_x)) TH
     &EN
      IF ((.not.restricted).or.(int_mb(k_spin+h6b-1)+int_mb(k_spin+h9b-1
     &)+int_mb(k_spin+h1b-1)+int_mb(k_spin+p7b-1).ne.8)) THEN
      length = length + 1
      END IF
      END IF
      END IF
      END DO
      END DO
      END DO
      END DO
      IF (.not.MA_PUSH_GET(mt_int,2*length+1,'noname',l_a_offset,k_a_off
     &set)) CALL ERRQUIT('eomccsdt_x2_11_7_3_1',0,MA_ERR)
      int_mb(k_a_offset) = length
      addr = 0
      size = 0
      DO h6b = 1,noab
      DO h9b = h6b,noab
      DO h1b = 1,noab
      DO p7b = noab+1,noab+nvab
      IF (int_mb(k_spin+h6b-1)+int_mb(k_spin+h9b-1) .eq. int_mb(k_spin+h
     &1b-1)+int_mb(k_spin+p7b-1)) THEN
      IF (ieor(int_mb(k_sym+h6b-1),ieor(int_mb(k_sym+h9b-1),ieor(int_mb(
     &k_sym+h1b-1),int_mb(k_sym+p7b-1)))) .eq. ieor(irrep_v,irrep_x)) TH
     &EN
      IF ((.not.restricted).or.(int_mb(k_spin+h6b-1)+int_mb(k_spin+h9b-1
     &)+int_mb(k_spin+h1b-1)+int_mb(k_spin+p7b-1).ne.8)) THEN
      addr = addr + 1
      int_mb(k_a_offset+addr) = p7b - noab - 1 + nvab * (h1b - 1 + noab 
     &* (h9b - 1 + noab * (h6b - 1)))
      int_mb(k_a_offset+length+addr) = size
      size = size + int_mb(k_range+h6b-1) * int_mb(k_range+h9b-1) * int_
     &mb(k_range+h1b-1) * int_mb(k_range+p7b-1)
      END IF
      END IF
      END IF
      END DO
      END DO
      END DO
      END DO
      RETURN
      END
      SUBROUTINE OFFSET_eomccsdt_x2_11_8_1(l_a_offset,k_a_offset,size)
C     $Id$
C     This is a Fortran77 program generated by Tensor Contraction Engine v.1.0
C     Copyright (c) Battelle & Pacific Northwest National Laboratory (2002)
C     i2 ( h9 p3 h1 p6 )_vx
      IMPLICIT NONE
#include "global.fh"
#include "mafdecls.fh"
#include "sym.fh"
#include "errquit.fh"
#include "tce.fh"
      INTEGER l_a_offset
      INTEGER k_a_offset
      INTEGER size
      INTEGER length
      INTEGER addr
      INTEGER p3b
      INTEGER h9b
      INTEGER h1b
      INTEGER p6b
      length = 0
      DO p3b = noab+1,noab+nvab
      DO h9b = 1,noab
      DO h1b = 1,noab
      DO p6b = noab+1,noab+nvab
      IF (int_mb(k_spin+h9b-1)+int_mb(k_spin+p3b-1) .eq. int_mb(k_spin+h
     &1b-1)+int_mb(k_spin+p6b-1)) THEN
      IF (ieor(int_mb(k_sym+h9b-1),ieor(int_mb(k_sym+p3b-1),ieor(int_mb(
     &k_sym+h1b-1),int_mb(k_sym+p6b-1)))) .eq. ieor(irrep_v,irrep_x)) TH
     &EN
      IF ((.not.restricted).or.(int_mb(k_spin+h9b-1)+int_mb(k_spin+p3b-1
     &)+int_mb(k_spin+h1b-1)+int_mb(k_spin+p6b-1).ne.8)) THEN
      length = length + 1
      END IF
      END IF
      END IF
      END DO
      END DO
      END DO
      END DO
      IF (.not.MA_PUSH_GET(mt_int,2*length+1,'noname',l_a_offset,k_a_off
     &set)) CALL ERRQUIT('eomccsdt_x2_11_8_1',0,MA_ERR)
      int_mb(k_a_offset) = length
      addr = 0
      size = 0
      DO p3b = noab+1,noab+nvab
      DO h9b = 1,noab
      DO h1b = 1,noab
      DO p6b = noab+1,noab+nvab
      IF (int_mb(k_spin+h9b-1)+int_mb(k_spin+p3b-1) .eq. int_mb(k_spin+h
     &1b-1)+int_mb(k_spin+p6b-1)) THEN
      IF (ieor(int_mb(k_sym+h9b-1),ieor(int_mb(k_sym+p3b-1),ieor(int_mb(
     &k_sym+h1b-1),int_mb(k_sym+p6b-1)))) .eq. ieor(irrep_v,irrep_x)) TH
     &EN
      IF ((.not.restricted).or.(int_mb(k_spin+h9b-1)+int_mb(k_spin+p3b-1
     &)+int_mb(k_spin+h1b-1)+int_mb(k_spin+p6b-1).ne.8)) THEN
      addr = addr + 1
      int_mb(k_a_offset+addr) = p6b - noab - 1 + nvab * (h1b - 1 + noab 
     &* (h9b - 1 + noab * (p3b - noab - 1)))
      int_mb(k_a_offset+length+addr) = size
      size = size + int_mb(k_range+p3b-1) * int_mb(k_range+h9b-1) * int_
     &mb(k_range+h1b-1) * int_mb(k_range+p6b-1)
      END IF
      END IF
      END IF
      END DO
      END DO
      END DO
      END DO
      RETURN
      END
      SUBROUTINE OFFSET_eomccsdt_x2_11_9_1(l_a_offset,k_a_offset,size)
C     $Id$
C     This is a Fortran77 program generated by Tensor Contraction Engine v.1.0
C     Copyright (c) Battelle & Pacific Northwest National Laboratory (2002)
C     i2 ( h9 p5 )_vx
      IMPLICIT NONE
#include "global.fh"
#include "mafdecls.fh"
#include "sym.fh"
#include "errquit.fh"
#include "tce.fh"
      INTEGER l_a_offset
      INTEGER k_a_offset
      INTEGER size
      INTEGER length
      INTEGER addr
      INTEGER h9b
      INTEGER p5b
      length = 0
      DO h9b = 1,noab
      DO p5b = noab+1,noab+nvab
      IF (int_mb(k_spin+h9b-1) .eq. int_mb(k_spin+p5b-1)) THEN
      IF (ieor(int_mb(k_sym+h9b-1),int_mb(k_sym+p5b-1)) .eq. ieor(irrep_
     &v,irrep_x)) THEN
      IF ((.not.restricted).or.(int_mb(k_spin+h9b-1)+int_mb(k_spin+p5b-1
     &).ne.4)) THEN
      length = length + 1
      END IF
      END IF
      END IF
      END DO
      END DO
      IF (.not.MA_PUSH_GET(mt_int,2*length+1,'noname',l_a_offset,k_a_off
     &set)) CALL ERRQUIT('eomccsdt_x2_11_9_1',0,MA_ERR)
      int_mb(k_a_offset) = length
      addr = 0
      size = 0
      DO h9b = 1,noab
      DO p5b = noab+1,noab+nvab
      IF (int_mb(k_spin+h9b-1) .eq. int_mb(k_spin+p5b-1)) THEN
      IF (ieor(int_mb(k_sym+h9b-1),int_mb(k_sym+p5b-1)) .eq. ieor(irrep_
     &v,irrep_x)) THEN
      IF ((.not.restricted).or.(int_mb(k_spin+h9b-1)+int_mb(k_spin+p5b-1
     &).ne.4)) THEN
      addr = addr + 1
      int_mb(k_a_offset+addr) = p5b - noab - 1 + nvab * (h9b - 1)
      int_mb(k_a_offset+length+addr) = size
      size = size + int_mb(k_range+h9b-1) * int_mb(k_range+p5b-1)
      END IF
      END IF
      END IF
      END DO
      END DO
      RETURN
      END
      SUBROUTINE OFFSET_eomccsdt_x2_1_1(l_a_offset,k_a_offset,size)
C     $Id$
C     This is a Fortran77 program generated by Tensor Contraction Engine v.1.0
C     Copyright (c) Battelle & Pacific Northwest National Laboratory (2002)
C     i1 ( h9 p3 h1 h2 )_v
      IMPLICIT NONE
#include "global.fh"
#include "mafdecls.fh"
#include "sym.fh"
#include "errquit.fh"
#include "tce.fh"
      INTEGER l_a_offset
      INTEGER k_a_offset
      INTEGER size
      INTEGER length
      INTEGER addr
      INTEGER p3b
      INTEGER h9b
      INTEGER h1b
      INTEGER h2b
      length = 0
      DO p3b = noab+1,noab+nvab
      DO h9b = 1,noab
      DO h1b = 1,noab
      DO h2b = h1b,noab
      IF (int_mb(k_spin+h9b-1)+int_mb(k_spin+p3b-1) .eq. int_mb(k_spin+h
     &1b-1)+int_mb(k_spin+h2b-1)) THEN
      IF (ieor(int_mb(k_sym+h9b-1),ieor(int_mb(k_sym+p3b-1),ieor(int_mb(
     &k_sym+h1b-1),int_mb(k_sym+h2b-1)))) .eq. irrep_v) THEN
      IF ((.not.restricted).or.(int_mb(k_spin+h9b-1)+int_mb(k_spin+p3b-1
     &)+int_mb(k_spin+h1b-1)+int_mb(k_spin+h2b-1).ne.8)) THEN
      length = length + 1
      END IF
      END IF
      END IF
      END DO
      END DO
      END DO
      END DO
      IF (.not.MA_PUSH_GET(mt_int,2*length+1,'noname',l_a_offset,k_a_off
     &set)) CALL ERRQUIT('eomccsdt_x2_1_1',0,MA_ERR)
      int_mb(k_a_offset) = length
      addr = 0
      size = 0
      DO p3b = noab+1,noab+nvab
      DO h9b = 1,noab
      DO h1b = 1,noab
      DO h2b = h1b,noab
      IF (int_mb(k_spin+h9b-1)+int_mb(k_spin+p3b-1) .eq. int_mb(k_spin+h
     &1b-1)+int_mb(k_spin+h2b-1)) THEN
      IF (ieor(int_mb(k_sym+h9b-1),ieor(int_mb(k_sym+p3b-1),ieor(int_mb(
     &k_sym+h1b-1),int_mb(k_sym+h2b-1)))) .eq. irrep_v) THEN
      IF ((.not.restricted).or.(int_mb(k_spin+h9b-1)+int_mb(k_spin+p3b-1
     &)+int_mb(k_spin+h1b-1)+int_mb(k_spin+h2b-1).ne.8)) THEN
      addr = addr + 1
      int_mb(k_a_offset+addr) = h2b - 1 + noab * (h1b - 1 + noab * (h9b 
     &- 1 + noab * (p3b - noab - 1)))
      int_mb(k_a_offset+length+addr) = size
      size = size + int_mb(k_range+p3b-1) * int_mb(k_range+h9b-1) * int_
     &mb(k_range+h1b-1) * int_mb(k_range+h2b-1)
      END IF
      END IF
      END IF
      END DO
      END DO
      END DO
      END DO
      RETURN
      END
      SUBROUTINE OFFSET_eomccsdt_x2_1_2_1(l_a_offset,k_a_offset,size)
C     $Id$
C     This is a Fortran77 program generated by Tensor Contraction Engine v.1.0
C     Copyright (c) Battelle & Pacific Northwest National Laboratory (2002)
C     i2 ( h9 p3 h1 p5 )_v
      IMPLICIT NONE
#include "global.fh"
#include "mafdecls.fh"
#include "sym.fh"
#include "errquit.fh"
#include "tce.fh"
      INTEGER l_a_offset
      INTEGER k_a_offset
      INTEGER size
      INTEGER length
      INTEGER addr
      INTEGER p3b
      INTEGER h9b
      INTEGER h1b
      INTEGER p5b
      length = 0
      DO p3b = noab+1,noab+nvab
      DO h9b = 1,noab
      DO h1b = 1,noab
      DO p5b = noab+1,noab+nvab
      IF (int_mb(k_spin+h9b-1)+int_mb(k_spin+p3b-1) .eq. int_mb(k_spin+h
     &1b-1)+int_mb(k_spin+p5b-1)) THEN
      IF (ieor(int_mb(k_sym+h9b-1),ieor(int_mb(k_sym+p3b-1),ieor(int_mb(
     &k_sym+h1b-1),int_mb(k_sym+p5b-1)))) .eq. irrep_v) THEN
      IF ((.not.restricted).or.(int_mb(k_spin+h9b-1)+int_mb(k_spin+p3b-1
     &)+int_mb(k_spin+h1b-1)+int_mb(k_spin+p5b-1).ne.8)) THEN
      length = length + 1
      END IF
      END IF
      END IF
      END DO
      END DO
      END DO
      END DO
      IF (.not.MA_PUSH_GET(mt_int,2*length+1,'noname',l_a_offset,k_a_off
     &set)) CALL ERRQUIT('eomccsdt_x2_1_2_1',0,MA_ERR)
      int_mb(k_a_offset) = length
      addr = 0
      size = 0
      DO p3b = noab+1,noab+nvab
      DO h9b = 1,noab
      DO h1b = 1,noab
      DO p5b = noab+1,noab+nvab
      IF (int_mb(k_spin+h9b-1)+int_mb(k_spin+p3b-1) .eq. int_mb(k_spin+h
     &1b-1)+int_mb(k_spin+p5b-1)) THEN
      IF (ieor(int_mb(k_sym+h9b-1),ieor(int_mb(k_sym+p3b-1),ieor(int_mb(
     &k_sym+h1b-1),int_mb(k_sym+p5b-1)))) .eq. irrep_v) THEN
      IF ((.not.restricted).or.(int_mb(k_spin+h9b-1)+int_mb(k_spin+p3b-1
     &)+int_mb(k_spin+h1b-1)+int_mb(k_spin+p5b-1).ne.8)) THEN
      addr = addr + 1
      int_mb(k_a_offset+addr) = p5b - noab - 1 + nvab * (h1b - 1 + noab 
     &* (h9b - 1 + noab * (p3b - noab - 1)))
      int_mb(k_a_offset+length+addr) = size
      size = size + int_mb(k_range+p3b-1) * int_mb(k_range+h9b-1) * int_
     &mb(k_range+h1b-1) * int_mb(k_range+p5b-1)
      END IF
      END IF
      END IF
      END DO
      END DO
      END DO
      END DO
      RETURN
      END
      SUBROUTINE OFFSET_eomccsdt_x2_12_1(l_a_offset,k_a_offset,size)
C     $Id$
C     This is a Fortran77 program generated by Tensor Contraction Engine v.1.0
C     Copyright (c) Battelle & Pacific Northwest National Laboratory (2002)
C     i1 ( p3 p4 h1 p5 )_vx
      IMPLICIT NONE
#include "global.fh"
#include "mafdecls.fh"
#include "sym.fh"
#include "errquit.fh"
#include "tce.fh"
      INTEGER l_a_offset
      INTEGER k_a_offset
      INTEGER size
      INTEGER length
      INTEGER addr
      INTEGER p3b
      INTEGER p4b
      INTEGER h1b
      INTEGER p5b
      length = 0
      DO p3b = noab+1,noab+nvab
      DO p4b = p3b,noab+nvab
      DO h1b = 1,noab
      DO p5b = noab+1,noab+nvab
      IF (int_mb(k_spin+p3b-1)+int_mb(k_spin+p4b-1) .eq. int_mb(k_spin+h
     &1b-1)+int_mb(k_spin+p5b-1)) THEN
      IF (ieor(int_mb(k_sym+p3b-1),ieor(int_mb(k_sym+p4b-1),ieor(int_mb(
     &k_sym+h1b-1),int_mb(k_sym+p5b-1)))) .eq. ieor(irrep_v,irrep_x)) TH
     &EN
      IF ((.not.restricted).or.(int_mb(k_spin+p3b-1)+int_mb(k_spin+p4b-1
     &)+int_mb(k_spin+h1b-1)+int_mb(k_spin+p5b-1).ne.8)) THEN
      length = length + 1
      END IF
      END IF
      END IF
      END DO
      END DO
      END DO
      END DO
      IF (.not.MA_PUSH_GET(mt_int,2*length+1,'noname',l_a_offset,k_a_off
     &set)) CALL ERRQUIT('eomccsdt_x2_12_1',0,MA_ERR)
      int_mb(k_a_offset) = length
      addr = 0
      size = 0
      DO p3b = noab+1,noab+nvab
      DO p4b = p3b,noab+nvab
      DO h1b = 1,noab
      DO p5b = noab+1,noab+nvab
      IF (int_mb(k_spin+p3b-1)+int_mb(k_spin+p4b-1) .eq. int_mb(k_spin+h
     &1b-1)+int_mb(k_spin+p5b-1)) THEN
      IF (ieor(int_mb(k_sym+p3b-1),ieor(int_mb(k_sym+p4b-1),ieor(int_mb(
     &k_sym+h1b-1),int_mb(k_sym+p5b-1)))) .eq. ieor(irrep_v,irrep_x)) TH
     &EN
      IF ((.not.restricted).or.(int_mb(k_spin+p3b-1)+int_mb(k_spin+p4b-1
     &)+int_mb(k_spin+h1b-1)+int_mb(k_spin+p5b-1).ne.8)) THEN
      addr = addr + 1
      int_mb(k_a_offset+addr) = p5b - noab - 1 + nvab * (h1b - 1 + noab 
     &* (p4b - noab - 1 + nvab * (p3b - noab - 1)))
      int_mb(k_a_offset+length+addr) = size
      size = size + int_mb(k_range+p3b-1) * int_mb(k_range+p4b-1) * int_
     &mb(k_range+h1b-1) * int_mb(k_range+p5b-1)
      END IF
      END IF
      END IF
      END DO
      END DO
      END DO
      END DO
      RETURN
      END
      SUBROUTINE OFFSET_eomccsdt_x2_13_1_1(l_a_offset,k_a_offset,size)
C     $Id$
C     This is a Fortran77 program generated by Tensor Contraction Engine v.1.0
C     Copyright (c) Battelle & Pacific Northwest National Laboratory (2002)
C     i2 ( h5 p9 )_f
      IMPLICIT NONE
#include "global.fh"
#include "mafdecls.fh"
#include "sym.fh"
#include "errquit.fh"
#include "tce.fh"
      INTEGER l_a_offset
      INTEGER k_a_offset
      INTEGER size
      INTEGER length
      INTEGER addr
      INTEGER h5b
      INTEGER p9b
      length = 0
      DO h5b = 1,noab
      DO p9b = noab+1,noab+nvab
      IF (int_mb(k_spin+h5b-1) .eq. int_mb(k_spin+p9b-1)) THEN
      IF (ieor(int_mb(k_sym+h5b-1),int_mb(k_sym+p9b-1)) .eq. irrep_f) TH
     &EN
      IF ((.not.restricted).or.(int_mb(k_spin+h5b-1)+int_mb(k_spin+p9b-1
     &).ne.4)) THEN
      length = length + 1
      END IF
      END IF
      END IF
      END DO
      END DO
      IF (.not.MA_PUSH_GET(mt_int,2*length+1,'noname',l_a_offset,k_a_off
     &set)) CALL ERRQUIT('eomccsdt_x2_13_1_1',0,MA_ERR)
      int_mb(k_a_offset) = length
      addr = 0
      size = 0
      DO h5b = 1,noab
      DO p9b = noab+1,noab+nvab
      IF (int_mb(k_spin+h5b-1) .eq. int_mb(k_spin+p9b-1)) THEN
      IF (ieor(int_mb(k_sym+h5b-1),int_mb(k_sym+p9b-1)) .eq. irrep_f) TH
     &EN
      IF ((.not.restricted).or.(int_mb(k_spin+h5b-1)+int_mb(k_spin+p9b-1
     &).ne.4)) THEN
      addr = addr + 1
      int_mb(k_a_offset+addr) = p9b - noab - 1 + nvab * (h5b - 1)
      int_mb(k_a_offset+length+addr) = size
      size = size + int_mb(k_range+h5b-1) * int_mb(k_range+p9b-1)
      END IF
      END IF
      END IF
      END DO
      END DO
      RETURN
      END
      SUBROUTINE OFFSET_eomccsdt_x2_1_3_1(l_a_offset,k_a_offset,size)
C     $Id$
C     This is a Fortran77 program generated by Tensor Contraction Engine v.1.0
C     Copyright (c) Battelle & Pacific Northwest National Laboratory (2002)
C     i2 ( h9 p8 )_f
      IMPLICIT NONE
#include "global.fh"
#include "mafdecls.fh"
#include "sym.fh"
#include "errquit.fh"
#include "tce.fh"
      INTEGER l_a_offset
      INTEGER k_a_offset
      INTEGER size
      INTEGER length
      INTEGER addr
      INTEGER h9b
      INTEGER p8b
      length = 0
      DO h9b = 1,noab
      DO p8b = noab+1,noab+nvab
      IF (int_mb(k_spin+h9b-1) .eq. int_mb(k_spin+p8b-1)) THEN
      IF (ieor(int_mb(k_sym+h9b-1),int_mb(k_sym+p8b-1)) .eq. irrep_f) TH
     &EN
      IF ((.not.restricted).or.(int_mb(k_spin+h9b-1)+int_mb(k_spin+p8b-1
     &).ne.4)) THEN
      length = length + 1
      END IF
      END IF
      END IF
      END DO
      END DO
      IF (.not.MA_PUSH_GET(mt_int,2*length+1,'noname',l_a_offset,k_a_off
     &set)) CALL ERRQUIT('eomccsdt_x2_1_3_1',0,MA_ERR)
      int_mb(k_a_offset) = length
      addr = 0
      size = 0
      DO h9b = 1,noab
      DO p8b = noab+1,noab+nvab
      IF (int_mb(k_spin+h9b-1) .eq. int_mb(k_spin+p8b-1)) THEN
      IF (ieor(int_mb(k_sym+h9b-1),int_mb(k_sym+p8b-1)) .eq. irrep_f) TH
     &EN
      IF ((.not.restricted).or.(int_mb(k_spin+h9b-1)+int_mb(k_spin+p8b-1
     &).ne.4)) THEN
      addr = addr + 1
      int_mb(k_a_offset+addr) = p8b - noab - 1 + nvab * (h9b - 1)
      int_mb(k_a_offset+length+addr) = size
      size = size + int_mb(k_range+h9b-1) * int_mb(k_range+p8b-1)
      END IF
      END IF
      END IF
      END DO
      END DO
      RETURN
      END
      SUBROUTINE OFFSET_eomccsdt_x2_13_1(l_a_offset,k_a_offset,size)
C     $Id$
C     This is a Fortran77 program generated by Tensor Contraction Engine v.1.0
C     Copyright (c) Battelle & Pacific Northwest National Laboratory (2002)
C     i1 ( h5 h1 )_fx
      IMPLICIT NONE
#include "global.fh"
#include "mafdecls.fh"
#include "sym.fh"
#include "errquit.fh"
#include "tce.fh"
      INTEGER l_a_offset
      INTEGER k_a_offset
      INTEGER size
      INTEGER length
      INTEGER addr
      INTEGER h5b
      INTEGER h1b
      length = 0
      DO h5b = 1,noab
      DO h1b = 1,noab
      IF (int_mb(k_spin+h5b-1) .eq. int_mb(k_spin+h1b-1)) THEN
      IF (ieor(int_mb(k_sym+h5b-1),int_mb(k_sym+h1b-1)) .eq. ieor(irrep_
     &f,irrep_x)) THEN
      IF ((.not.restricted).or.(int_mb(k_spin+h5b-1)+int_mb(k_spin+h1b-1
     &).ne.4)) THEN
      length = length + 1
      END IF
      END IF
      END IF
      END DO
      END DO
      IF (.not.MA_PUSH_GET(mt_int,2*length+1,'noname',l_a_offset,k_a_off
     &set)) CALL ERRQUIT('eomccsdt_x2_13_1',0,MA_ERR)
      int_mb(k_a_offset) = length
      addr = 0
      size = 0
      DO h5b = 1,noab
      DO h1b = 1,noab
      IF (int_mb(k_spin+h5b-1) .eq. int_mb(k_spin+h1b-1)) THEN
      IF (ieor(int_mb(k_sym+h5b-1),int_mb(k_sym+h1b-1)) .eq. ieor(irrep_
     &f,irrep_x)) THEN
      IF ((.not.restricted).or.(int_mb(k_spin+h5b-1)+int_mb(k_spin+h1b-1
     &).ne.4)) THEN
      addr = addr + 1
      int_mb(k_a_offset+addr) = h1b - 1 + noab * (h5b - 1)
      int_mb(k_a_offset+length+addr) = size
      size = size + int_mb(k_range+h5b-1) * int_mb(k_range+h1b-1)
      END IF
      END IF
      END IF
      END DO
      END DO
      RETURN
      END
      SUBROUTINE OFFSET_eomccsdt_x2_13_4_1(l_a_offset,k_a_offset,size)
C     $Id$
C     This is a Fortran77 program generated by Tensor Contraction Engine v.1.0
C     Copyright (c) Battelle & Pacific Northwest National Laboratory (2002)
C     i2 ( h5 p6 )_vx
      IMPLICIT NONE
#include "global.fh"
#include "mafdecls.fh"
#include "sym.fh"
#include "errquit.fh"
#include "tce.fh"
      INTEGER l_a_offset
      INTEGER k_a_offset
      INTEGER size
      INTEGER length
      INTEGER addr
      INTEGER h5b
      INTEGER p6b
      length = 0
      DO h5b = 1,noab
      DO p6b = noab+1,noab+nvab
      IF (int_mb(k_spin+h5b-1) .eq. int_mb(k_spin+p6b-1)) THEN
      IF (ieor(int_mb(k_sym+h5b-1),int_mb(k_sym+p6b-1)) .eq. ieor(irrep_
     &v,irrep_x)) THEN
      IF ((.not.restricted).or.(int_mb(k_spin+h5b-1)+int_mb(k_spin+p6b-1
     &).ne.4)) THEN
      length = length + 1
      END IF
      END IF
      END IF
      END DO
      END DO
      IF (.not.MA_PUSH_GET(mt_int,2*length+1,'noname',l_a_offset,k_a_off
     &set)) CALL ERRQUIT('eomccsdt_x2_13_4_1',0,MA_ERR)
      int_mb(k_a_offset) = length
      addr = 0
      size = 0
      DO h5b = 1,noab
      DO p6b = noab+1,noab+nvab
      IF (int_mb(k_spin+h5b-1) .eq. int_mb(k_spin+p6b-1)) THEN
      IF (ieor(int_mb(k_sym+h5b-1),int_mb(k_sym+p6b-1)) .eq. ieor(irrep_
     &v,irrep_x)) THEN
      IF ((.not.restricted).or.(int_mb(k_spin+h5b-1)+int_mb(k_spin+p6b-1
     &).ne.4)) THEN
      addr = addr + 1
      int_mb(k_a_offset+addr) = p6b - noab - 1 + nvab * (h5b - 1)
      int_mb(k_a_offset+length+addr) = size
      size = size + int_mb(k_range+h5b-1) * int_mb(k_range+p6b-1)
      END IF
      END IF
      END IF
      END DO
      END DO
      RETURN
      END
      SUBROUTINE OFFSET_eomccsdt_x2_1_4_1(l_a_offset,k_a_offset,size)
C     $Id$
C     This is a Fortran77 program generated by Tensor Contraction Engine v.1.0
C     Copyright (c) Battelle & Pacific Northwest National Laboratory (2002)
C     i2 ( h6 h9 h1 p5 )_v
      IMPLICIT NONE
#include "global.fh"
#include "mafdecls.fh"
#include "sym.fh"
#include "errquit.fh"
#include "tce.fh"
      INTEGER l_a_offset
      INTEGER k_a_offset
      INTEGER size
      INTEGER length
      INTEGER addr
      INTEGER h6b
      INTEGER h9b
      INTEGER h1b
      INTEGER p5b
      length = 0
      DO h6b = 1,noab
      DO h9b = h6b,noab
      DO h1b = 1,noab
      DO p5b = noab+1,noab+nvab
      IF (int_mb(k_spin+h6b-1)+int_mb(k_spin+h9b-1) .eq. int_mb(k_spin+h
     &1b-1)+int_mb(k_spin+p5b-1)) THEN
      IF (ieor(int_mb(k_sym+h6b-1),ieor(int_mb(k_sym+h9b-1),ieor(int_mb(
     &k_sym+h1b-1),int_mb(k_sym+p5b-1)))) .eq. irrep_v) THEN
      IF ((.not.restricted).or.(int_mb(k_spin+h6b-1)+int_mb(k_spin+h9b-1
     &)+int_mb(k_spin+h1b-1)+int_mb(k_spin+p5b-1).ne.8)) THEN
      length = length + 1
      END IF
      END IF
      END IF
      END DO
      END DO
      END DO
      END DO
      IF (.not.MA_PUSH_GET(mt_int,2*length+1,'noname',l_a_offset,k_a_off
     &set)) CALL ERRQUIT('eomccsdt_x2_1_4_1',0,MA_ERR)
      int_mb(k_a_offset) = length
      addr = 0
      size = 0
      DO h6b = 1,noab
      DO h9b = h6b,noab
      DO h1b = 1,noab
      DO p5b = noab+1,noab+nvab
      IF (int_mb(k_spin+h6b-1)+int_mb(k_spin+h9b-1) .eq. int_mb(k_spin+h
     &1b-1)+int_mb(k_spin+p5b-1)) THEN
      IF (ieor(int_mb(k_sym+h6b-1),ieor(int_mb(k_sym+h9b-1),ieor(int_mb(
     &k_sym+h1b-1),int_mb(k_sym+p5b-1)))) .eq. irrep_v) THEN
      IF ((.not.restricted).or.(int_mb(k_spin+h6b-1)+int_mb(k_spin+h9b-1
     &)+int_mb(k_spin+h1b-1)+int_mb(k_spin+p5b-1).ne.8)) THEN
      addr = addr + 1
      int_mb(k_a_offset+addr) = p5b - noab - 1 + nvab * (h1b - 1 + noab 
     &* (h9b - 1 + noab * (h6b - 1)))
      int_mb(k_a_offset+length+addr) = size
      size = size + int_mb(k_range+h6b-1) * int_mb(k_range+h9b-1) * int_
     &mb(k_range+h1b-1) * int_mb(k_range+p5b-1)
      END IF
      END IF
      END IF
      END DO
      END DO
      END DO
      END DO
      RETURN
      END
      SUBROUTINE OFFSET_eomccsdt_x2_14_1(l_a_offset,k_a_offset,size)
C     $Id$
C     This is a Fortran77 program generated by Tensor Contraction Engine v.1.0
C     Copyright (c) Battelle & Pacific Northwest National Laboratory (2002)
C     i1 ( h5 h6 h1 h2 )_vx
      IMPLICIT NONE
#include "global.fh"
#include "mafdecls.fh"
#include "sym.fh"
#include "errquit.fh"
#include "tce.fh"
      INTEGER l_a_offset
      INTEGER k_a_offset
      INTEGER size
      INTEGER length
      INTEGER addr
      INTEGER h5b
      INTEGER h6b
      INTEGER h1b
      INTEGER h2b
      length = 0
      DO h5b = 1,noab
      DO h6b = h5b,noab
      DO h1b = 1,noab
      DO h2b = h1b,noab
      IF (int_mb(k_spin+h5b-1)+int_mb(k_spin+h6b-1) .eq. int_mb(k_spin+h
     &1b-1)+int_mb(k_spin+h2b-1)) THEN
      IF (ieor(int_mb(k_sym+h5b-1),ieor(int_mb(k_sym+h6b-1),ieor(int_mb(
     &k_sym+h1b-1),int_mb(k_sym+h2b-1)))) .eq. ieor(irrep_v,irrep_x)) TH
     &EN
      IF ((.not.restricted).or.(int_mb(k_spin+h5b-1)+int_mb(k_spin+h6b-1
     &)+int_mb(k_spin+h1b-1)+int_mb(k_spin+h2b-1).ne.8)) THEN
      length = length + 1
      END IF
      END IF
      END IF
      END DO
      END DO
      END DO
      END DO
      IF (.not.MA_PUSH_GET(mt_int,2*length+1,'noname',l_a_offset,k_a_off
     &set)) CALL ERRQUIT('eomccsdt_x2_14_1',0,MA_ERR)
      int_mb(k_a_offset) = length
      addr = 0
      size = 0
      DO h5b = 1,noab
      DO h6b = h5b,noab
      DO h1b = 1,noab
      DO h2b = h1b,noab
      IF (int_mb(k_spin+h5b-1)+int_mb(k_spin+h6b-1) .eq. int_mb(k_spin+h
     &1b-1)+int_mb(k_spin+h2b-1)) THEN
      IF (ieor(int_mb(k_sym+h5b-1),ieor(int_mb(k_sym+h6b-1),ieor(int_mb(
     &k_sym+h1b-1),int_mb(k_sym+h2b-1)))) .eq. ieor(irrep_v,irrep_x)) TH
     &EN
      IF ((.not.restricted).or.(int_mb(k_spin+h5b-1)+int_mb(k_spin+h6b-1
     &)+int_mb(k_spin+h1b-1)+int_mb(k_spin+h2b-1).ne.8)) THEN
      addr = addr + 1
      int_mb(k_a_offset+addr) = h2b - 1 + noab * (h1b - 1 + noab * (h6b 
     &- 1 + noab * (h5b - 1)))
      int_mb(k_a_offset+length+addr) = size
      size = size + int_mb(k_range+h5b-1) * int_mb(k_range+h6b-1) * int_
     &mb(k_range+h1b-1) * int_mb(k_range+h2b-1)
      END IF
      END IF
      END IF
      END DO
      END DO
      END DO
      END DO
      RETURN
      END
      SUBROUTINE OFFSET_eomccsdt_x2_14_3_1(l_a_offset,k_a_offset,size)
C     $Id$
C     This is a Fortran77 program generated by Tensor Contraction Engine v.1.0
C     Copyright (c) Battelle & Pacific Northwest National Laboratory (2002)
C     i2 ( h5 h6 h1 p7 )_vx
      IMPLICIT NONE
#include "global.fh"
#include "mafdecls.fh"
#include "sym.fh"
#include "errquit.fh"
#include "tce.fh"
      INTEGER l_a_offset
      INTEGER k_a_offset
      INTEGER size
      INTEGER length
      INTEGER addr
      INTEGER h5b
      INTEGER h6b
      INTEGER h1b
      INTEGER p7b
      length = 0
      DO h5b = 1,noab
      DO h6b = h5b,noab
      DO h1b = 1,noab
      DO p7b = noab+1,noab+nvab
      IF (int_mb(k_spin+h5b-1)+int_mb(k_spin+h6b-1) .eq. int_mb(k_spin+h
     &1b-1)+int_mb(k_spin+p7b-1)) THEN
      IF (ieor(int_mb(k_sym+h5b-1),ieor(int_mb(k_sym+h6b-1),ieor(int_mb(
     &k_sym+h1b-1),int_mb(k_sym+p7b-1)))) .eq. ieor(irrep_v,irrep_x)) TH
     &EN
      IF ((.not.restricted).or.(int_mb(k_spin+h5b-1)+int_mb(k_spin+h6b-1
     &)+int_mb(k_spin+h1b-1)+int_mb(k_spin+p7b-1).ne.8)) THEN
      length = length + 1
      END IF
      END IF
      END IF
      END DO
      END DO
      END DO
      END DO
      IF (.not.MA_PUSH_GET(mt_int,2*length+1,'noname',l_a_offset,k_a_off
     &set)) CALL ERRQUIT('eomccsdt_x2_14_3_1',0,MA_ERR)
      int_mb(k_a_offset) = length
      addr = 0
      size = 0
      DO h5b = 1,noab
      DO h6b = h5b,noab
      DO h1b = 1,noab
      DO p7b = noab+1,noab+nvab
      IF (int_mb(k_spin+h5b-1)+int_mb(k_spin+h6b-1) .eq. int_mb(k_spin+h
     &1b-1)+int_mb(k_spin+p7b-1)) THEN
      IF (ieor(int_mb(k_sym+h5b-1),ieor(int_mb(k_sym+h6b-1),ieor(int_mb(
     &k_sym+h1b-1),int_mb(k_sym+p7b-1)))) .eq. ieor(irrep_v,irrep_x)) TH
     &EN
      IF ((.not.restricted).or.(int_mb(k_spin+h5b-1)+int_mb(k_spin+h6b-1
     &)+int_mb(k_spin+h1b-1)+int_mb(k_spin+p7b-1).ne.8)) THEN
      addr = addr + 1
      int_mb(k_a_offset+addr) = p7b - noab - 1 + nvab * (h1b - 1 + noab 
     &* (h6b - 1 + noab * (h5b - 1)))
      int_mb(k_a_offset+length+addr) = size
      size = size + int_mb(k_range+h5b-1) * int_mb(k_range+h6b-1) * int_
     &mb(k_range+h1b-1) * int_mb(k_range+p7b-1)
      END IF
      END IF
      END IF
      END DO
      END DO
      END DO
      END DO
      RETURN
      END
      SUBROUTINE OFFSET_eomccsdt_x2_15_1(l_a_offset,k_a_offset,size)
C     $Id$
C     This is a Fortran77 program generated by Tensor Contraction Engine v.1.0
C     Copyright (c) Battelle & Pacific Northwest National Laboratory (2002)
C     i1 ( p3 p5 )_vx
      IMPLICIT NONE
#include "global.fh"
#include "mafdecls.fh"
#include "sym.fh"
#include "errquit.fh"
#include "tce.fh"
      INTEGER l_a_offset
      INTEGER k_a_offset
      INTEGER size
      INTEGER length
      INTEGER addr
      INTEGER p3b
      INTEGER p5b
      length = 0
      DO p3b = noab+1,noab+nvab
      DO p5b = noab+1,noab+nvab
      IF (int_mb(k_spin+p3b-1) .eq. int_mb(k_spin+p5b-1)) THEN
      IF (ieor(int_mb(k_sym+p3b-1),int_mb(k_sym+p5b-1)) .eq. ieor(irrep_
     &v,irrep_x)) THEN
      IF ((.not.restricted).or.(int_mb(k_spin+p3b-1)+int_mb(k_spin+p5b-1
     &).ne.4)) THEN
      length = length + 1
      END IF
      END IF
      END IF
      END DO
      END DO
      IF (.not.MA_PUSH_GET(mt_int,2*length+1,'noname',l_a_offset,k_a_off
     &set)) CALL ERRQUIT('eomccsdt_x2_15_1',0,MA_ERR)
      int_mb(k_a_offset) = length
      addr = 0
      size = 0
      DO p3b = noab+1,noab+nvab
      DO p5b = noab+1,noab+nvab
      IF (int_mb(k_spin+p3b-1) .eq. int_mb(k_spin+p5b-1)) THEN
      IF (ieor(int_mb(k_sym+p3b-1),int_mb(k_sym+p5b-1)) .eq. ieor(irrep_
     &v,irrep_x)) THEN
      IF ((.not.restricted).or.(int_mb(k_spin+p3b-1)+int_mb(k_spin+p5b-1
     &).ne.4)) THEN
      addr = addr + 1
      int_mb(k_a_offset+addr) = p5b - noab - 1 + nvab * (p3b - noab - 1)
      int_mb(k_a_offset+length+addr) = size
      size = size + int_mb(k_range+p3b-1) * int_mb(k_range+p5b-1)
      END IF
      END IF
      END IF
      END DO
      END DO
      RETURN
      END
      SUBROUTINE OFFSET_eomccsdt_x2_16_1(l_a_offset,k_a_offset,size)
C     $Id$
C     This is a Fortran77 program generated by Tensor Contraction Engine v.1.0
C     Copyright (c) Battelle & Pacific Northwest National Laboratory (2002)
C     i1 ( h6 p3 h1 p5 )_vx
      IMPLICIT NONE
#include "global.fh"
#include "mafdecls.fh"
#include "sym.fh"
#include "errquit.fh"
#include "tce.fh"
      INTEGER l_a_offset
      INTEGER k_a_offset
      INTEGER size
      INTEGER length
      INTEGER addr
      INTEGER p3b
      INTEGER h6b
      INTEGER h1b
      INTEGER p5b
      length = 0
      DO p3b = noab+1,noab+nvab
      DO h6b = 1,noab
      DO h1b = 1,noab
      DO p5b = noab+1,noab+nvab
      IF (int_mb(k_spin+h6b-1)+int_mb(k_spin+p3b-1) .eq. int_mb(k_spin+h
     &1b-1)+int_mb(k_spin+p5b-1)) THEN
      IF (ieor(int_mb(k_sym+h6b-1),ieor(int_mb(k_sym+p3b-1),ieor(int_mb(
     &k_sym+h1b-1),int_mb(k_sym+p5b-1)))) .eq. ieor(irrep_v,irrep_x)) TH
     &EN
      IF ((.not.restricted).or.(int_mb(k_spin+h6b-1)+int_mb(k_spin+p3b-1
     &)+int_mb(k_spin+h1b-1)+int_mb(k_spin+p5b-1).ne.8)) THEN
      length = length + 1
      END IF
      END IF
      END IF
      END DO
      END DO
      END DO
      END DO
      IF (.not.MA_PUSH_GET(mt_int,2*length+1,'noname',l_a_offset,k_a_off
     &set)) CALL ERRQUIT('eomccsdt_x2_16_1',0,MA_ERR)
      int_mb(k_a_offset) = length
      addr = 0
      size = 0
      DO p3b = noab+1,noab+nvab
      DO h6b = 1,noab
      DO h1b = 1,noab
      DO p5b = noab+1,noab+nvab
      IF (int_mb(k_spin+h6b-1)+int_mb(k_spin+p3b-1) .eq. int_mb(k_spin+h
     &1b-1)+int_mb(k_spin+p5b-1)) THEN
      IF (ieor(int_mb(k_sym+h6b-1),ieor(int_mb(k_sym+p3b-1),ieor(int_mb(
     &k_sym+h1b-1),int_mb(k_sym+p5b-1)))) .eq. ieor(irrep_v,irrep_x)) TH
     &EN
      IF ((.not.restricted).or.(int_mb(k_spin+h6b-1)+int_mb(k_spin+p3b-1
     &)+int_mb(k_spin+h1b-1)+int_mb(k_spin+p5b-1).ne.8)) THEN
      addr = addr + 1
      int_mb(k_a_offset+addr) = p5b - noab - 1 + nvab * (h1b - 1 + noab 
     &* (h6b - 1 + noab * (p3b - noab - 1)))
      int_mb(k_a_offset+length+addr) = size
      size = size + int_mb(k_range+p3b-1) * int_mb(k_range+h6b-1) * int_
     &mb(k_range+h1b-1) * int_mb(k_range+p5b-1)
      END IF
      END IF
      END IF
      END DO
      END DO
      END DO
      END DO
      RETURN
      END
      SUBROUTINE OFFSET_eomccsdt_x2_17_1(l_a_offset,k_a_offset,size)
C     $Id$
C     This is a Fortran77 program generated by Tensor Contraction Engine v.1.0
C     Copyright (c) Battelle & Pacific Northwest National Laboratory (2002)
C     i1 ( h6 p5 )_vx
      IMPLICIT NONE
#include "global.fh"
#include "mafdecls.fh"
#include "sym.fh"
#include "errquit.fh"
#include "tce.fh"
      INTEGER l_a_offset
      INTEGER k_a_offset
      INTEGER size
      INTEGER length
      INTEGER addr
      INTEGER h6b
      INTEGER p5b
      length = 0
      DO h6b = 1,noab
      DO p5b = noab+1,noab+nvab
      IF (int_mb(k_spin+h6b-1) .eq. int_mb(k_spin+p5b-1)) THEN
      IF (ieor(int_mb(k_sym+h6b-1),int_mb(k_sym+p5b-1)) .eq. ieor(irrep_
     &v,irrep_x)) THEN
      IF ((.not.restricted).or.(int_mb(k_spin+h6b-1)+int_mb(k_spin+p5b-1
     &).ne.4)) THEN
      length = length + 1
      END IF
      END IF
      END IF
      END DO
      END DO
      IF (.not.MA_PUSH_GET(mt_int,2*length+1,'noname',l_a_offset,k_a_off
     &set)) CALL ERRQUIT('eomccsdt_x2_17_1',0,MA_ERR)
      int_mb(k_a_offset) = length
      addr = 0
      size = 0
      DO h6b = 1,noab
      DO p5b = noab+1,noab+nvab
      IF (int_mb(k_spin+h6b-1) .eq. int_mb(k_spin+p5b-1)) THEN
      IF (ieor(int_mb(k_sym+h6b-1),int_mb(k_sym+p5b-1)) .eq. ieor(irrep_
     &v,irrep_x)) THEN
      IF ((.not.restricted).or.(int_mb(k_spin+h6b-1)+int_mb(k_spin+p5b-1
     &).ne.4)) THEN
      addr = addr + 1
      int_mb(k_a_offset+addr) = p5b - noab - 1 + nvab * (h6b - 1)
      int_mb(k_a_offset+length+addr) = size
      size = size + int_mb(k_range+h6b-1) * int_mb(k_range+p5b-1)
      END IF
      END IF
      END IF
      END DO
      END DO
      RETURN
      END
      SUBROUTINE OFFSET_eomccsdt_x2_18_1(l_a_offset,k_a_offset,size)
C     $Id$
C     This is a Fortran77 program generated by Tensor Contraction Engine v.1.0
C     Copyright (c) Battelle & Pacific Northwest National Laboratory (2002)
C     i1 ( h6 h7 h1 p5 )_vx
      IMPLICIT NONE
#include "global.fh"
#include "mafdecls.fh"
#include "sym.fh"
#include "errquit.fh"
#include "tce.fh"
      INTEGER l_a_offset
      INTEGER k_a_offset
      INTEGER size
      INTEGER length
      INTEGER addr
      INTEGER h6b
      INTEGER h7b
      INTEGER h1b
      INTEGER p5b
      length = 0
      DO h6b = 1,noab
      DO h7b = h6b,noab
      DO h1b = 1,noab
      DO p5b = noab+1,noab+nvab
      IF (int_mb(k_spin+h6b-1)+int_mb(k_spin+h7b-1) .eq. int_mb(k_spin+h
     &1b-1)+int_mb(k_spin+p5b-1)) THEN
      IF (ieor(int_mb(k_sym+h6b-1),ieor(int_mb(k_sym+h7b-1),ieor(int_mb(
     &k_sym+h1b-1),int_mb(k_sym+p5b-1)))) .eq. ieor(irrep_v,irrep_x)) TH
     &EN
      IF ((.not.restricted).or.(int_mb(k_spin+h6b-1)+int_mb(k_spin+h7b-1
     &)+int_mb(k_spin+h1b-1)+int_mb(k_spin+p5b-1).ne.8)) THEN
      length = length + 1
      END IF
      END IF
      END IF
      END DO
      END DO
      END DO
      END DO
      IF (.not.MA_PUSH_GET(mt_int,2*length+1,'noname',l_a_offset,k_a_off
     &set)) CALL ERRQUIT('eomccsdt_x2_18_1',0,MA_ERR)
      int_mb(k_a_offset) = length
      addr = 0
      size = 0
      DO h6b = 1,noab
      DO h7b = h6b,noab
      DO h1b = 1,noab
      DO p5b = noab+1,noab+nvab
      IF (int_mb(k_spin+h6b-1)+int_mb(k_spin+h7b-1) .eq. int_mb(k_spin+h
     &1b-1)+int_mb(k_spin+p5b-1)) THEN
      IF (ieor(int_mb(k_sym+h6b-1),ieor(int_mb(k_sym+h7b-1),ieor(int_mb(
     &k_sym+h1b-1),int_mb(k_sym+p5b-1)))) .eq. ieor(irrep_v,irrep_x)) TH
     &EN
      IF ((.not.restricted).or.(int_mb(k_spin+h6b-1)+int_mb(k_spin+h7b-1
     &)+int_mb(k_spin+h1b-1)+int_mb(k_spin+p5b-1).ne.8)) THEN
      addr = addr + 1
      int_mb(k_a_offset+addr) = p5b - noab - 1 + nvab * (h1b - 1 + noab 
     &* (h7b - 1 + noab * (h6b - 1)))
      int_mb(k_a_offset+length+addr) = size
      size = size + int_mb(k_range+h6b-1) * int_mb(k_range+h7b-1) * int_
     &mb(k_range+h1b-1) * int_mb(k_range+p5b-1)
      END IF
      END IF
      END IF
      END DO
      END DO
      END DO
      END DO
      RETURN
      END
      SUBROUTINE OFFSET_eomccsdt_x2_3_1(l_a_offset,k_a_offset,size)
C     $Id$
C     This is a Fortran77 program generated by Tensor Contraction Engine v.1.0
C     Copyright (c) Battelle & Pacific Northwest National Laboratory (2002)
C     i1 ( h8 h1 )_f
      IMPLICIT NONE
#include "global.fh"
#include "mafdecls.fh"
#include "sym.fh"
#include "errquit.fh"
#include "tce.fh"
      INTEGER l_a_offset
      INTEGER k_a_offset
      INTEGER size
      INTEGER length
      INTEGER addr
      INTEGER h8b
      INTEGER h1b
      length = 0
      DO h8b = 1,noab
      DO h1b = 1,noab
      IF (int_mb(k_spin+h8b-1) .eq. int_mb(k_spin+h1b-1)) THEN
      IF (ieor(int_mb(k_sym+h8b-1),int_mb(k_sym+h1b-1)) .eq. irrep_f) TH
     &EN
      IF ((.not.restricted).or.(int_mb(k_spin+h8b-1)+int_mb(k_spin+h1b-1
     &).ne.4)) THEN
      length = length + 1
      END IF
      END IF
      END IF
      END DO
      END DO
      IF (.not.MA_PUSH_GET(mt_int,2*length+1,'noname',l_a_offset,k_a_off
     &set)) CALL ERRQUIT('eomccsdt_x2_3_1',0,MA_ERR)
      int_mb(k_a_offset) = length
      addr = 0
      size = 0
      DO h8b = 1,noab
      DO h1b = 1,noab
      IF (int_mb(k_spin+h8b-1) .eq. int_mb(k_spin+h1b-1)) THEN
      IF (ieor(int_mb(k_sym+h8b-1),int_mb(k_sym+h1b-1)) .eq. irrep_f) TH
     &EN
      IF ((.not.restricted).or.(int_mb(k_spin+h8b-1)+int_mb(k_spin+h1b-1
     &).ne.4)) THEN
      addr = addr + 1
      int_mb(k_a_offset+addr) = h1b - 1 + noab * (h8b - 1)
      int_mb(k_a_offset+length+addr) = size
      size = size + int_mb(k_range+h8b-1) * int_mb(k_range+h1b-1)
      END IF
      END IF
      END IF
      END DO
      END DO
      RETURN
      END
      SUBROUTINE OFFSET_eomccsdt_x2_3_2_1(l_a_offset,k_a_offset,size)
C     $Id$
C     This is a Fortran77 program generated by Tensor Contraction Engine v.1.0
C     Copyright (c) Battelle & Pacific Northwest National Laboratory (2002)
C     i2 ( h8 p9 )_f
      IMPLICIT NONE
#include "global.fh"
#include "mafdecls.fh"
#include "sym.fh"
#include "errquit.fh"
#include "tce.fh"
      INTEGER l_a_offset
      INTEGER k_a_offset
      INTEGER size
      INTEGER length
      INTEGER addr
      INTEGER h8b
      INTEGER p9b
      length = 0
      DO h8b = 1,noab
      DO p9b = noab+1,noab+nvab
      IF (int_mb(k_spin+h8b-1) .eq. int_mb(k_spin+p9b-1)) THEN
      IF (ieor(int_mb(k_sym+h8b-1),int_mb(k_sym+p9b-1)) .eq. irrep_f) TH
     &EN
      IF ((.not.restricted).or.(int_mb(k_spin+h8b-1)+int_mb(k_spin+p9b-1
     &).ne.4)) THEN
      length = length + 1
      END IF
      END IF
      END IF
      END DO
      END DO
      IF (.not.MA_PUSH_GET(mt_int,2*length+1,'noname',l_a_offset,k_a_off
     &set)) CALL ERRQUIT('eomccsdt_x2_3_2_1',0,MA_ERR)
      int_mb(k_a_offset) = length
      addr = 0
      size = 0
      DO h8b = 1,noab
      DO p9b = noab+1,noab+nvab
      IF (int_mb(k_spin+h8b-1) .eq. int_mb(k_spin+p9b-1)) THEN
      IF (ieor(int_mb(k_sym+h8b-1),int_mb(k_sym+p9b-1)) .eq. irrep_f) TH
     &EN
      IF ((.not.restricted).or.(int_mb(k_spin+h8b-1)+int_mb(k_spin+p9b-1
     &).ne.4)) THEN
      addr = addr + 1
      int_mb(k_a_offset+addr) = p9b - noab - 1 + nvab * (h8b - 1)
      int_mb(k_a_offset+length+addr) = size
      size = size + int_mb(k_range+h8b-1) * int_mb(k_range+p9b-1)
      END IF
      END IF
      END IF
      END DO
      END DO
      RETURN
      END
      SUBROUTINE OFFSET_eomccsdt_x2_4_1(l_a_offset,k_a_offset,size)
C     $Id$
C     This is a Fortran77 program generated by Tensor Contraction Engine v.1.0
C     Copyright (c) Battelle & Pacific Northwest National Laboratory (2002)
C     i1 ( p3 p8 )_f
      IMPLICIT NONE
#include "global.fh"
#include "mafdecls.fh"
#include "sym.fh"
#include "errquit.fh"
#include "tce.fh"
      INTEGER l_a_offset
      INTEGER k_a_offset
      INTEGER size
      INTEGER length
      INTEGER addr
      INTEGER p3b
      INTEGER p8b
      length = 0
      DO p3b = noab+1,noab+nvab
      DO p8b = noab+1,noab+nvab
      IF (int_mb(k_spin+p3b-1) .eq. int_mb(k_spin+p8b-1)) THEN
      IF (ieor(int_mb(k_sym+p3b-1),int_mb(k_sym+p8b-1)) .eq. irrep_f) TH
     &EN
      IF ((.not.restricted).or.(int_mb(k_spin+p3b-1)+int_mb(k_spin+p8b-1
     &).ne.4)) THEN
      length = length + 1
      END IF
      END IF
      END IF
      END DO
      END DO
      IF (.not.MA_PUSH_GET(mt_int,2*length+1,'noname',l_a_offset,k_a_off
     &set)) CALL ERRQUIT('eomccsdt_x2_4_1',0,MA_ERR)
      int_mb(k_a_offset) = length
      addr = 0
      size = 0
      DO p3b = noab+1,noab+nvab
      DO p8b = noab+1,noab+nvab
      IF (int_mb(k_spin+p3b-1) .eq. int_mb(k_spin+p8b-1)) THEN
      IF (ieor(int_mb(k_sym+p3b-1),int_mb(k_sym+p8b-1)) .eq. irrep_f) TH
     &EN
      IF ((.not.restricted).or.(int_mb(k_spin+p3b-1)+int_mb(k_spin+p8b-1
     &).ne.4)) THEN
      addr = addr + 1
      int_mb(k_a_offset+addr) = p8b - noab - 1 + nvab * (p3b - noab - 1)
      int_mb(k_a_offset+length+addr) = size
      size = size + int_mb(k_range+p3b-1) * int_mb(k_range+p8b-1)
      END IF
      END IF
      END IF
      END DO
      END DO
      RETURN
      END
      SUBROUTINE OFFSET_eomccsdt_x2_5_1(l_a_offset,k_a_offset,size)
C     $Id$
C     This is a Fortran77 program generated by Tensor Contraction Engine v.1.0
C     Copyright (c) Battelle & Pacific Northwest National Laboratory (2002)
C     i1 ( h9 h10 h1 h2 )_v
      IMPLICIT NONE
#include "global.fh"
#include "mafdecls.fh"
#include "sym.fh"
#include "errquit.fh"
#include "tce.fh"
      INTEGER l_a_offset
      INTEGER k_a_offset
      INTEGER size
      INTEGER length
      INTEGER addr
      INTEGER h9b
      INTEGER h10b
      INTEGER h1b
      INTEGER h2b
      length = 0
      DO h9b = 1,noab
      DO h10b = h9b,noab
      DO h1b = 1,noab
      DO h2b = h1b,noab
      IF (int_mb(k_spin+h9b-1)+int_mb(k_spin+h10b-1) .eq. int_mb(k_spin+
     &h1b-1)+int_mb(k_spin+h2b-1)) THEN
      IF (ieor(int_mb(k_sym+h9b-1),ieor(int_mb(k_sym+h10b-1),ieor(int_mb
     &(k_sym+h1b-1),int_mb(k_sym+h2b-1)))) .eq. irrep_v) THEN
      IF ((.not.restricted).or.(int_mb(k_spin+h9b-1)+int_mb(k_spin+h10b-
     &1)+int_mb(k_spin+h1b-1)+int_mb(k_spin+h2b-1).ne.8)) THEN
      length = length + 1
      END IF
      END IF
      END IF
      END DO
      END DO
      END DO
      END DO
      IF (.not.MA_PUSH_GET(mt_int,2*length+1,'noname',l_a_offset,k_a_off
     &set)) CALL ERRQUIT('eomccsdt_x2_5_1',0,MA_ERR)
      int_mb(k_a_offset) = length
      addr = 0
      size = 0
      DO h9b = 1,noab
      DO h10b = h9b,noab
      DO h1b = 1,noab
      DO h2b = h1b,noab
      IF (int_mb(k_spin+h9b-1)+int_mb(k_spin+h10b-1) .eq. int_mb(k_spin+
     &h1b-1)+int_mb(k_spin+h2b-1)) THEN
      IF (ieor(int_mb(k_sym+h9b-1),ieor(int_mb(k_sym+h10b-1),ieor(int_mb
     &(k_sym+h1b-1),int_mb(k_sym+h2b-1)))) .eq. irrep_v) THEN
      IF ((.not.restricted).or.(int_mb(k_spin+h9b-1)+int_mb(k_spin+h10b-
     &1)+int_mb(k_spin+h1b-1)+int_mb(k_spin+h2b-1).ne.8)) THEN
      addr = addr + 1
      int_mb(k_a_offset+addr) = h2b - 1 + noab * (h1b - 1 + noab * (h10b
     & - 1 + noab * (h9b - 1)))
      int_mb(k_a_offset+length+addr) = size
      size = size + int_mb(k_range+h9b-1) * int_mb(k_range+h10b-1) * int
     &_mb(k_range+h1b-1) * int_mb(k_range+h2b-1)
      END IF
      END IF
      END IF
      END DO
      END DO
      END DO
      END DO
      RETURN
      END
      SUBROUTINE OFFSET_eomccsdt_x2_5_2_1(l_a_offset,k_a_offset,size)
C     $Id$
C     This is a Fortran77 program generated by Tensor Contraction Engine v.1.0
C     Copyright (c) Battelle & Pacific Northwest National Laboratory (2002)
C     i2 ( h9 h10 h1 p5 )_v
      IMPLICIT NONE
#include "global.fh"
#include "mafdecls.fh"
#include "sym.fh"
#include "errquit.fh"
#include "tce.fh"
      INTEGER l_a_offset
      INTEGER k_a_offset
      INTEGER size
      INTEGER length
      INTEGER addr
      INTEGER h9b
      INTEGER h10b
      INTEGER h1b
      INTEGER p5b
      length = 0
      DO h9b = 1,noab
      DO h10b = h9b,noab
      DO h1b = 1,noab
      DO p5b = noab+1,noab+nvab
      IF (int_mb(k_spin+h9b-1)+int_mb(k_spin+h10b-1) .eq. int_mb(k_spin+
     &h1b-1)+int_mb(k_spin+p5b-1)) THEN
      IF (ieor(int_mb(k_sym+h9b-1),ieor(int_mb(k_sym+h10b-1),ieor(int_mb
     &(k_sym+h1b-1),int_mb(k_sym+p5b-1)))) .eq. irrep_v) THEN
      IF ((.not.restricted).or.(int_mb(k_spin+h9b-1)+int_mb(k_spin+h10b-
     &1)+int_mb(k_spin+h1b-1)+int_mb(k_spin+p5b-1).ne.8)) THEN
      length = length + 1
      END IF
      END IF
      END IF
      END DO
      END DO
      END DO
      END DO
      IF (.not.MA_PUSH_GET(mt_int,2*length+1,'noname',l_a_offset,k_a_off
     &set)) CALL ERRQUIT('eomccsdt_x2_5_2_1',0,MA_ERR)
      int_mb(k_a_offset) = length
      addr = 0
      size = 0
      DO h9b = 1,noab
      DO h10b = h9b,noab
      DO h1b = 1,noab
      DO p5b = noab+1,noab+nvab
      IF (int_mb(k_spin+h9b-1)+int_mb(k_spin+h10b-1) .eq. int_mb(k_spin+
     &h1b-1)+int_mb(k_spin+p5b-1)) THEN
      IF (ieor(int_mb(k_sym+h9b-1),ieor(int_mb(k_sym+h10b-1),ieor(int_mb
     &(k_sym+h1b-1),int_mb(k_sym+p5b-1)))) .eq. irrep_v) THEN
      IF ((.not.restricted).or.(int_mb(k_spin+h9b-1)+int_mb(k_spin+h10b-
     &1)+int_mb(k_spin+h1b-1)+int_mb(k_spin+p5b-1).ne.8)) THEN
      addr = addr + 1
      int_mb(k_a_offset+addr) = p5b - noab - 1 + nvab * (h1b - 1 + noab 
     &* (h10b - 1 + noab * (h9b - 1)))
      int_mb(k_a_offset+length+addr) = size
      size = size + int_mb(k_range+h9b-1) * int_mb(k_range+h10b-1) * int
     &_mb(k_range+h1b-1) * int_mb(k_range+p5b-1)
      END IF
      END IF
      END IF
      END DO
      END DO
      END DO
      END DO
      RETURN
      END
      SUBROUTINE OFFSET_eomccsdt_x2_6_1(l_a_offset,k_a_offset,size)
C     $Id$
C     This is a Fortran77 program generated by Tensor Contraction Engine v.1.0
C     Copyright (c) Battelle & Pacific Northwest National Laboratory (2002)
C     i1 ( h7 p3 h1 p8 )_v
      IMPLICIT NONE
#include "global.fh"
#include "mafdecls.fh"
#include "sym.fh"
#include "errquit.fh"
#include "tce.fh"
      INTEGER l_a_offset
      INTEGER k_a_offset
      INTEGER size
      INTEGER length
      INTEGER addr
      INTEGER p3b
      INTEGER h7b
      INTEGER h1b
      INTEGER p8b
      length = 0
      DO p3b = noab+1,noab+nvab
      DO h7b = 1,noab
      DO h1b = 1,noab
      DO p8b = noab+1,noab+nvab
      IF (int_mb(k_spin+h7b-1)+int_mb(k_spin+p3b-1) .eq. int_mb(k_spin+h
     &1b-1)+int_mb(k_spin+p8b-1)) THEN
      IF (ieor(int_mb(k_sym+h7b-1),ieor(int_mb(k_sym+p3b-1),ieor(int_mb(
     &k_sym+h1b-1),int_mb(k_sym+p8b-1)))) .eq. irrep_v) THEN
      IF ((.not.restricted).or.(int_mb(k_spin+h7b-1)+int_mb(k_spin+p3b-1
     &)+int_mb(k_spin+h1b-1)+int_mb(k_spin+p8b-1).ne.8)) THEN
      length = length + 1
      END IF
      END IF
      END IF
      END DO
      END DO
      END DO
      END DO
      IF (.not.MA_PUSH_GET(mt_int,2*length+1,'noname',l_a_offset,k_a_off
     &set)) CALL ERRQUIT('eomccsdt_x2_6_1',0,MA_ERR)
      int_mb(k_a_offset) = length
      addr = 0
      size = 0
      DO p3b = noab+1,noab+nvab
      DO h7b = 1,noab
      DO h1b = 1,noab
      DO p8b = noab+1,noab+nvab
      IF (int_mb(k_spin+h7b-1)+int_mb(k_spin+p3b-1) .eq. int_mb(k_spin+h
     &1b-1)+int_mb(k_spin+p8b-1)) THEN
      IF (ieor(int_mb(k_sym+h7b-1),ieor(int_mb(k_sym+p3b-1),ieor(int_mb(
     &k_sym+h1b-1),int_mb(k_sym+p8b-1)))) .eq. irrep_v) THEN
      IF ((.not.restricted).or.(int_mb(k_spin+h7b-1)+int_mb(k_spin+p3b-1
     &)+int_mb(k_spin+h1b-1)+int_mb(k_spin+p8b-1).ne.8)) THEN
      addr = addr + 1
      int_mb(k_a_offset+addr) = p8b - noab - 1 + nvab * (h1b - 1 + noab 
     &* (h7b - 1 + noab * (p3b - noab - 1)))
      int_mb(k_a_offset+length+addr) = size
      size = size + int_mb(k_range+p3b-1) * int_mb(k_range+h7b-1) * int_
     &mb(k_range+h1b-1) * int_mb(k_range+p8b-1)
      END IF
      END IF
      END IF
      END DO
      END DO
      END DO
      END DO
      RETURN
      END
      SUBROUTINE OFFSET_eomccsdt_x2_8_1(l_a_offset,k_a_offset,size)
C     $Id$
C     This is a Fortran77 program generated by Tensor Contraction Engine v.1.0
C     Copyright (c) Battelle & Pacific Northwest National Laboratory (2002)
C     i1 ( h8 p9 )_f
      IMPLICIT NONE
#include "global.fh"
#include "mafdecls.fh"
#include "sym.fh"
#include "errquit.fh"
#include "tce.fh"
      INTEGER l_a_offset
      INTEGER k_a_offset
      INTEGER size
      INTEGER length
      INTEGER addr
      INTEGER h8b
      INTEGER p9b
      length = 0
      DO h8b = 1,noab
      DO p9b = noab+1,noab+nvab
      IF (int_mb(k_spin+h8b-1) .eq. int_mb(k_spin+p9b-1)) THEN
      IF (ieor(int_mb(k_sym+h8b-1),int_mb(k_sym+p9b-1)) .eq. irrep_f) TH
     &EN
      IF ((.not.restricted).or.(int_mb(k_spin+h8b-1)+int_mb(k_spin+p9b-1
     &).ne.4)) THEN
      length = length + 1
      END IF
      END IF
      END IF
      END DO
      END DO
      IF (.not.MA_PUSH_GET(mt_int,2*length+1,'noname',l_a_offset,k_a_off
     &set)) CALL ERRQUIT('eomccsdt_x2_8_1',0,MA_ERR)
      int_mb(k_a_offset) = length
      addr = 0
      size = 0
      DO h8b = 1,noab
      DO p9b = noab+1,noab+nvab
      IF (int_mb(k_spin+h8b-1) .eq. int_mb(k_spin+p9b-1)) THEN
      IF (ieor(int_mb(k_sym+h8b-1),int_mb(k_sym+p9b-1)) .eq. irrep_f) TH
     &EN
      IF ((.not.restricted).or.(int_mb(k_spin+h8b-1)+int_mb(k_spin+p9b-1
     &).ne.4)) THEN
      addr = addr + 1
      int_mb(k_a_offset+addr) = p9b - noab - 1 + nvab * (h8b - 1)
      int_mb(k_a_offset+length+addr) = size
      size = size + int_mb(k_range+h8b-1) * int_mb(k_range+p9b-1)
      END IF
      END IF
      END IF
      END DO
      END DO
      RETURN
      END
      SUBROUTINE OFFSET_eomccsdt_x2_9_1(l_a_offset,k_a_offset,size)
C     $Id$
C     This is a Fortran77 program generated by Tensor Contraction Engine v.1.0
C     Copyright (c) Battelle & Pacific Northwest National Laboratory (2002)
C     i1 ( h8 h10 h1 p9 )_v
      IMPLICIT NONE
#include "global.fh"
#include "mafdecls.fh"
#include "sym.fh"
#include "errquit.fh"
#include "tce.fh"
      INTEGER l_a_offset
      INTEGER k_a_offset
      INTEGER size
      INTEGER length
      INTEGER addr
      INTEGER h8b
      INTEGER h10b
      INTEGER h1b
      INTEGER p9b
      length = 0
      DO h8b = 1,noab
      DO h10b = h8b,noab
      DO h1b = 1,noab
      DO p9b = noab+1,noab+nvab
      IF (int_mb(k_spin+h8b-1)+int_mb(k_spin+h10b-1) .eq. int_mb(k_spin+
     &h1b-1)+int_mb(k_spin+p9b-1)) THEN
      IF (ieor(int_mb(k_sym+h8b-1),ieor(int_mb(k_sym+h10b-1),ieor(int_mb
     &(k_sym+h1b-1),int_mb(k_sym+p9b-1)))) .eq. irrep_v) THEN
      IF ((.not.restricted).or.(int_mb(k_spin+h8b-1)+int_mb(k_spin+h10b-
     &1)+int_mb(k_spin+h1b-1)+int_mb(k_spin+p9b-1).ne.8)) THEN
      length = length + 1
      END IF
      END IF
      END IF
      END DO
      END DO
      END DO
      END DO
      IF (.not.MA_PUSH_GET(mt_int,2*length+1,'noname',l_a_offset,k_a_off
     &set)) CALL ERRQUIT('eomccsdt_x2_9_1',0,MA_ERR)
      int_mb(k_a_offset) = length
      addr = 0
      size = 0
      DO h8b = 1,noab
      DO h10b = h8b,noab
      DO h1b = 1,noab
      DO p9b = noab+1,noab+nvab
      IF (int_mb(k_spin+h8b-1)+int_mb(k_spin+h10b-1) .eq. int_mb(k_spin+
     &h1b-1)+int_mb(k_spin+p9b-1)) THEN
      IF (ieor(int_mb(k_sym+h8b-1),ieor(int_mb(k_sym+h10b-1),ieor(int_mb
     &(k_sym+h1b-1),int_mb(k_sym+p9b-1)))) .eq. irrep_v) THEN
      IF ((.not.restricted).or.(int_mb(k_spin+h8b-1)+int_mb(k_spin+h10b-
     &1)+int_mb(k_spin+h1b-1)+int_mb(k_spin+p9b-1).ne.8)) THEN
      addr = addr + 1
      int_mb(k_a_offset+addr) = p9b - noab - 1 + nvab * (h1b - 1 + noab 
     &* (h10b - 1 + noab * (h8b - 1)))
      int_mb(k_a_offset+length+addr) = size
      size = size + int_mb(k_range+h8b-1) * int_mb(k_range+h10b-1) * int
     &_mb(k_range+h1b-1) * int_mb(k_range+p9b-1)
      END IF
      END IF
      END IF
      END DO
      END DO
      END DO
      END DO
      RETURN
      END
      SUBROUTINE OFFSET_eomccsdt_x2a_11_10_1(l_a_offset,k_a_offset,size)
C     $Id$
C     This is a Fortran77 program generated by Tensor Contraction Engine v.1.0
C     Copyright (c) Battelle & Pacific Northwest National Laboratory (2002)
C     i2 ( h6 h9 h1 p5 )_vx
      IMPLICIT NONE
#include "global.fh"
#include "mafdecls.fh"
#include "sym.fh"
#include "errquit.fh"
#include "tce.fh"
      INTEGER l_a_offset
      INTEGER k_a_offset
      INTEGER size
      INTEGER length
      INTEGER addr
      INTEGER h6b
      INTEGER h9b
      INTEGER h1b
      INTEGER p5b
      length = 0
      DO h6b = 1,noab
      DO h9b = h6b,noab
      DO h1b = 1,noab
      DO p5b = noab+1,noab+nvab
      IF (int_mb(k_spin+h6b-1)+int_mb(k_spin+h9b-1) .eq. int_mb(k_spin+h
     &1b-1)+int_mb(k_spin+p5b-1)) THEN
      IF (ieor(int_mb(k_sym+h6b-1),ieor(int_mb(k_sym+h9b-1),ieor(int_mb(
     &k_sym+h1b-1),int_mb(k_sym+p5b-1)))) .eq. ieor(irrep_v,irrep_x)) TH
     &EN
      IF ((.not.restricted).or.(int_mb(k_spin+h6b-1)+int_mb(k_spin+h9b-1
     &)+int_mb(k_spin+h1b-1)+int_mb(k_spin+p5b-1).ne.8)) THEN
      length = length + 1
      END IF
      END IF
      END IF
      END DO
      END DO
      END DO
      END DO
      IF (.not.MA_PUSH_GET(mt_int,2*length+1,'noname',l_a_offset,k_a_off
     &set)) CALL ERRQUIT('eomccsdt_x2_11_10_1',0,MA_ERR)
      int_mb(k_a_offset) = length
      addr = 0
      size = 0
      DO h6b = 1,noab
      DO h9b = h6b,noab
      DO h1b = 1,noab
      DO p5b = noab+1,noab+nvab
      IF (int_mb(k_spin+h6b-1)+int_mb(k_spin+h9b-1) .eq. int_mb(k_spin+h
     &1b-1)+int_mb(k_spin+p5b-1)) THEN
      IF (ieor(int_mb(k_sym+h6b-1),ieor(int_mb(k_sym+h9b-1),ieor(int_mb(
     &k_sym+h1b-1),int_mb(k_sym+p5b-1)))) .eq. ieor(irrep_v,irrep_x)) TH
     &EN
      IF ((.not.restricted).or.(int_mb(k_spin+h6b-1)+int_mb(k_spin+h9b-1
     &)+int_mb(k_spin+h1b-1)+int_mb(k_spin+p5b-1).ne.8)) THEN
      addr = addr + 1
      int_mb(k_a_offset+addr) = p5b - noab - 1 + nvab * (h1b - 1 + noab 
     &* (h9b - 1 + noab * (h6b - 1)))
      int_mb(k_a_offset+length+addr) = size
      size = size + int_mb(k_range+h6b-1) * int_mb(k_range+h9b-1) * int_
     &mb(k_range+h1b-1) * int_mb(k_range+p5b-1)
      END IF
      END IF
      END IF
      END DO
      END DO
      END DO
      END DO
      RETURN
      END
      SUBROUTINE OFFSET_eomccsdt_x2a_11_1_1(l_a_offset,k_a_offset,size)
C     $Id$
C     This is a Fortran77 program generated by Tensor Contraction Engine v.1.0
C     Copyright (c) Battelle & Pacific Northwest National Laboratory (2002)
C     i2 ( h9 h10 h1 h2 )_v
      IMPLICIT NONE
#include "global.fh"
#include "mafdecls.fh"
#include "sym.fh"
#include "errquit.fh"
#include "tce.fh"
      INTEGER l_a_offset
      INTEGER k_a_offset
      INTEGER size
      INTEGER length
      INTEGER addr
      INTEGER h9b
      INTEGER h10b
      INTEGER h1b
      INTEGER h2b
      length = 0
      DO h9b = 1,noab
      DO h10b = h9b,noab
      DO h1b = 1,noab
      DO h2b = h1b,noab
      IF (int_mb(k_spin+h9b-1)+int_mb(k_spin+h10b-1) .eq. int_mb(k_spin+
     &h1b-1)+int_mb(k_spin+h2b-1)) THEN
      IF (ieor(int_mb(k_sym+h9b-1),ieor(int_mb(k_sym+h10b-1),ieor(int_mb
     &(k_sym+h1b-1),int_mb(k_sym+h2b-1)))) .eq. irrep_v) THEN
      IF ((.not.restricted).or.(int_mb(k_spin+h9b-1)+int_mb(k_spin+h10b-
     &1)+int_mb(k_spin+h1b-1)+int_mb(k_spin+h2b-1).ne.8)) THEN
      length = length + 1
      END IF
      END IF
      END IF
      END DO
      END DO
      END DO
      END DO
      IF (.not.MA_PUSH_GET(mt_int,2*length+1,'noname',l_a_offset,k_a_off
     &set)) CALL ERRQUIT('eomccsdt_x2_11_1_1',0,MA_ERR)
      int_mb(k_a_offset) = length
      addr = 0
      size = 0
      DO h9b = 1,noab
      DO h10b = h9b,noab
      DO h1b = 1,noab
      DO h2b = h1b,noab
      IF (int_mb(k_spin+h9b-1)+int_mb(k_spin+h10b-1) .eq. int_mb(k_spin+
     &h1b-1)+int_mb(k_spin+h2b-1)) THEN
      IF (ieor(int_mb(k_sym+h9b-1),ieor(int_mb(k_sym+h10b-1),ieor(int_mb
     &(k_sym+h1b-1),int_mb(k_sym+h2b-1)))) .eq. irrep_v) THEN
      IF ((.not.restricted).or.(int_mb(k_spin+h9b-1)+int_mb(k_spin+h10b-
     &1)+int_mb(k_spin+h1b-1)+int_mb(k_spin+h2b-1).ne.8)) THEN
      addr = addr + 1
      int_mb(k_a_offset+addr) = h2b - 1 + noab * (h1b - 1 + noab * (h10b
     & - 1 + noab * (h9b - 1)))
      int_mb(k_a_offset+length+addr) = size
      size = size + int_mb(k_range+h9b-1) * int_mb(k_range+h10b-1) * int
     &_mb(k_range+h1b-1) * int_mb(k_range+h2b-1)
      END IF
      END IF
      END IF
      END DO
      END DO
      END DO
      END DO
      RETURN
      END
      SUBROUTINE OFFSET_eomccsdt_x2a_11_1_2_1(l_a_offset,k_a_offset,
     &size)
C     $Id$
C     This is a Fortran77 program generated by Tensor Contraction Engine v.1.0
C     Copyright (c) Battelle & Pacific Northwest National Laboratory (2002)
C     i3 ( h9 h10 h1 p6 )_v
      IMPLICIT NONE
#include "global.fh"
#include "mafdecls.fh"
#include "sym.fh"
#include "errquit.fh"
#include "tce.fh"
      INTEGER l_a_offset
      INTEGER k_a_offset
      INTEGER size
      INTEGER length
      INTEGER addr
      INTEGER h9b
      INTEGER h10b
      INTEGER h1b
      INTEGER p6b
      length = 0
      DO h9b = 1,noab
      DO h10b = h9b,noab
      DO h1b = 1,noab
      DO p6b = noab+1,noab+nvab
      IF (int_mb(k_spin+h9b-1)+int_mb(k_spin+h10b-1) .eq. int_mb(k_spin+
     &h1b-1)+int_mb(k_spin+p6b-1)) THEN
      IF (ieor(int_mb(k_sym+h9b-1),ieor(int_mb(k_sym+h10b-1),ieor(int_mb
     &(k_sym+h1b-1),int_mb(k_sym+p6b-1)))) .eq. irrep_v) THEN
      IF ((.not.restricted).or.(int_mb(k_spin+h9b-1)+int_mb(k_spin+h10b-
     &1)+int_mb(k_spin+h1b-1)+int_mb(k_spin+p6b-1).ne.8)) THEN
      length = length + 1
      END IF
      END IF
      END IF
      END DO
      END DO
      END DO
      END DO
      IF (.not.MA_PUSH_GET(mt_int,2*length+1,'noname',l_a_offset,k_a_off
     &set)) CALL ERRQUIT('eomccsdt_x2_11_1_2_1',0,MA_ERR)
      int_mb(k_a_offset) = length
      addr = 0
      size = 0
      DO h9b = 1,noab
      DO h10b = h9b,noab
      DO h1b = 1,noab
      DO p6b = noab+1,noab+nvab
      IF (int_mb(k_spin+h9b-1)+int_mb(k_spin+h10b-1) .eq. int_mb(k_spin+
     &h1b-1)+int_mb(k_spin+p6b-1)) THEN
      IF (ieor(int_mb(k_sym+h9b-1),ieor(int_mb(k_sym+h10b-1),ieor(int_mb
     &(k_sym+h1b-1),int_mb(k_sym+p6b-1)))) .eq. irrep_v) THEN
      IF ((.not.restricted).or.(int_mb(k_spin+h9b-1)+int_mb(k_spin+h10b-
     &1)+int_mb(k_spin+h1b-1)+int_mb(k_spin+p6b-1).ne.8)) THEN
      addr = addr + 1
      int_mb(k_a_offset+addr) = p6b - noab - 1 + nvab * (h1b - 1 + noab 
     &* (h10b - 1 + noab * (h9b - 1)))
      int_mb(k_a_offset+length+addr) = size
      size = size + int_mb(k_range+h9b-1) * int_mb(k_range+h10b-1) * int
     &_mb(k_range+h1b-1) * int_mb(k_range+p6b-1)
      END IF
      END IF
      END IF
      END DO
      END DO
      END DO
      END DO
      RETURN
      END
      SUBROUTINE OFFSET_eomccsdt_x2a_11_1(l_a_offset,k_a_offset,size)
C     $Id$
C     This is a Fortran77 program generated by Tensor Contraction Engine v.1.0
C     Copyright (c) Battelle & Pacific Northwest National Laboratory (2002)
C     i1 ( h9 p3 h1 h2 )_vx
      IMPLICIT NONE
#include "global.fh"
#include "mafdecls.fh"
#include "sym.fh"
#include "errquit.fh"
#include "tce.fh"
      INTEGER l_a_offset
      INTEGER k_a_offset
      INTEGER size
      INTEGER length
      INTEGER addr
      INTEGER p3b
      INTEGER h9b
      INTEGER h1b
      INTEGER h2b
      length = 0
      DO p3b = noab+1,noab+nvab
      DO h9b = 1,noab
      DO h1b = 1,noab
      DO h2b = h1b,noab
      IF (int_mb(k_spin+h9b-1)+int_mb(k_spin+p3b-1) .eq. int_mb(k_spin+h
     &1b-1)+int_mb(k_spin+h2b-1)) THEN
      IF (ieor(int_mb(k_sym+h9b-1),ieor(int_mb(k_sym+p3b-1),ieor(int_mb(
     &k_sym+h1b-1),int_mb(k_sym+h2b-1)))) .eq. ieor(irrep_v,irrep_x)) TH
     &EN
      IF ((.not.restricted).or.(int_mb(k_spin+h9b-1)+int_mb(k_spin+p3b-1
     &)+int_mb(k_spin+h1b-1)+int_mb(k_spin+h2b-1).ne.8)) THEN
      length = length + 1
      END IF
      END IF
      END IF
      END DO
      END DO
      END DO
      END DO
      IF (.not.MA_PUSH_GET(mt_int,2*length+1,'noname',l_a_offset,k_a_off
     &set)) CALL ERRQUIT('eomccsdt_x2_11_1',0,MA_ERR)
      int_mb(k_a_offset) = length
      addr = 0
      size = 0
      DO p3b = noab+1,noab+nvab
      DO h9b = 1,noab
      DO h1b = 1,noab
      DO h2b = h1b,noab
      IF (int_mb(k_spin+h9b-1)+int_mb(k_spin+p3b-1) .eq. int_mb(k_spin+h
     &1b-1)+int_mb(k_spin+h2b-1)) THEN
      IF (ieor(int_mb(k_sym+h9b-1),ieor(int_mb(k_sym+p3b-1),ieor(int_mb(
     &k_sym+h1b-1),int_mb(k_sym+h2b-1)))) .eq. ieor(irrep_v,irrep_x)) TH
     &EN
      IF ((.not.restricted).or.(int_mb(k_spin+h9b-1)+int_mb(k_spin+p3b-1
     &)+int_mb(k_spin+h1b-1)+int_mb(k_spin+h2b-1).ne.8)) THEN
      addr = addr + 1
      int_mb(k_a_offset+addr) = h2b - 1 + noab * (h1b - 1 + noab * (h9b 
     &- 1 + noab * (p3b - noab - 1)))
      int_mb(k_a_offset+length+addr) = size
      size = size + int_mb(k_range+p3b-1) * int_mb(k_range+h9b-1) * int_
     &mb(k_range+h1b-1) * int_mb(k_range+h2b-1)
      END IF
      END IF
      END IF
      END DO
      END DO
      END DO
      END DO
      RETURN
      END
      SUBROUTINE OFFSET_eomccsdt_x2a_11_3_1(l_a_offset,k_a_offset,size)
C     $Id$
C     This is a Fortran77 program generated by Tensor Contraction Engine v.1.0
C     Copyright (c) Battelle & Pacific Northwest National Laboratory (2002)
C     i2 ( h9 p5 )_f
      IMPLICIT NONE
#include "global.fh"
#include "mafdecls.fh"
#include "sym.fh"
#include "errquit.fh"
#include "tce.fh"
      INTEGER l_a_offset
      INTEGER k_a_offset
      INTEGER size
      INTEGER length
      INTEGER addr
      INTEGER h9b
      INTEGER p5b
      length = 0
      DO h9b = 1,noab
      DO p5b = noab+1,noab+nvab
      IF (int_mb(k_spin+h9b-1) .eq. int_mb(k_spin+p5b-1)) THEN
      IF (ieor(int_mb(k_sym+h9b-1),int_mb(k_sym+p5b-1)) .eq. irrep_f) TH
     &EN
      IF ((.not.restricted).or.(int_mb(k_spin+h9b-1)+int_mb(k_spin+p5b-1
     &).ne.4)) THEN
      length = length + 1
      END IF
      END IF
      END IF
      END DO
      END DO
      IF (.not.MA_PUSH_GET(mt_int,2*length+1,'noname',l_a_offset,k_a_off
     &set)) CALL ERRQUIT('eomccsdt_x2_11_3_1',0,MA_ERR)
      int_mb(k_a_offset) = length
      addr = 0
      size = 0
      DO h9b = 1,noab
      DO p5b = noab+1,noab+nvab
      IF (int_mb(k_spin+h9b-1) .eq. int_mb(k_spin+p5b-1)) THEN
      IF (ieor(int_mb(k_sym+h9b-1),int_mb(k_sym+p5b-1)) .eq. irrep_f) TH
     &EN
      IF ((.not.restricted).or.(int_mb(k_spin+h9b-1)+int_mb(k_spin+p5b-1
     &).ne.4)) THEN
      addr = addr + 1
      int_mb(k_a_offset+addr) = p5b - noab - 1 + nvab * (h9b - 1)
      int_mb(k_a_offset+length+addr) = size
      size = size + int_mb(k_range+h9b-1) * int_mb(k_range+p5b-1)
      END IF
      END IF
      END IF
      END DO
      END DO
      RETURN
      END
      SUBROUTINE OFFSET_eomccsdt_x2a_11_4_1(l_a_offset,k_a_offset,size)
C     $Id$
C     This is a Fortran77 program generated by Tensor Contraction Engine v.1.0
C     Copyright (c) Battelle & Pacific Northwest National Laboratory (2002)
C     i2 ( h8 h9 h1 p5 )_v
      IMPLICIT NONE
#include "global.fh"
#include "mafdecls.fh"
#include "sym.fh"
#include "errquit.fh"
#include "tce.fh"
      INTEGER l_a_offset
      INTEGER k_a_offset
      INTEGER size
      INTEGER length
      INTEGER addr
      INTEGER h8b
      INTEGER h9b
      INTEGER h1b
      INTEGER p5b
      length = 0
      DO h8b = 1,noab
      DO h9b = h8b,noab
      DO h1b = 1,noab
      DO p5b = noab+1,noab+nvab
      IF (int_mb(k_spin+h8b-1)+int_mb(k_spin+h9b-1) .eq. int_mb(k_spin+h
     &1b-1)+int_mb(k_spin+p5b-1)) THEN
      IF (ieor(int_mb(k_sym+h8b-1),ieor(int_mb(k_sym+h9b-1),ieor(int_mb(
     &k_sym+h1b-1),int_mb(k_sym+p5b-1)))) .eq. irrep_v) THEN
      IF ((.not.restricted).or.(int_mb(k_spin+h8b-1)+int_mb(k_spin+h9b-1
     &)+int_mb(k_spin+h1b-1)+int_mb(k_spin+p5b-1).ne.8)) THEN
      length = length + 1
      END IF
      END IF
      END IF
      END DO
      END DO
      END DO
      END DO
      IF (.not.MA_PUSH_GET(mt_int,2*length+1,'noname',l_a_offset,k_a_off
     &set)) CALL ERRQUIT('eomccsdt_x2_11_4_1',0,MA_ERR)
      int_mb(k_a_offset) = length
      addr = 0
      size = 0
      DO h8b = 1,noab
      DO h9b = h8b,noab
      DO h1b = 1,noab
      DO p5b = noab+1,noab+nvab
      IF (int_mb(k_spin+h8b-1)+int_mb(k_spin+h9b-1) .eq. int_mb(k_spin+h
     &1b-1)+int_mb(k_spin+p5b-1)) THEN
      IF (ieor(int_mb(k_sym+h8b-1),ieor(int_mb(k_sym+h9b-1),ieor(int_mb(
     &k_sym+h1b-1),int_mb(k_sym+p5b-1)))) .eq. irrep_v) THEN
      IF ((.not.restricted).or.(int_mb(k_spin+h8b-1)+int_mb(k_spin+h9b-1
     &)+int_mb(k_spin+h1b-1)+int_mb(k_spin+p5b-1).ne.8)) THEN
      addr = addr + 1
      int_mb(k_a_offset+addr) = p5b - noab - 1 + nvab * (h1b - 1 + noab 
     &* (h9b - 1 + noab * (h8b - 1)))
      int_mb(k_a_offset+length+addr) = size
      size = size + int_mb(k_range+h8b-1) * int_mb(k_range+h9b-1) * int_
     &mb(k_range+h1b-1) * int_mb(k_range+p5b-1)
      END IF
      END IF
      END IF
      END DO
      END DO
      END DO
      END DO
      RETURN
      END
      SUBROUTINE OFFSET_eomccsdt_x2a_11_7_1(l_a_offset,k_a_offset,size)
C     $Id$
C     This is a Fortran77 program generated by Tensor Contraction Engine v.1.0
C     Copyright (c) Battelle & Pacific Northwest National Laboratory (2002)
C     i2 ( h6 h9 h1 h2 )_vx
      IMPLICIT NONE
#include "global.fh"
#include "mafdecls.fh"
#include "sym.fh"
#include "errquit.fh"
#include "tce.fh"
      INTEGER l_a_offset
      INTEGER k_a_offset
      INTEGER size
      INTEGER length
      INTEGER addr
      INTEGER h6b
      INTEGER h9b
      INTEGER h1b
      INTEGER h2b
      length = 0
      DO h6b = 1,noab
      DO h9b = h6b,noab
      DO h1b = 1,noab
      DO h2b = h1b,noab
      IF (int_mb(k_spin+h6b-1)+int_mb(k_spin+h9b-1) .eq. int_mb(k_spin+h
     &1b-1)+int_mb(k_spin+h2b-1)) THEN
      IF (ieor(int_mb(k_sym+h6b-1),ieor(int_mb(k_sym+h9b-1),ieor(int_mb(
     &k_sym+h1b-1),int_mb(k_sym+h2b-1)))) .eq. ieor(irrep_v,irrep_x)) TH
     &EN
      IF ((.not.restricted).or.(int_mb(k_spin+h6b-1)+int_mb(k_spin+h9b-1
     &)+int_mb(k_spin+h1b-1)+int_mb(k_spin+h2b-1).ne.8)) THEN
      length = length + 1
      END IF
      END IF
      END IF
      END DO
      END DO
      END DO
      END DO
      IF (.not.MA_PUSH_GET(mt_int,2*length+1,'noname',l_a_offset,k_a_off
     &set)) CALL ERRQUIT('eomccsdt_x2_11_7_1',0,MA_ERR)
      int_mb(k_a_offset) = length
      addr = 0
      size = 0
      DO h6b = 1,noab
      DO h9b = h6b,noab
      DO h1b = 1,noab
      DO h2b = h1b,noab
      IF (int_mb(k_spin+h6b-1)+int_mb(k_spin+h9b-1) .eq. int_mb(k_spin+h
     &1b-1)+int_mb(k_spin+h2b-1)) THEN
      IF (ieor(int_mb(k_sym+h6b-1),ieor(int_mb(k_sym+h9b-1),ieor(int_mb(
     &k_sym+h1b-1),int_mb(k_sym+h2b-1)))) .eq. ieor(irrep_v,irrep_x)) TH
     &EN
      IF ((.not.restricted).or.(int_mb(k_spin+h6b-1)+int_mb(k_spin+h9b-1
     &)+int_mb(k_spin+h1b-1)+int_mb(k_spin+h2b-1).ne.8)) THEN
      addr = addr + 1
      int_mb(k_a_offset+addr) = h2b - 1 + noab * (h1b - 1 + noab * (h9b 
     &- 1 + noab * (h6b - 1)))
      int_mb(k_a_offset+length+addr) = size
      size = size + int_mb(k_range+h6b-1) * int_mb(k_range+h9b-1) * int_
     &mb(k_range+h1b-1) * int_mb(k_range+h2b-1)
      END IF
      END IF
      END IF
      END DO
      END DO
      END DO
      END DO
      RETURN
      END
      SUBROUTINE OFFSET_eomccsdt_x2a_11_7_3_1(l_a_offset,k_a_offset,
     &size)
C     $Id$
C     This is a Fortran77 program generated by Tensor Contraction Engine v.1.0
C     Copyright (c) Battelle & Pacific Northwest National Laboratory (2002)
C     i3 ( h6 h9 h1 p7 )_vx
      IMPLICIT NONE
#include "global.fh"
#include "mafdecls.fh"
#include "sym.fh"
#include "errquit.fh"
#include "tce.fh"
      INTEGER l_a_offset
      INTEGER k_a_offset
      INTEGER size
      INTEGER length
      INTEGER addr
      INTEGER h6b
      INTEGER h9b
      INTEGER h1b
      INTEGER p7b
      length = 0
      DO h6b = 1,noab
      DO h9b = h6b,noab
      DO h1b = 1,noab
      DO p7b = noab+1,noab+nvab
      IF (int_mb(k_spin+h6b-1)+int_mb(k_spin+h9b-1) .eq. int_mb(k_spin+h
     &1b-1)+int_mb(k_spin+p7b-1)) THEN
      IF (ieor(int_mb(k_sym+h6b-1),ieor(int_mb(k_sym+h9b-1),ieor(int_mb(
     &k_sym+h1b-1),int_mb(k_sym+p7b-1)))) .eq. ieor(irrep_v,irrep_x)) TH
     &EN
      IF ((.not.restricted).or.(int_mb(k_spin+h6b-1)+int_mb(k_spin+h9b-1
     &)+int_mb(k_spin+h1b-1)+int_mb(k_spin+p7b-1).ne.8)) THEN
      length = length + 1
      END IF
      END IF
      END IF
      END DO
      END DO
      END DO
      END DO
      IF (.not.MA_PUSH_GET(mt_int,2*length+1,'noname',l_a_offset,k_a_off
     &set)) CALL ERRQUIT('eomccsdt_x2_11_7_3_1',0,MA_ERR)
      int_mb(k_a_offset) = length
      addr = 0
      size = 0
      DO h6b = 1,noab
      DO h9b = h6b,noab
      DO h1b = 1,noab
      DO p7b = noab+1,noab+nvab
      IF (int_mb(k_spin+h6b-1)+int_mb(k_spin+h9b-1) .eq. int_mb(k_spin+h
     &1b-1)+int_mb(k_spin+p7b-1)) THEN
      IF (ieor(int_mb(k_sym+h6b-1),ieor(int_mb(k_sym+h9b-1),ieor(int_mb(
     &k_sym+h1b-1),int_mb(k_sym+p7b-1)))) .eq. ieor(irrep_v,irrep_x)) TH
     &EN
      IF ((.not.restricted).or.(int_mb(k_spin+h6b-1)+int_mb(k_spin+h9b-1
     &)+int_mb(k_spin+h1b-1)+int_mb(k_spin+p7b-1).ne.8)) THEN
      addr = addr + 1
      int_mb(k_a_offset+addr) = p7b - noab - 1 + nvab * (h1b - 1 + noab 
     &* (h9b - 1 + noab * (h6b - 1)))
      int_mb(k_a_offset+length+addr) = size
      size = size + int_mb(k_range+h6b-1) * int_mb(k_range+h9b-1) * int_
     &mb(k_range+h1b-1) * int_mb(k_range+p7b-1)
      END IF
      END IF
      END IF
      END DO
      END DO
      END DO
      END DO
      RETURN
      END
      SUBROUTINE OFFSET_eomccsdt_x2a_11_8_1(l_a_offset,k_a_offset,size)
C     $Id$
C     This is a Fortran77 program generated by Tensor Contraction Engine v.1.0
C     Copyright (c) Battelle & Pacific Northwest National Laboratory (2002)
C     i2 ( h9 p3 h1 p6 )_vx
      IMPLICIT NONE
#include "global.fh"
#include "mafdecls.fh"
#include "sym.fh"
#include "errquit.fh"
#include "tce.fh"
      INTEGER l_a_offset
      INTEGER k_a_offset
      INTEGER size
      INTEGER length
      INTEGER addr
      INTEGER p3b
      INTEGER h9b
      INTEGER h1b
      INTEGER p6b
      length = 0
      DO p3b = noab+1,noab+nvab
      DO h9b = 1,noab
      DO h1b = 1,noab
      DO p6b = noab+1,noab+nvab
      IF (int_mb(k_spin+h9b-1)+int_mb(k_spin+p3b-1) .eq. int_mb(k_spin+h
     &1b-1)+int_mb(k_spin+p6b-1)) THEN
      IF (ieor(int_mb(k_sym+h9b-1),ieor(int_mb(k_sym+p3b-1),ieor(int_mb(
     &k_sym+h1b-1),int_mb(k_sym+p6b-1)))) .eq. ieor(irrep_v,irrep_x)) TH
     &EN
      IF ((.not.restricted).or.(int_mb(k_spin+h9b-1)+int_mb(k_spin+p3b-1
     &)+int_mb(k_spin+h1b-1)+int_mb(k_spin+p6b-1).ne.8)) THEN
      length = length + 1
      END IF
      END IF
      END IF
      END DO
      END DO
      END DO
      END DO
      IF (.not.MA_PUSH_GET(mt_int,2*length+1,'noname',l_a_offset,k_a_off
     &set)) CALL ERRQUIT('eomccsdt_x2_11_8_1',0,MA_ERR)
      int_mb(k_a_offset) = length
      addr = 0
      size = 0
      DO p3b = noab+1,noab+nvab
      DO h9b = 1,noab
      DO h1b = 1,noab
      DO p6b = noab+1,noab+nvab
      IF (int_mb(k_spin+h9b-1)+int_mb(k_spin+p3b-1) .eq. int_mb(k_spin+h
     &1b-1)+int_mb(k_spin+p6b-1)) THEN
      IF (ieor(int_mb(k_sym+h9b-1),ieor(int_mb(k_sym+p3b-1),ieor(int_mb(
     &k_sym+h1b-1),int_mb(k_sym+p6b-1)))) .eq. ieor(irrep_v,irrep_x)) TH
     &EN
      IF ((.not.restricted).or.(int_mb(k_spin+h9b-1)+int_mb(k_spin+p3b-1
     &)+int_mb(k_spin+h1b-1)+int_mb(k_spin+p6b-1).ne.8)) THEN
      addr = addr + 1
      int_mb(k_a_offset+addr) = p6b - noab - 1 + nvab * (h1b - 1 + noab 
     &* (h9b - 1 + noab * (p3b - noab - 1)))
      int_mb(k_a_offset+length+addr) = size
      size = size + int_mb(k_range+p3b-1) * int_mb(k_range+h9b-1) * int_
     &mb(k_range+h1b-1) * int_mb(k_range+p6b-1)
      END IF
      END IF
      END IF
      END DO
      END DO
      END DO
      END DO
      RETURN
      END
      SUBROUTINE OFFSET_eomccsdt_x2a_11_9_1(l_a_offset,k_a_offset,size)
C     $Id$
C     This is a Fortran77 program generated by Tensor Contraction Engine v.1.0
C     Copyright (c) Battelle & Pacific Northwest National Laboratory (2002)
C     i2 ( h9 p5 )_vx
      IMPLICIT NONE
#include "global.fh"
#include "mafdecls.fh"
#include "sym.fh"
#include "errquit.fh"
#include "tce.fh"
      INTEGER l_a_offset
      INTEGER k_a_offset
      INTEGER size
      INTEGER length
      INTEGER addr
      INTEGER h9b
      INTEGER p5b
      length = 0
      DO h9b = 1,noab
      DO p5b = noab+1,noab+nvab
      IF (int_mb(k_spin+h9b-1) .eq. int_mb(k_spin+p5b-1)) THEN
      IF (ieor(int_mb(k_sym+h9b-1),int_mb(k_sym+p5b-1)) .eq. ieor(irrep_
     &v,irrep_x)) THEN
      IF ((.not.restricted).or.(int_mb(k_spin+h9b-1)+int_mb(k_spin+p5b-1
     &).ne.4)) THEN
      length = length + 1
      END IF
      END IF
      END IF
      END DO
      END DO
      IF (.not.MA_PUSH_GET(mt_int,2*length+1,'noname',l_a_offset,k_a_off
     &set)) CALL ERRQUIT('eomccsdt_x2_11_9_1',0,MA_ERR)
      int_mb(k_a_offset) = length
      addr = 0
      size = 0
      DO h9b = 1,noab
      DO p5b = noab+1,noab+nvab
      IF (int_mb(k_spin+h9b-1) .eq. int_mb(k_spin+p5b-1)) THEN
      IF (ieor(int_mb(k_sym+h9b-1),int_mb(k_sym+p5b-1)) .eq. ieor(irrep_
     &v,irrep_x)) THEN
      IF ((.not.restricted).or.(int_mb(k_spin+h9b-1)+int_mb(k_spin+p5b-1
     &).ne.4)) THEN
      addr = addr + 1
      int_mb(k_a_offset+addr) = p5b - noab - 1 + nvab * (h9b - 1)
      int_mb(k_a_offset+length+addr) = size
      size = size + int_mb(k_range+h9b-1) * int_mb(k_range+p5b-1)
      END IF
      END IF
      END IF
      END DO
      END DO
      RETURN
      END
      SUBROUTINE OFFSET_eomccsdt_x2a_1_1(l_a_offset,k_a_offset,size)
C     $Id$
C     This is a Fortran77 program generated by Tensor Contraction Engine v.1.0
C     Copyright (c) Battelle & Pacific Northwest National Laboratory (2002)
C     i1 ( h9 p3 h1 h2 )_v
      IMPLICIT NONE
#include "global.fh"
#include "mafdecls.fh"
#include "sym.fh"
#include "errquit.fh"
#include "tce.fh"
      INTEGER l_a_offset
      INTEGER k_a_offset
      INTEGER size
      INTEGER length
      INTEGER addr
      INTEGER p3b
      INTEGER h9b
      INTEGER h1b
      INTEGER h2b
      length = 0
      DO p3b = noab+1,noab+nvab
      DO h9b = 1,noab
      DO h1b = 1,noab
      DO h2b = h1b,noab
      IF (int_mb(k_spin+h9b-1)+int_mb(k_spin+p3b-1) .eq. int_mb(k_spin+h
     &1b-1)+int_mb(k_spin+h2b-1)) THEN
      IF (ieor(int_mb(k_sym+h9b-1),ieor(int_mb(k_sym+p3b-1),ieor(int_mb(
     &k_sym+h1b-1),int_mb(k_sym+h2b-1)))) .eq. irrep_v) THEN
      IF ((.not.restricted).or.(int_mb(k_spin+h9b-1)+int_mb(k_spin+p3b-1
     &)+int_mb(k_spin+h1b-1)+int_mb(k_spin+h2b-1).ne.8)) THEN
      length = length + 1
      END IF
      END IF
      END IF
      END DO
      END DO
      END DO
      END DO
      IF (.not.MA_PUSH_GET(mt_int,2*length+1,'noname',l_a_offset,k_a_off
     &set)) CALL ERRQUIT('eomccsdt_x2_1_1',0,MA_ERR)
      int_mb(k_a_offset) = length
      addr = 0
      size = 0
      DO p3b = noab+1,noab+nvab
      DO h9b = 1,noab
      DO h1b = 1,noab
      DO h2b = h1b,noab
      IF (int_mb(k_spin+h9b-1)+int_mb(k_spin+p3b-1) .eq. int_mb(k_spin+h
     &1b-1)+int_mb(k_spin+h2b-1)) THEN
      IF (ieor(int_mb(k_sym+h9b-1),ieor(int_mb(k_sym+p3b-1),ieor(int_mb(
     &k_sym+h1b-1),int_mb(k_sym+h2b-1)))) .eq. irrep_v) THEN
      IF ((.not.restricted).or.(int_mb(k_spin+h9b-1)+int_mb(k_spin+p3b-1
     &)+int_mb(k_spin+h1b-1)+int_mb(k_spin+h2b-1).ne.8)) THEN
      addr = addr + 1
      int_mb(k_a_offset+addr) = h2b - 1 + noab * (h1b - 1 + noab * (h9b 
     &- 1 + noab * (p3b - noab - 1)))
      int_mb(k_a_offset+length+addr) = size
      size = size + int_mb(k_range+p3b-1) * int_mb(k_range+h9b-1) * int_
     &mb(k_range+h1b-1) * int_mb(k_range+h2b-1)
      END IF
      END IF
      END IF
      END DO
      END DO
      END DO
      END DO
      RETURN
      END
      SUBROUTINE OFFSET_eomccsdt_x2a_1_2_1(l_a_offset,k_a_offset,size)
C     $Id$
C     This is a Fortran77 program generated by Tensor Contraction Engine v.1.0
C     Copyright (c) Battelle & Pacific Northwest National Laboratory (2002)
C     i2 ( h9 p3 h1 p5 )_v
      IMPLICIT NONE
#include "global.fh"
#include "mafdecls.fh"
#include "sym.fh"
#include "errquit.fh"
#include "tce.fh"
      INTEGER l_a_offset
      INTEGER k_a_offset
      INTEGER size
      INTEGER length
      INTEGER addr
      INTEGER p3b
      INTEGER h9b
      INTEGER h1b
      INTEGER p5b
      length = 0
      DO p3b = noab+1,noab+nvab
      DO h9b = 1,noab
      DO h1b = 1,noab
      DO p5b = noab+1,noab+nvab
      IF (int_mb(k_spin+h9b-1)+int_mb(k_spin+p3b-1) .eq. int_mb(k_spin+h
     &1b-1)+int_mb(k_spin+p5b-1)) THEN
      IF (ieor(int_mb(k_sym+h9b-1),ieor(int_mb(k_sym+p3b-1),ieor(int_mb(
     &k_sym+h1b-1),int_mb(k_sym+p5b-1)))) .eq. irrep_v) THEN
      IF ((.not.restricted).or.(int_mb(k_spin+h9b-1)+int_mb(k_spin+p3b-1
     &)+int_mb(k_spin+h1b-1)+int_mb(k_spin+p5b-1).ne.8)) THEN
      length = length + 1
      END IF
      END IF
      END IF
      END DO
      END DO
      END DO
      END DO
      IF (.not.MA_PUSH_GET(mt_int,2*length+1,'noname',l_a_offset,k_a_off
     &set)) CALL ERRQUIT('eomccsdt_x2_1_2_1',0,MA_ERR)
      int_mb(k_a_offset) = length
      addr = 0
      size = 0
      DO p3b = noab+1,noab+nvab
      DO h9b = 1,noab
      DO h1b = 1,noab
      DO p5b = noab+1,noab+nvab
      IF (int_mb(k_spin+h9b-1)+int_mb(k_spin+p3b-1) .eq. int_mb(k_spin+h
     &1b-1)+int_mb(k_spin+p5b-1)) THEN
      IF (ieor(int_mb(k_sym+h9b-1),ieor(int_mb(k_sym+p3b-1),ieor(int_mb(
     &k_sym+h1b-1),int_mb(k_sym+p5b-1)))) .eq. irrep_v) THEN
      IF ((.not.restricted).or.(int_mb(k_spin+h9b-1)+int_mb(k_spin+p3b-1
     &)+int_mb(k_spin+h1b-1)+int_mb(k_spin+p5b-1).ne.8)) THEN
      addr = addr + 1
      int_mb(k_a_offset+addr) = p5b - noab - 1 + nvab * (h1b - 1 + noab 
     &* (h9b - 1 + noab * (p3b - noab - 1)))
      int_mb(k_a_offset+length+addr) = size
      size = size + int_mb(k_range+p3b-1) * int_mb(k_range+h9b-1) * int_
     &mb(k_range+h1b-1) * int_mb(k_range+p5b-1)
      END IF
      END IF
      END IF
      END DO
      END DO
      END DO
      END DO
      RETURN
      END
      SUBROUTINE OFFSET_eomccsdt_x2a_12_1(l_a_offset,k_a_offset,size)
C     $Id$
C     This is a Fortran77 program generated by Tensor Contraction Engine v.1.0
C     Copyright (c) Battelle & Pacific Northwest National Laboratory (2002)
C     i1 ( p3 p4 h1 p5 )_vx
      IMPLICIT NONE
#include "global.fh"
#include "mafdecls.fh"
#include "sym.fh"
#include "errquit.fh"
#include "tce.fh"
      INTEGER l_a_offset
      INTEGER k_a_offset
      INTEGER size
      INTEGER length
      INTEGER addr
      INTEGER p3b
      INTEGER p4b
      INTEGER h1b
      INTEGER p5b
      length = 0
      DO p3b = noab+1,noab+nvab
      DO p4b = p3b,noab+nvab
      DO h1b = 1,noab
      DO p5b = noab+1,noab+nvab
      IF (int_mb(k_spin+p3b-1)+int_mb(k_spin+p4b-1) .eq. int_mb(k_spin+h
     &1b-1)+int_mb(k_spin+p5b-1)) THEN
      IF (ieor(int_mb(k_sym+p3b-1),ieor(int_mb(k_sym+p4b-1),ieor(int_mb(
     &k_sym+h1b-1),int_mb(k_sym+p5b-1)))) .eq. ieor(irrep_v,irrep_x)) TH
     &EN
      IF ((.not.restricted).or.(int_mb(k_spin+p3b-1)+int_mb(k_spin+p4b-1
     &)+int_mb(k_spin+h1b-1)+int_mb(k_spin+p5b-1).ne.8)) THEN
      length = length + 1
      END IF
      END IF
      END IF
      END DO
      END DO
      END DO
      END DO
      IF (.not.MA_PUSH_GET(mt_int,2*length+1,'noname',l_a_offset,k_a_off
     &set)) CALL ERRQUIT('eomccsdt_x2_12_1',0,MA_ERR)
      int_mb(k_a_offset) = length
      addr = 0
      size = 0
      DO p3b = noab+1,noab+nvab
      DO p4b = p3b,noab+nvab
      DO h1b = 1,noab
      DO p5b = noab+1,noab+nvab
      IF (int_mb(k_spin+p3b-1)+int_mb(k_spin+p4b-1) .eq. int_mb(k_spin+h
     &1b-1)+int_mb(k_spin+p5b-1)) THEN
      IF (ieor(int_mb(k_sym+p3b-1),ieor(int_mb(k_sym+p4b-1),ieor(int_mb(
     &k_sym+h1b-1),int_mb(k_sym+p5b-1)))) .eq. ieor(irrep_v,irrep_x)) TH
     &EN
      IF ((.not.restricted).or.(int_mb(k_spin+p3b-1)+int_mb(k_spin+p4b-1
     &)+int_mb(k_spin+h1b-1)+int_mb(k_spin+p5b-1).ne.8)) THEN
      addr = addr + 1
      int_mb(k_a_offset+addr) = p5b - noab - 1 + nvab * (h1b - 1 + noab 
     &* (p4b - noab - 1 + nvab * (p3b - noab - 1)))
      int_mb(k_a_offset+length+addr) = size
      size = size + int_mb(k_range+p3b-1) * int_mb(k_range+p4b-1) * int_
     &mb(k_range+h1b-1) * int_mb(k_range+p5b-1)
      END IF
      END IF
      END IF
      END DO
      END DO
      END DO
      END DO
      RETURN
      END
      SUBROUTINE OFFSET_eomccsdt_x2a_13_1_1(l_a_offset,k_a_offset,size)
C     $Id$
C     This is a Fortran77 program generated by Tensor Contraction Engine v.1.0
C     Copyright (c) Battelle & Pacific Northwest National Laboratory (2002)
C     i2 ( h5 p9 )_f
      IMPLICIT NONE
#include "global.fh"
#include "mafdecls.fh"
#include "sym.fh"
#include "errquit.fh"
#include "tce.fh"
      INTEGER l_a_offset
      INTEGER k_a_offset
      INTEGER size
      INTEGER length
      INTEGER addr
      INTEGER h5b
      INTEGER p9b
      length = 0
      DO h5b = 1,noab
      DO p9b = noab+1,noab+nvab
      IF (int_mb(k_spin+h5b-1) .eq. int_mb(k_spin+p9b-1)) THEN
      IF (ieor(int_mb(k_sym+h5b-1),int_mb(k_sym+p9b-1)) .eq. irrep_f) TH
     &EN
      IF ((.not.restricted).or.(int_mb(k_spin+h5b-1)+int_mb(k_spin+p9b-1
     &).ne.4)) THEN
      length = length + 1
      END IF
      END IF
      END IF
      END DO
      END DO
      IF (.not.MA_PUSH_GET(mt_int,2*length+1,'noname',l_a_offset,k_a_off
     &set)) CALL ERRQUIT('eomccsdt_x2_13_1_1',0,MA_ERR)
      int_mb(k_a_offset) = length
      addr = 0
      size = 0
      DO h5b = 1,noab
      DO p9b = noab+1,noab+nvab
      IF (int_mb(k_spin+h5b-1) .eq. int_mb(k_spin+p9b-1)) THEN
      IF (ieor(int_mb(k_sym+h5b-1),int_mb(k_sym+p9b-1)) .eq. irrep_f) TH
     &EN
      IF ((.not.restricted).or.(int_mb(k_spin+h5b-1)+int_mb(k_spin+p9b-1
     &).ne.4)) THEN
      addr = addr + 1
      int_mb(k_a_offset+addr) = p9b - noab - 1 + nvab * (h5b - 1)
      int_mb(k_a_offset+length+addr) = size
      size = size + int_mb(k_range+h5b-1) * int_mb(k_range+p9b-1)
      END IF
      END IF
      END IF
      END DO
      END DO
      RETURN
      END
      SUBROUTINE OFFSET_eomccsdt_x2a_1_3_1(l_a_offset,k_a_offset,size)
C     $Id$
C     This is a Fortran77 program generated by Tensor Contraction Engine v.1.0
C     Copyright (c) Battelle & Pacific Northwest National Laboratory (2002)
C     i2 ( h9 p8 )_f
      IMPLICIT NONE
#include "global.fh"
#include "mafdecls.fh"
#include "sym.fh"
#include "errquit.fh"
#include "tce.fh"
      INTEGER l_a_offset
      INTEGER k_a_offset
      INTEGER size
      INTEGER length
      INTEGER addr
      INTEGER h9b
      INTEGER p8b
      length = 0
      DO h9b = 1,noab
      DO p8b = noab+1,noab+nvab
      IF (int_mb(k_spin+h9b-1) .eq. int_mb(k_spin+p8b-1)) THEN
      IF (ieor(int_mb(k_sym+h9b-1),int_mb(k_sym+p8b-1)) .eq. irrep_f) TH
     &EN
      IF ((.not.restricted).or.(int_mb(k_spin+h9b-1)+int_mb(k_spin+p8b-1
     &).ne.4)) THEN
      length = length + 1
      END IF
      END IF
      END IF
      END DO
      END DO
      IF (.not.MA_PUSH_GET(mt_int,2*length+1,'noname',l_a_offset,k_a_off
     &set)) CALL ERRQUIT('eomccsdt_x2_1_3_1',0,MA_ERR)
      int_mb(k_a_offset) = length
      addr = 0
      size = 0
      DO h9b = 1,noab
      DO p8b = noab+1,noab+nvab
      IF (int_mb(k_spin+h9b-1) .eq. int_mb(k_spin+p8b-1)) THEN
      IF (ieor(int_mb(k_sym+h9b-1),int_mb(k_sym+p8b-1)) .eq. irrep_f) TH
     &EN
      IF ((.not.restricted).or.(int_mb(k_spin+h9b-1)+int_mb(k_spin+p8b-1
     &).ne.4)) THEN
      addr = addr + 1
      int_mb(k_a_offset+addr) = p8b - noab - 1 + nvab * (h9b - 1)
      int_mb(k_a_offset+length+addr) = size
      size = size + int_mb(k_range+h9b-1) * int_mb(k_range+p8b-1)
      END IF
      END IF
      END IF
      END DO
      END DO
      RETURN
      END
      SUBROUTINE OFFSET_eomccsdt_x2a_13_1(l_a_offset,k_a_offset,size)
C     $Id$
C     This is a Fortran77 program generated by Tensor Contraction Engine v.1.0
C     Copyright (c) Battelle & Pacific Northwest National Laboratory (2002)
C     i1 ( h5 h1 )_fx
      IMPLICIT NONE
#include "global.fh"
#include "mafdecls.fh"
#include "sym.fh"
#include "errquit.fh"
#include "tce.fh"
      INTEGER l_a_offset
      INTEGER k_a_offset
      INTEGER size
      INTEGER length
      INTEGER addr
      INTEGER h5b
      INTEGER h1b
      length = 0
      DO h5b = 1,noab
      DO h1b = 1,noab
      IF (int_mb(k_spin+h5b-1) .eq. int_mb(k_spin+h1b-1)) THEN
      IF (ieor(int_mb(k_sym+h5b-1),int_mb(k_sym+h1b-1)) .eq. ieor(irrep_
     &f,irrep_x)) THEN
      IF ((.not.restricted).or.(int_mb(k_spin+h5b-1)+int_mb(k_spin+h1b-1
     &).ne.4)) THEN
      length = length + 1
      END IF
      END IF
      END IF
      END DO
      END DO
      IF (.not.MA_PUSH_GET(mt_int,2*length+1,'noname',l_a_offset,k_a_off
     &set)) CALL ERRQUIT('eomccsdt_x2_13_1',0,MA_ERR)
      int_mb(k_a_offset) = length
      addr = 0
      size = 0
      DO h5b = 1,noab
      DO h1b = 1,noab
      IF (int_mb(k_spin+h5b-1) .eq. int_mb(k_spin+h1b-1)) THEN
      IF (ieor(int_mb(k_sym+h5b-1),int_mb(k_sym+h1b-1)) .eq. ieor(irrep_
     &f,irrep_x)) THEN
      IF ((.not.restricted).or.(int_mb(k_spin+h5b-1)+int_mb(k_spin+h1b-1
     &).ne.4)) THEN
      addr = addr + 1
      int_mb(k_a_offset+addr) = h1b - 1 + noab * (h5b - 1)
      int_mb(k_a_offset+length+addr) = size
      size = size + int_mb(k_range+h5b-1) * int_mb(k_range+h1b-1)
      END IF
      END IF
      END IF
      END DO
      END DO
      RETURN
      END
      SUBROUTINE OFFSET_eomccsdt_x2a_13_4_1(l_a_offset,k_a_offset,size)
C     $Id$
C     This is a Fortran77 program generated by Tensor Contraction Engine v.1.0
C     Copyright (c) Battelle & Pacific Northwest National Laboratory (2002)
C     i2 ( h5 p6 )_vx
      IMPLICIT NONE
#include "global.fh"
#include "mafdecls.fh"
#include "sym.fh"
#include "errquit.fh"
#include "tce.fh"
      INTEGER l_a_offset
      INTEGER k_a_offset
      INTEGER size
      INTEGER length
      INTEGER addr
      INTEGER h5b
      INTEGER p6b
      length = 0
      DO h5b = 1,noab
      DO p6b = noab+1,noab+nvab
      IF (int_mb(k_spin+h5b-1) .eq. int_mb(k_spin+p6b-1)) THEN
      IF (ieor(int_mb(k_sym+h5b-1),int_mb(k_sym+p6b-1)) .eq. ieor(irrep_
     &v,irrep_x)) THEN
      IF ((.not.restricted).or.(int_mb(k_spin+h5b-1)+int_mb(k_spin+p6b-1
     &).ne.4)) THEN
      length = length + 1
      END IF
      END IF
      END IF
      END DO
      END DO
      IF (.not.MA_PUSH_GET(mt_int,2*length+1,'noname',l_a_offset,k_a_off
     &set)) CALL ERRQUIT('eomccsdt_x2_13_4_1',0,MA_ERR)
      int_mb(k_a_offset) = length
      addr = 0
      size = 0
      DO h5b = 1,noab
      DO p6b = noab+1,noab+nvab
      IF (int_mb(k_spin+h5b-1) .eq. int_mb(k_spin+p6b-1)) THEN
      IF (ieor(int_mb(k_sym+h5b-1),int_mb(k_sym+p6b-1)) .eq. ieor(irrep_
     &v,irrep_x)) THEN
      IF ((.not.restricted).or.(int_mb(k_spin+h5b-1)+int_mb(k_spin+p6b-1
     &).ne.4)) THEN
      addr = addr + 1
      int_mb(k_a_offset+addr) = p6b - noab - 1 + nvab * (h5b - 1)
      int_mb(k_a_offset+length+addr) = size
      size = size + int_mb(k_range+h5b-1) * int_mb(k_range+p6b-1)
      END IF
      END IF
      END IF
      END DO
      END DO
      RETURN
      END
      SUBROUTINE OFFSET_eomccsdt_x2a_1_4_1(l_a_offset,k_a_offset,size)
C     $Id$
C     This is a Fortran77 program generated by Tensor Contraction Engine v.1.0
C     Copyright (c) Battelle & Pacific Northwest National Laboratory (2002)
C     i2 ( h6 h9 h1 p5 )_v
      IMPLICIT NONE
#include "global.fh"
#include "mafdecls.fh"
#include "sym.fh"
#include "errquit.fh"
#include "tce.fh"
      INTEGER l_a_offset
      INTEGER k_a_offset
      INTEGER size
      INTEGER length
      INTEGER addr
      INTEGER h6b
      INTEGER h9b
      INTEGER h1b
      INTEGER p5b
      length = 0
      DO h6b = 1,noab
      DO h9b = h6b,noab
      DO h1b = 1,noab
      DO p5b = noab+1,noab+nvab
      IF (int_mb(k_spin+h6b-1)+int_mb(k_spin+h9b-1) .eq. int_mb(k_spin+h
     &1b-1)+int_mb(k_spin+p5b-1)) THEN
      IF (ieor(int_mb(k_sym+h6b-1),ieor(int_mb(k_sym+h9b-1),ieor(int_mb(
     &k_sym+h1b-1),int_mb(k_sym+p5b-1)))) .eq. irrep_v) THEN
      IF ((.not.restricted).or.(int_mb(k_spin+h6b-1)+int_mb(k_spin+h9b-1
     &)+int_mb(k_spin+h1b-1)+int_mb(k_spin+p5b-1).ne.8)) THEN
      length = length + 1
      END IF
      END IF
      END IF
      END DO
      END DO
      END DO
      END DO
      IF (.not.MA_PUSH_GET(mt_int,2*length+1,'noname',l_a_offset,k_a_off
     &set)) CALL ERRQUIT('eomccsdt_x2_1_4_1',0,MA_ERR)
      int_mb(k_a_offset) = length
      addr = 0
      size = 0
      DO h6b = 1,noab
      DO h9b = h6b,noab
      DO h1b = 1,noab
      DO p5b = noab+1,noab+nvab
      IF (int_mb(k_spin+h6b-1)+int_mb(k_spin+h9b-1) .eq. int_mb(k_spin+h
     &1b-1)+int_mb(k_spin+p5b-1)) THEN
      IF (ieor(int_mb(k_sym+h6b-1),ieor(int_mb(k_sym+h9b-1),ieor(int_mb(
     &k_sym+h1b-1),int_mb(k_sym+p5b-1)))) .eq. irrep_v) THEN
      IF ((.not.restricted).or.(int_mb(k_spin+h6b-1)+int_mb(k_spin+h9b-1
     &)+int_mb(k_spin+h1b-1)+int_mb(k_spin+p5b-1).ne.8)) THEN
      addr = addr + 1
      int_mb(k_a_offset+addr) = p5b - noab - 1 + nvab * (h1b - 1 + noab 
     &* (h9b - 1 + noab * (h6b - 1)))
      int_mb(k_a_offset+length+addr) = size
      size = size + int_mb(k_range+h6b-1) * int_mb(k_range+h9b-1) * int_
     &mb(k_range+h1b-1) * int_mb(k_range+p5b-1)
      END IF
      END IF
      END IF
      END DO
      END DO
      END DO
      END DO
      RETURN
      END
      SUBROUTINE OFFSET_eomccsdt_x2a_14_1(l_a_offset,k_a_offset,size)
C     $Id$
C     This is a Fortran77 program generated by Tensor Contraction Engine v.1.0
C     Copyright (c) Battelle & Pacific Northwest National Laboratory (2002)
C     i1 ( h5 h6 h1 h2 )_vx
      IMPLICIT NONE
#include "global.fh"
#include "mafdecls.fh"
#include "sym.fh"
#include "errquit.fh"
#include "tce.fh"
      INTEGER l_a_offset
      INTEGER k_a_offset
      INTEGER size
      INTEGER length
      INTEGER addr
      INTEGER h5b
      INTEGER h6b
      INTEGER h1b
      INTEGER h2b
      length = 0
      DO h5b = 1,noab
      DO h6b = h5b,noab
      DO h1b = 1,noab
      DO h2b = h1b,noab
      IF (int_mb(k_spin+h5b-1)+int_mb(k_spin+h6b-1) .eq. int_mb(k_spin+h
     &1b-1)+int_mb(k_spin+h2b-1)) THEN
      IF (ieor(int_mb(k_sym+h5b-1),ieor(int_mb(k_sym+h6b-1),ieor(int_mb(
     &k_sym+h1b-1),int_mb(k_sym+h2b-1)))) .eq. ieor(irrep_v,irrep_x)) TH
     &EN
      IF ((.not.restricted).or.(int_mb(k_spin+h5b-1)+int_mb(k_spin+h6b-1
     &)+int_mb(k_spin+h1b-1)+int_mb(k_spin+h2b-1).ne.8)) THEN
      length = length + 1
      END IF
      END IF
      END IF
      END DO
      END DO
      END DO
      END DO
      IF (.not.MA_PUSH_GET(mt_int,2*length+1,'noname',l_a_offset,k_a_off
     &set)) CALL ERRQUIT('eomccsdt_x2_14_1',0,MA_ERR)
      int_mb(k_a_offset) = length
      addr = 0
      size = 0
      DO h5b = 1,noab
      DO h6b = h5b,noab
      DO h1b = 1,noab
      DO h2b = h1b,noab
      IF (int_mb(k_spin+h5b-1)+int_mb(k_spin+h6b-1) .eq. int_mb(k_spin+h
     &1b-1)+int_mb(k_spin+h2b-1)) THEN
      IF (ieor(int_mb(k_sym+h5b-1),ieor(int_mb(k_sym+h6b-1),ieor(int_mb(
     &k_sym+h1b-1),int_mb(k_sym+h2b-1)))) .eq. ieor(irrep_v,irrep_x)) TH
     &EN
      IF ((.not.restricted).or.(int_mb(k_spin+h5b-1)+int_mb(k_spin+h6b-1
     &)+int_mb(k_spin+h1b-1)+int_mb(k_spin+h2b-1).ne.8)) THEN
      addr = addr + 1
      int_mb(k_a_offset+addr) = h2b - 1 + noab * (h1b - 1 + noab * (h6b 
     &- 1 + noab * (h5b - 1)))
      int_mb(k_a_offset+length+addr) = size
      size = size + int_mb(k_range+h5b-1) * int_mb(k_range+h6b-1) * int_
     &mb(k_range+h1b-1) * int_mb(k_range+h2b-1)
      END IF
      END IF
      END IF
      END DO
      END DO
      END DO
      END DO
      RETURN
      END
      SUBROUTINE OFFSET_eomccsdt_x2a_14_3_1(l_a_offset,k_a_offset,size)
C     $Id$
C     This is a Fortran77 program generated by Tensor Contraction Engine v.1.0
C     Copyright (c) Battelle & Pacific Northwest National Laboratory (2002)
C     i2 ( h5 h6 h1 p7 )_vx
      IMPLICIT NONE
#include "global.fh"
#include "mafdecls.fh"
#include "sym.fh"
#include "errquit.fh"
#include "tce.fh"
      INTEGER l_a_offset
      INTEGER k_a_offset
      INTEGER size
      INTEGER length
      INTEGER addr
      INTEGER h5b
      INTEGER h6b
      INTEGER h1b
      INTEGER p7b
      length = 0
      DO h5b = 1,noab
      DO h6b = h5b,noab
      DO h1b = 1,noab
      DO p7b = noab+1,noab+nvab
      IF (int_mb(k_spin+h5b-1)+int_mb(k_spin+h6b-1) .eq. int_mb(k_spin+h
     &1b-1)+int_mb(k_spin+p7b-1)) THEN
      IF (ieor(int_mb(k_sym+h5b-1),ieor(int_mb(k_sym+h6b-1),ieor(int_mb(
     &k_sym+h1b-1),int_mb(k_sym+p7b-1)))) .eq. ieor(irrep_v,irrep_x)) TH
     &EN
      IF ((.not.restricted).or.(int_mb(k_spin+h5b-1)+int_mb(k_spin+h6b-1
     &)+int_mb(k_spin+h1b-1)+int_mb(k_spin+p7b-1).ne.8)) THEN
      length = length + 1
      END IF
      END IF
      END IF
      END DO
      END DO
      END DO
      END DO
      IF (.not.MA_PUSH_GET(mt_int,2*length+1,'noname',l_a_offset,k_a_off
     &set)) CALL ERRQUIT('eomccsdt_x2_14_3_1',0,MA_ERR)
      int_mb(k_a_offset) = length
      addr = 0
      size = 0
      DO h5b = 1,noab
      DO h6b = h5b,noab
      DO h1b = 1,noab
      DO p7b = noab+1,noab+nvab
      IF (int_mb(k_spin+h5b-1)+int_mb(k_spin+h6b-1) .eq. int_mb(k_spin+h
     &1b-1)+int_mb(k_spin+p7b-1)) THEN
      IF (ieor(int_mb(k_sym+h5b-1),ieor(int_mb(k_sym+h6b-1),ieor(int_mb(
     &k_sym+h1b-1),int_mb(k_sym+p7b-1)))) .eq. ieor(irrep_v,irrep_x)) TH
     &EN
      IF ((.not.restricted).or.(int_mb(k_spin+h5b-1)+int_mb(k_spin+h6b-1
     &)+int_mb(k_spin+h1b-1)+int_mb(k_spin+p7b-1).ne.8)) THEN
      addr = addr + 1
      int_mb(k_a_offset+addr) = p7b - noab - 1 + nvab * (h1b - 1 + noab 
     &* (h6b - 1 + noab * (h5b - 1)))
      int_mb(k_a_offset+length+addr) = size
      size = size + int_mb(k_range+h5b-1) * int_mb(k_range+h6b-1) * int_
     &mb(k_range+h1b-1) * int_mb(k_range+p7b-1)
      END IF
      END IF
      END IF
      END DO
      END DO
      END DO
      END DO
      RETURN
      END
      SUBROUTINE OFFSET_eomccsdt_x2a_15_1(l_a_offset,k_a_offset,size)
C     $Id$
C     This is a Fortran77 program generated by Tensor Contraction Engine v.1.0
C     Copyright (c) Battelle & Pacific Northwest National Laboratory (2002)
C     i1 ( p3 p5 )_vx
      IMPLICIT NONE
#include "global.fh"
#include "mafdecls.fh"
#include "sym.fh"
#include "errquit.fh"
#include "tce.fh"
      INTEGER l_a_offset
      INTEGER k_a_offset
      INTEGER size
      INTEGER length
      INTEGER addr
      INTEGER p3b
      INTEGER p5b
      length = 0
      DO p3b = noab+1,noab+nvab
      DO p5b = noab+1,noab+nvab
      IF (int_mb(k_spin+p3b-1) .eq. int_mb(k_spin+p5b-1)) THEN
      IF (ieor(int_mb(k_sym+p3b-1),int_mb(k_sym+p5b-1)) .eq. ieor(irrep_
     &v,irrep_x)) THEN
      IF ((.not.restricted).or.(int_mb(k_spin+p3b-1)+int_mb(k_spin+p5b-1
     &).ne.4)) THEN
      length = length + 1
      END IF
      END IF
      END IF
      END DO
      END DO
      IF (.not.MA_PUSH_GET(mt_int,2*length+1,'noname',l_a_offset,k_a_off
     &set)) CALL ERRQUIT('eomccsdt_x2_15_1',0,MA_ERR)
      int_mb(k_a_offset) = length
      addr = 0
      size = 0
      DO p3b = noab+1,noab+nvab
      DO p5b = noab+1,noab+nvab
      IF (int_mb(k_spin+p3b-1) .eq. int_mb(k_spin+p5b-1)) THEN
      IF (ieor(int_mb(k_sym+p3b-1),int_mb(k_sym+p5b-1)) .eq. ieor(irrep_
     &v,irrep_x)) THEN
      IF ((.not.restricted).or.(int_mb(k_spin+p3b-1)+int_mb(k_spin+p5b-1
     &).ne.4)) THEN
      addr = addr + 1
      int_mb(k_a_offset+addr) = p5b - noab - 1 + nvab * (p3b - noab - 1)
      int_mb(k_a_offset+length+addr) = size
      size = size + int_mb(k_range+p3b-1) * int_mb(k_range+p5b-1)
      END IF
      END IF
      END IF
      END DO
      END DO
      RETURN
      END
      SUBROUTINE OFFSET_eomccsdt_x2a_16_1(l_a_offset,k_a_offset,size)
C     $Id$
C     This is a Fortran77 program generated by Tensor Contraction Engine v.1.0
C     Copyright (c) Battelle & Pacific Northwest National Laboratory (2002)
C     i1 ( h6 p3 h1 p5 )_vx
      IMPLICIT NONE
#include "global.fh"
#include "mafdecls.fh"
#include "sym.fh"
#include "errquit.fh"
#include "tce.fh"
      INTEGER l_a_offset
      INTEGER k_a_offset
      INTEGER size
      INTEGER length
      INTEGER addr
      INTEGER p3b
      INTEGER h6b
      INTEGER h1b
      INTEGER p5b
      length = 0
      DO p3b = noab+1,noab+nvab
      DO h6b = 1,noab
      DO h1b = 1,noab
      DO p5b = noab+1,noab+nvab
      IF (int_mb(k_spin+h6b-1)+int_mb(k_spin+p3b-1) .eq. int_mb(k_spin+h
     &1b-1)+int_mb(k_spin+p5b-1)) THEN
      IF (ieor(int_mb(k_sym+h6b-1),ieor(int_mb(k_sym+p3b-1),ieor(int_mb(
     &k_sym+h1b-1),int_mb(k_sym+p5b-1)))) .eq. ieor(irrep_v,irrep_x)) TH
     &EN
      IF ((.not.restricted).or.(int_mb(k_spin+h6b-1)+int_mb(k_spin+p3b-1
     &)+int_mb(k_spin+h1b-1)+int_mb(k_spin+p5b-1).ne.8)) THEN
      length = length + 1
      END IF
      END IF
      END IF
      END DO
      END DO
      END DO
      END DO
      IF (.not.MA_PUSH_GET(mt_int,2*length+1,'noname',l_a_offset,k_a_off
     &set)) CALL ERRQUIT('eomccsdt_x2_16_1',0,MA_ERR)
      int_mb(k_a_offset) = length
      addr = 0
      size = 0
      DO p3b = noab+1,noab+nvab
      DO h6b = 1,noab
      DO h1b = 1,noab
      DO p5b = noab+1,noab+nvab
      IF (int_mb(k_spin+h6b-1)+int_mb(k_spin+p3b-1) .eq. int_mb(k_spin+h
     &1b-1)+int_mb(k_spin+p5b-1)) THEN
      IF (ieor(int_mb(k_sym+h6b-1),ieor(int_mb(k_sym+p3b-1),ieor(int_mb(
     &k_sym+h1b-1),int_mb(k_sym+p5b-1)))) .eq. ieor(irrep_v,irrep_x)) TH
     &EN
      IF ((.not.restricted).or.(int_mb(k_spin+h6b-1)+int_mb(k_spin+p3b-1
     &)+int_mb(k_spin+h1b-1)+int_mb(k_spin+p5b-1).ne.8)) THEN
      addr = addr + 1
      int_mb(k_a_offset+addr) = p5b - noab - 1 + nvab * (h1b - 1 + noab 
     &* (h6b - 1 + noab * (p3b - noab - 1)))
      int_mb(k_a_offset+length+addr) = size
      size = size + int_mb(k_range+p3b-1) * int_mb(k_range+h6b-1) * int_
     &mb(k_range+h1b-1) * int_mb(k_range+p5b-1)
      END IF
      END IF
      END IF
      END DO
      END DO
      END DO
      END DO
      RETURN
      END
      SUBROUTINE OFFSET_eomccsdt_x2a_17_1(l_a_offset,k_a_offset,size)
C     $Id$
C     This is a Fortran77 program generated by Tensor Contraction Engine v.1.0
C     Copyright (c) Battelle & Pacific Northwest National Laboratory (2002)
C     i1 ( h6 p5 )_vx
      IMPLICIT NONE
#include "global.fh"
#include "mafdecls.fh"
#include "sym.fh"
#include "errquit.fh"
#include "tce.fh"
      INTEGER l_a_offset
      INTEGER k_a_offset
      INTEGER size
      INTEGER length
      INTEGER addr
      INTEGER h6b
      INTEGER p5b
      LOGICAL ACOLO_1P_1H
      length = 0
      DO h6b = 1,noab
      DO p5b = noab+1,noab+nvab
      IF(acolo_1p_1h(p5b,h6b)) THEN
      IF (int_mb(k_spin+h6b-1) .eq. int_mb(k_spin+p5b-1)) THEN
      IF (ieor(int_mb(k_sym+h6b-1),int_mb(k_sym+p5b-1)) .eq. ieor(irrep_
     &v,irrep_x)) THEN
      IF ((.not.restricted).or.(int_mb(k_spin+h6b-1)+int_mb(k_spin+p5b-1
     &).ne.4)) THEN
      length = length + 1
      END IF
      END IF
      END IF
      END IF !active
      END DO
      END DO
      IF (.not.MA_PUSH_GET(mt_int,2*length+1,'noname',l_a_offset,k_a_off
     &set)) CALL ERRQUIT('eomccsdt_x2_17_1',0,MA_ERR)
      int_mb(k_a_offset) = length
      addr = 0
      size = 0
      DO h6b = 1,noab
      DO p5b = noab+1,noab+nvab
      IF(acolo_1p_1h(p5b,h6b)) THEN 
      IF (int_mb(k_spin+h6b-1) .eq. int_mb(k_spin+p5b-1)) THEN
      IF (ieor(int_mb(k_sym+h6b-1),int_mb(k_sym+p5b-1)) .eq. ieor(irrep_
     &v,irrep_x)) THEN
      IF ((.not.restricted).or.(int_mb(k_spin+h6b-1)+int_mb(k_spin+p5b-1
     &).ne.4)) THEN
      addr = addr + 1
      int_mb(k_a_offset+addr) = p5b - noab - 1 + nvab * (h6b - 1)
      int_mb(k_a_offset+length+addr) = size
      size = size + int_mb(k_range+h6b-1) * int_mb(k_range+p5b-1)
      END IF
      END IF
      END IF
      END IF !active
      END DO
      END DO
      RETURN
      END
      SUBROUTINE OFFSET_eomccsdt_x2a_18_1(l_a_offset,k_a_offset,size)
C     $Id$
C     This is a Fortran77 program generated by Tensor Contraction Engine v.1.0
C     Copyright (c) Battelle & Pacific Northwest National Laboratory (2002)
C     i1 ( h6 h7 h1 p5 )_vx
      IMPLICIT NONE
#include "global.fh"
#include "mafdecls.fh"
#include "sym.fh"
#include "errquit.fh"
#include "tce.fh"
      INTEGER l_a_offset
      INTEGER k_a_offset
      INTEGER size
      INTEGER length
      INTEGER addr
      INTEGER h6b
      INTEGER h7b
      INTEGER h1b
      INTEGER p5b
      LOGICAL ACOLO_1P_2H
      length = 0
      DO h6b = 1,noab
      DO h7b = h6b,noab
      DO h1b = 1,noab
      DO p5b = noab+1,noab+nvab
      IF(acolo_1p_2h(p5b,h6b,h7b)) THEN
      IF (int_mb(k_spin+h6b-1)+int_mb(k_spin+h7b-1) .eq. int_mb(k_spin+h
     &1b-1)+int_mb(k_spin+p5b-1)) THEN
      IF (ieor(int_mb(k_sym+h6b-1),ieor(int_mb(k_sym+h7b-1),ieor(int_mb(
     &k_sym+h1b-1),int_mb(k_sym+p5b-1)))) .eq. ieor(irrep_v,irrep_x)) TH
     &EN
      IF ((.not.restricted).or.(int_mb(k_spin+h6b-1)+int_mb(k_spin+h7b-1
     &)+int_mb(k_spin+h1b-1)+int_mb(k_spin+p5b-1).ne.8)) THEN
      length = length + 1
      END IF
      END IF
      END IF
      END IF !active
      END DO
      END DO
      END DO
      END DO
      IF (.not.MA_PUSH_GET(mt_int,2*length+1,'noname',l_a_offset,k_a_off
     &set)) CALL ERRQUIT('eomccsdt_x2_18_1',0,MA_ERR)
      int_mb(k_a_offset) = length
      addr = 0
      size = 0
      DO h6b = 1,noab
      DO h7b = h6b,noab
      DO h1b = 1,noab
      DO p5b = noab+1,noab+nvab
      IF(acolo_1p_2h(p5b,h6b,h7b)) THEN  
      IF (int_mb(k_spin+h6b-1)+int_mb(k_spin+h7b-1) .eq. int_mb(k_spin+h
     &1b-1)+int_mb(k_spin+p5b-1)) THEN
      IF (ieor(int_mb(k_sym+h6b-1),ieor(int_mb(k_sym+h7b-1),ieor(int_mb(
     &k_sym+h1b-1),int_mb(k_sym+p5b-1)))) .eq. ieor(irrep_v,irrep_x)) TH
     &EN
      IF ((.not.restricted).or.(int_mb(k_spin+h6b-1)+int_mb(k_spin+h7b-1
     &)+int_mb(k_spin+h1b-1)+int_mb(k_spin+p5b-1).ne.8)) THEN
      addr = addr + 1
      int_mb(k_a_offset+addr) = p5b - noab - 1 + nvab * (h1b - 1 + noab 
     &* (h7b - 1 + noab * (h6b - 1)))
      int_mb(k_a_offset+length+addr) = size
      size = size + int_mb(k_range+h6b-1) * int_mb(k_range+h7b-1) * int_
     &mb(k_range+h1b-1) * int_mb(k_range+p5b-1)
      END IF
      END IF
      END IF
      END IF !active
      END DO
      END DO
      END DO
      END DO
      RETURN
      END
      SUBROUTINE OFFSET_eomccsdt_x2a_3_1(l_a_offset,k_a_offset,size)
C     $Id$
C     This is a Fortran77 program generated by Tensor Contraction Engine v.1.0
C     Copyright (c) Battelle & Pacific Northwest National Laboratory (2002)
C     i1 ( h8 h1 )_f
      IMPLICIT NONE
#include "global.fh"
#include "mafdecls.fh"
#include "sym.fh"
#include "errquit.fh"
#include "tce.fh"
      INTEGER l_a_offset
      INTEGER k_a_offset
      INTEGER size
      INTEGER length
      INTEGER addr
      INTEGER h8b
      INTEGER h1b
      length = 0
      DO h8b = 1,noab
      DO h1b = 1,noab
      IF (int_mb(k_spin+h8b-1) .eq. int_mb(k_spin+h1b-1)) THEN
      IF (ieor(int_mb(k_sym+h8b-1),int_mb(k_sym+h1b-1)) .eq. irrep_f) TH
     &EN
      IF ((.not.restricted).or.(int_mb(k_spin+h8b-1)+int_mb(k_spin+h1b-1
     &).ne.4)) THEN
      length = length + 1
      END IF
      END IF
      END IF
      END DO
      END DO
      IF (.not.MA_PUSH_GET(mt_int,2*length+1,'noname',l_a_offset,k_a_off
     &set)) CALL ERRQUIT('eomccsdt_x2_3_1',0,MA_ERR)
      int_mb(k_a_offset) = length
      addr = 0
      size = 0
      DO h8b = 1,noab
      DO h1b = 1,noab
      IF (int_mb(k_spin+h8b-1) .eq. int_mb(k_spin+h1b-1)) THEN
      IF (ieor(int_mb(k_sym+h8b-1),int_mb(k_sym+h1b-1)) .eq. irrep_f) TH
     &EN
      IF ((.not.restricted).or.(int_mb(k_spin+h8b-1)+int_mb(k_spin+h1b-1
     &).ne.4)) THEN
      addr = addr + 1
      int_mb(k_a_offset+addr) = h1b - 1 + noab * (h8b - 1)
      int_mb(k_a_offset+length+addr) = size
      size = size + int_mb(k_range+h8b-1) * int_mb(k_range+h1b-1)
      END IF
      END IF
      END IF
      END DO
      END DO
      RETURN
      END
      SUBROUTINE OFFSET_eomccsdt_x2a_3_2_1(l_a_offset,k_a_offset,size)
C     $Id$
C     This is a Fortran77 program generated by Tensor Contraction Engine v.1.0
C     Copyright (c) Battelle & Pacific Northwest National Laboratory (2002)
C     i2 ( h8 p9 )_f
      IMPLICIT NONE
#include "global.fh"
#include "mafdecls.fh"
#include "sym.fh"
#include "errquit.fh"
#include "tce.fh"
      INTEGER l_a_offset
      INTEGER k_a_offset
      INTEGER size
      INTEGER length
      INTEGER addr
      INTEGER h8b
      INTEGER p9b
      length = 0
      DO h8b = 1,noab
      DO p9b = noab+1,noab+nvab
      IF (int_mb(k_spin+h8b-1) .eq. int_mb(k_spin+p9b-1)) THEN
      IF (ieor(int_mb(k_sym+h8b-1),int_mb(k_sym+p9b-1)) .eq. irrep_f) TH
     &EN
      IF ((.not.restricted).or.(int_mb(k_spin+h8b-1)+int_mb(k_spin+p9b-1
     &).ne.4)) THEN
      length = length + 1
      END IF
      END IF
      END IF
      END DO
      END DO
      IF (.not.MA_PUSH_GET(mt_int,2*length+1,'noname',l_a_offset,k_a_off
     &set)) CALL ERRQUIT('eomccsdt_x2_3_2_1',0,MA_ERR)
      int_mb(k_a_offset) = length
      addr = 0
      size = 0
      DO h8b = 1,noab
      DO p9b = noab+1,noab+nvab
      IF (int_mb(k_spin+h8b-1) .eq. int_mb(k_spin+p9b-1)) THEN
      IF (ieor(int_mb(k_sym+h8b-1),int_mb(k_sym+p9b-1)) .eq. irrep_f) TH
     &EN
      IF ((.not.restricted).or.(int_mb(k_spin+h8b-1)+int_mb(k_spin+p9b-1
     &).ne.4)) THEN
      addr = addr + 1
      int_mb(k_a_offset+addr) = p9b - noab - 1 + nvab * (h8b - 1)
      int_mb(k_a_offset+length+addr) = size
      size = size + int_mb(k_range+h8b-1) * int_mb(k_range+p9b-1)
      END IF
      END IF
      END IF
      END DO
      END DO
      RETURN
      END
      SUBROUTINE OFFSET_eomccsdt_x2a_4_1(l_a_offset,k_a_offset,size)
C     $Id$
C     This is a Fortran77 program generated by Tensor Contraction Engine v.1.0
C     Copyright (c) Battelle & Pacific Northwest National Laboratory (2002)
C     i1 ( p3 p8 )_f
      IMPLICIT NONE
#include "global.fh"
#include "mafdecls.fh"
#include "sym.fh"
#include "errquit.fh"
#include "tce.fh"
      INTEGER l_a_offset
      INTEGER k_a_offset
      INTEGER size
      INTEGER length
      INTEGER addr
      INTEGER p3b
      INTEGER p8b
      length = 0
      DO p3b = noab+1,noab+nvab
      DO p8b = noab+1,noab+nvab
      IF (int_mb(k_spin+p3b-1) .eq. int_mb(k_spin+p8b-1)) THEN
      IF (ieor(int_mb(k_sym+p3b-1),int_mb(k_sym+p8b-1)) .eq. irrep_f) TH
     &EN
      IF ((.not.restricted).or.(int_mb(k_spin+p3b-1)+int_mb(k_spin+p8b-1
     &).ne.4)) THEN
      length = length + 1
      END IF
      END IF
      END IF
      END DO
      END DO
      IF (.not.MA_PUSH_GET(mt_int,2*length+1,'noname',l_a_offset,k_a_off
     &set)) CALL ERRQUIT('eomccsdt_x2_4_1',0,MA_ERR)
      int_mb(k_a_offset) = length
      addr = 0
      size = 0
      DO p3b = noab+1,noab+nvab
      DO p8b = noab+1,noab+nvab
      IF (int_mb(k_spin+p3b-1) .eq. int_mb(k_spin+p8b-1)) THEN
      IF (ieor(int_mb(k_sym+p3b-1),int_mb(k_sym+p8b-1)) .eq. irrep_f) TH
     &EN
      IF ((.not.restricted).or.(int_mb(k_spin+p3b-1)+int_mb(k_spin+p8b-1
     &).ne.4)) THEN
      addr = addr + 1
      int_mb(k_a_offset+addr) = p8b - noab - 1 + nvab * (p3b - noab - 1)
      int_mb(k_a_offset+length+addr) = size
      size = size + int_mb(k_range+p3b-1) * int_mb(k_range+p8b-1)
      END IF
      END IF
      END IF
      END DO
      END DO
      RETURN
      END
      SUBROUTINE OFFSET_eomccsdt_x2a_5_1(l_a_offset,k_a_offset,size)
C     $Id$
C     This is a Fortran77 program generated by Tensor Contraction Engine v.1.0
C     Copyright (c) Battelle & Pacific Northwest National Laboratory (2002)
C     i1 ( h9 h10 h1 h2 )_v
      IMPLICIT NONE
#include "global.fh"
#include "mafdecls.fh"
#include "sym.fh"
#include "errquit.fh"
#include "tce.fh"
      INTEGER l_a_offset
      INTEGER k_a_offset
      INTEGER size
      INTEGER length
      INTEGER addr
      INTEGER h9b
      INTEGER h10b
      INTEGER h1b
      INTEGER h2b
      length = 0
      DO h9b = 1,noab
      DO h10b = h9b,noab
      DO h1b = 1,noab
      DO h2b = h1b,noab
      IF (int_mb(k_spin+h9b-1)+int_mb(k_spin+h10b-1) .eq. int_mb(k_spin+
     &h1b-1)+int_mb(k_spin+h2b-1)) THEN
      IF (ieor(int_mb(k_sym+h9b-1),ieor(int_mb(k_sym+h10b-1),ieor(int_mb
     &(k_sym+h1b-1),int_mb(k_sym+h2b-1)))) .eq. irrep_v) THEN
      IF ((.not.restricted).or.(int_mb(k_spin+h9b-1)+int_mb(k_spin+h10b-
     &1)+int_mb(k_spin+h1b-1)+int_mb(k_spin+h2b-1).ne.8)) THEN
      length = length + 1
      END IF
      END IF
      END IF
      END DO
      END DO
      END DO
      END DO
      IF (.not.MA_PUSH_GET(mt_int,2*length+1,'noname',l_a_offset,k_a_off
     &set)) CALL ERRQUIT('eomccsdt_x2_5_1',0,MA_ERR)
      int_mb(k_a_offset) = length
      addr = 0
      size = 0
      DO h9b = 1,noab
      DO h10b = h9b,noab
      DO h1b = 1,noab
      DO h2b = h1b,noab
      IF (int_mb(k_spin+h9b-1)+int_mb(k_spin+h10b-1) .eq. int_mb(k_spin+
     &h1b-1)+int_mb(k_spin+h2b-1)) THEN
      IF (ieor(int_mb(k_sym+h9b-1),ieor(int_mb(k_sym+h10b-1),ieor(int_mb
     &(k_sym+h1b-1),int_mb(k_sym+h2b-1)))) .eq. irrep_v) THEN
      IF ((.not.restricted).or.(int_mb(k_spin+h9b-1)+int_mb(k_spin+h10b-
     &1)+int_mb(k_spin+h1b-1)+int_mb(k_spin+h2b-1).ne.8)) THEN
      addr = addr + 1
      int_mb(k_a_offset+addr) = h2b - 1 + noab * (h1b - 1 + noab * (h10b
     & - 1 + noab * (h9b - 1)))
      int_mb(k_a_offset+length+addr) = size
      size = size + int_mb(k_range+h9b-1) * int_mb(k_range+h10b-1) * int
     &_mb(k_range+h1b-1) * int_mb(k_range+h2b-1)
      END IF
      END IF
      END IF
      END DO
      END DO
      END DO
      END DO
      RETURN
      END
      SUBROUTINE OFFSET_eomccsdt_x2a_5_2_1(l_a_offset,k_a_offset,size)
C     $Id$
C     This is a Fortran77 program generated by Tensor Contraction Engine v.1.0
C     Copyright (c) Battelle & Pacific Northwest National Laboratory (2002)
C     i2 ( h9 h10 h1 p5 )_v
      IMPLICIT NONE
#include "global.fh"
#include "mafdecls.fh"
#include "sym.fh"
#include "errquit.fh"
#include "tce.fh"
      INTEGER l_a_offset
      INTEGER k_a_offset
      INTEGER size
      INTEGER length
      INTEGER addr
      INTEGER h9b
      INTEGER h10b
      INTEGER h1b
      INTEGER p5b
      length = 0
      DO h9b = 1,noab
      DO h10b = h9b,noab
      DO h1b = 1,noab
      DO p5b = noab+1,noab+nvab
      IF (int_mb(k_spin+h9b-1)+int_mb(k_spin+h10b-1) .eq. int_mb(k_spin+
     &h1b-1)+int_mb(k_spin+p5b-1)) THEN
      IF (ieor(int_mb(k_sym+h9b-1),ieor(int_mb(k_sym+h10b-1),ieor(int_mb
     &(k_sym+h1b-1),int_mb(k_sym+p5b-1)))) .eq. irrep_v) THEN
      IF ((.not.restricted).or.(int_mb(k_spin+h9b-1)+int_mb(k_spin+h10b-
     &1)+int_mb(k_spin+h1b-1)+int_mb(k_spin+p5b-1).ne.8)) THEN
      length = length + 1
      END IF
      END IF
      END IF
      END DO
      END DO
      END DO
      END DO
      IF (.not.MA_PUSH_GET(mt_int,2*length+1,'noname',l_a_offset,k_a_off
     &set)) CALL ERRQUIT('eomccsdt_x2_5_2_1',0,MA_ERR)
      int_mb(k_a_offset) = length
      addr = 0
      size = 0
      DO h9b = 1,noab
      DO h10b = h9b,noab
      DO h1b = 1,noab
      DO p5b = noab+1,noab+nvab
      IF (int_mb(k_spin+h9b-1)+int_mb(k_spin+h10b-1) .eq. int_mb(k_spin+
     &h1b-1)+int_mb(k_spin+p5b-1)) THEN
      IF (ieor(int_mb(k_sym+h9b-1),ieor(int_mb(k_sym+h10b-1),ieor(int_mb
     &(k_sym+h1b-1),int_mb(k_sym+p5b-1)))) .eq. irrep_v) THEN
      IF ((.not.restricted).or.(int_mb(k_spin+h9b-1)+int_mb(k_spin+h10b-
     &1)+int_mb(k_spin+h1b-1)+int_mb(k_spin+p5b-1).ne.8)) THEN
      addr = addr + 1
      int_mb(k_a_offset+addr) = p5b - noab - 1 + nvab * (h1b - 1 + noab 
     &* (h10b - 1 + noab * (h9b - 1)))
      int_mb(k_a_offset+length+addr) = size
      size = size + int_mb(k_range+h9b-1) * int_mb(k_range+h10b-1) * int
     &_mb(k_range+h1b-1) * int_mb(k_range+p5b-1)
      END IF
      END IF
      END IF
      END DO
      END DO
      END DO
      END DO
      RETURN
      END
      SUBROUTINE OFFSET_eomccsdt_x2a_6_1(l_a_offset,k_a_offset,size)
C     $Id$
C     This is a Fortran77 program generated by Tensor Contraction Engine v.1.0
C     Copyright (c) Battelle & Pacific Northwest National Laboratory (2002)
C     i1 ( h7 p3 h1 p8 )_v
      IMPLICIT NONE
#include "global.fh"
#include "mafdecls.fh"
#include "sym.fh"
#include "errquit.fh"
#include "tce.fh"
      INTEGER l_a_offset
      INTEGER k_a_offset
      INTEGER size
      INTEGER length
      INTEGER addr
      INTEGER p3b
      INTEGER h7b
      INTEGER h1b
      INTEGER p8b
      length = 0
      DO p3b = noab+1,noab+nvab
      DO h7b = 1,noab
      DO h1b = 1,noab
      DO p8b = noab+1,noab+nvab
      IF (int_mb(k_spin+h7b-1)+int_mb(k_spin+p3b-1) .eq. int_mb(k_spin+h
     &1b-1)+int_mb(k_spin+p8b-1)) THEN
      IF (ieor(int_mb(k_sym+h7b-1),ieor(int_mb(k_sym+p3b-1),ieor(int_mb(
     &k_sym+h1b-1),int_mb(k_sym+p8b-1)))) .eq. irrep_v) THEN
      IF ((.not.restricted).or.(int_mb(k_spin+h7b-1)+int_mb(k_spin+p3b-1
     &)+int_mb(k_spin+h1b-1)+int_mb(k_spin+p8b-1).ne.8)) THEN
      length = length + 1
      END IF
      END IF
      END IF
      END DO
      END DO
      END DO
      END DO
      IF (.not.MA_PUSH_GET(mt_int,2*length+1,'noname',l_a_offset,k_a_off
     &set)) CALL ERRQUIT('eomccsdt_x2_6_1',0,MA_ERR)
      int_mb(k_a_offset) = length
      addr = 0
      size = 0
      DO p3b = noab+1,noab+nvab
      DO h7b = 1,noab
      DO h1b = 1,noab
      DO p8b = noab+1,noab+nvab
      IF (int_mb(k_spin+h7b-1)+int_mb(k_spin+p3b-1) .eq. int_mb(k_spin+h
     &1b-1)+int_mb(k_spin+p8b-1)) THEN
      IF (ieor(int_mb(k_sym+h7b-1),ieor(int_mb(k_sym+p3b-1),ieor(int_mb(
     &k_sym+h1b-1),int_mb(k_sym+p8b-1)))) .eq. irrep_v) THEN
      IF ((.not.restricted).or.(int_mb(k_spin+h7b-1)+int_mb(k_spin+p3b-1
     &)+int_mb(k_spin+h1b-1)+int_mb(k_spin+p8b-1).ne.8)) THEN
      addr = addr + 1
      int_mb(k_a_offset+addr) = p8b - noab - 1 + nvab * (h1b - 1 + noab 
     &* (h7b - 1 + noab * (p3b - noab - 1)))
      int_mb(k_a_offset+length+addr) = size
      size = size + int_mb(k_range+p3b-1) * int_mb(k_range+h7b-1) * int_
     &mb(k_range+h1b-1) * int_mb(k_range+p8b-1)
      END IF
      END IF
      END IF
      END DO
      END DO
      END DO
      END DO
      RETURN
      END
      SUBROUTINE OFFSET_eomccsdt_x2a_8_1(l_a_offset,k_a_offset,size)
C     $Id$
C     This is a Fortran77 program generated by Tensor Contraction Engine v.1.0
C     Copyright (c) Battelle & Pacific Northwest National Laboratory (2002)
C     i1 ( h8 p9 )_f
      IMPLICIT NONE
#include "global.fh"
#include "mafdecls.fh"
#include "sym.fh"
#include "errquit.fh"
#include "tce.fh"
      INTEGER l_a_offset
      INTEGER k_a_offset
      INTEGER size
      INTEGER length
      INTEGER addr
      INTEGER h8b
      INTEGER p9b
      LOGICAL ACOLO_1P_1H
      length = 0
      DO h8b = 1,noab
      DO p9b = noab+1,noab+nvab
      IF(acolo_1p_1h(p9b,h8b)) THEN
      IF (int_mb(k_spin+h8b-1) .eq. int_mb(k_spin+p9b-1)) THEN
      IF (ieor(int_mb(k_sym+h8b-1),int_mb(k_sym+p9b-1)) .eq. irrep_f) TH
     &EN
      IF ((.not.restricted).or.(int_mb(k_spin+h8b-1)+int_mb(k_spin+p9b-1
     &).ne.4)) THEN
      length = length + 1
      END IF
      END IF
      END IF
      END IF !active
      END DO
      END DO
      IF (.not.MA_PUSH_GET(mt_int,2*length+1,'noname',l_a_offset,k_a_off
     &set)) CALL ERRQUIT('eomccsdt_x2_8_1',0,MA_ERR)
      int_mb(k_a_offset) = length
      addr = 0
      size = 0
      DO h8b = 1,noab
      DO p9b = noab+1,noab+nvab
      IF(acolo_1p_1h(p9b,h8b)) THEN   
      IF (int_mb(k_spin+h8b-1) .eq. int_mb(k_spin+p9b-1)) THEN
      IF (ieor(int_mb(k_sym+h8b-1),int_mb(k_sym+p9b-1)) .eq. irrep_f) TH
     &EN
      IF ((.not.restricted).or.(int_mb(k_spin+h8b-1)+int_mb(k_spin+p9b-1
     &).ne.4)) THEN
      addr = addr + 1
      int_mb(k_a_offset+addr) = p9b - noab - 1 + nvab * (h8b - 1)
      int_mb(k_a_offset+length+addr) = size
      size = size + int_mb(k_range+h8b-1) * int_mb(k_range+p9b-1)
      END IF
      END IF
      END IF
      END IF !active
      END DO
      END DO
      RETURN
      END
      SUBROUTINE OFFSET_eomccsdt_x2a_9_1(l_a_offset,k_a_offset,size)
C     $Id$
C     This is a Fortran77 program generated by Tensor Contraction Engine v.1.0
C     Copyright (c) Battelle & Pacific Northwest National Laboratory (2002)
C     i1 ( h8 h10 h1 p9 )_v
      IMPLICIT NONE
#include "global.fh"
#include "mafdecls.fh"
#include "sym.fh"
#include "errquit.fh"
#include "tce.fh"
      INTEGER l_a_offset
      INTEGER k_a_offset
      INTEGER size
      INTEGER length
      INTEGER addr
      INTEGER h8b
      INTEGER h10b
      INTEGER h1b
      INTEGER p9b
      LOGICAL ACOLO_1P,ACOLO_2H
      length = 0
      DO h8b = 1,noab
      DO h10b = h8b,noab
      DO h1b = 1,noab
      DO p9b = noab+1,noab+nvab
      IF(acolo_1p(p9b).AND.acolo_2h(h8b,h10b)) THEN
      IF (int_mb(k_spin+h8b-1)+int_mb(k_spin+h10b-1) .eq. int_mb(k_spin+
     &h1b-1)+int_mb(k_spin+p9b-1)) THEN
      IF (ieor(int_mb(k_sym+h8b-1),ieor(int_mb(k_sym+h10b-1),ieor(int_mb
     &(k_sym+h1b-1),int_mb(k_sym+p9b-1)))) .eq. irrep_v) THEN
      IF ((.not.restricted).or.(int_mb(k_spin+h8b-1)+int_mb(k_spin+h10b-
     &1)+int_mb(k_spin+h1b-1)+int_mb(k_spin+p9b-1).ne.8)) THEN
      length = length + 1
      END IF
      END IF
      END IF
      END IF !active
      END DO
      END DO
      END DO
      END DO
      IF (.not.MA_PUSH_GET(mt_int,2*length+1,'noname',l_a_offset,k_a_off
     &set)) CALL ERRQUIT('eomccsdt_x2_9_1',0,MA_ERR)
      int_mb(k_a_offset) = length
      addr = 0
      size = 0
      DO h8b = 1,noab
      DO h10b = h8b,noab
      DO h1b = 1,noab
      DO p9b = noab+1,noab+nvab
      IF(acolo_1p(p9b).AND.acolo_2h(h8b,h10b)) THEN  
      IF (int_mb(k_spin+h8b-1)+int_mb(k_spin+h10b-1) .eq. int_mb(k_spin+
     &h1b-1)+int_mb(k_spin+p9b-1)) THEN
      IF (ieor(int_mb(k_sym+h8b-1),ieor(int_mb(k_sym+h10b-1),ieor(int_mb
     &(k_sym+h1b-1),int_mb(k_sym+p9b-1)))) .eq. irrep_v) THEN
      IF ((.not.restricted).or.(int_mb(k_spin+h8b-1)+int_mb(k_spin+h10b-
     &1)+int_mb(k_spin+h1b-1)+int_mb(k_spin+p9b-1).ne.8)) THEN
      addr = addr + 1
      int_mb(k_a_offset+addr) = p9b - noab - 1 + nvab * (h1b - 1 + noab 
     &* (h10b - 1 + noab * (h8b - 1)))
      int_mb(k_a_offset+length+addr) = size
      size = size + int_mb(k_range+h8b-1) * int_mb(k_range+h10b-1) * int
     &_mb(k_range+h1b-1) * int_mb(k_range+p9b-1)
      END IF
      END IF
      END IF
      END IF !active 
      END DO
      END DO
      END DO
      END DO
      RETURN
      END
      SUBROUTINE OFFSET_eomccsdt_x3_10_1_1(l_a_offset,k_a_offset,size)
C     $Id$
C     This is a Fortran77 program generated by Tensor Contraction Engine v.1.0
C     Copyright (c) Battelle & Pacific Northwest National Laboratory (2002)
C     i2 ( h11 p4 h1 p7 )_v
      IMPLICIT NONE
#include "global.fh"
#include "mafdecls.fh"
#include "sym.fh"
#include "errquit.fh"
#include "tce.fh"
      INTEGER l_a_offset
      INTEGER k_a_offset
      INTEGER size
      INTEGER length
      INTEGER addr
      INTEGER p4b
      INTEGER h11b
      INTEGER h1b
      INTEGER p7b
      length = 0
      DO p4b = noab+1,noab+nvab
      DO h11b = 1,noab
      DO h1b = 1,noab
      DO p7b = noab+1,noab+nvab
      IF (int_mb(k_spin+h11b-1)+int_mb(k_spin+p4b-1) .eq. int_mb(k_spin+
     &h1b-1)+int_mb(k_spin+p7b-1)) THEN
      IF (ieor(int_mb(k_sym+h11b-1),ieor(int_mb(k_sym+p4b-1),ieor(int_mb
     &(k_sym+h1b-1),int_mb(k_sym+p7b-1)))) .eq. irrep_v) THEN
      IF ((.not.restricted).or.(int_mb(k_spin+h11b-1)+int_mb(k_spin+p4b-
     &1)+int_mb(k_spin+h1b-1)+int_mb(k_spin+p7b-1).ne.8)) THEN
      length = length + 1
      END IF
      END IF
      END IF
      END DO
      END DO
      END DO
      END DO
      IF (.not.MA_PUSH_GET(mt_int,2*length+1,'noname',l_a_offset,k_a_off
     &set)) CALL ERRQUIT('eomccsdt_x3_10_1_1',0,MA_ERR)
      int_mb(k_a_offset) = length
      addr = 0
      size = 0
      DO p4b = noab+1,noab+nvab
      DO h11b = 1,noab
      DO h1b = 1,noab
      DO p7b = noab+1,noab+nvab
      IF (int_mb(k_spin+h11b-1)+int_mb(k_spin+p4b-1) .eq. int_mb(k_spin+
     &h1b-1)+int_mb(k_spin+p7b-1)) THEN
      IF (ieor(int_mb(k_sym+h11b-1),ieor(int_mb(k_sym+p4b-1),ieor(int_mb
     &(k_sym+h1b-1),int_mb(k_sym+p7b-1)))) .eq. irrep_v) THEN
      IF ((.not.restricted).or.(int_mb(k_spin+h11b-1)+int_mb(k_spin+p4b-
     &1)+int_mb(k_spin+h1b-1)+int_mb(k_spin+p7b-1).ne.8)) THEN
      addr = addr + 1
      int_mb(k_a_offset+addr) = p7b - noab - 1 + nvab * (h1b - 1 + noab 
     &* (h11b - 1 + noab * (p4b - noab - 1)))
      int_mb(k_a_offset+length+addr) = size
      size = size + int_mb(k_range+p4b-1) * int_mb(k_range+h11b-1) * int
     &_mb(k_range+h1b-1) * int_mb(k_range+p7b-1)
      END IF
      END IF
      END IF
      END DO
      END DO
      END DO
      END DO
      RETURN
      END
      SUBROUTINE OFFSET_eomccsdt_x3_10_1(l_a_offset,k_a_offset,size)
C     $Id$
C     This is a Fortran77 program generated by Tensor Contraction Engine v.1.0
C     Copyright (c) Battelle & Pacific Northwest National Laboratory (2002)
C     i1 ( h11 p4 p5 h1 h2 h3 )_vt
      IMPLICIT NONE
#include "global.fh"
#include "mafdecls.fh"
#include "sym.fh"
#include "errquit.fh"
#include "tce.fh"
      INTEGER l_a_offset
      INTEGER k_a_offset
      INTEGER size
      INTEGER length
      INTEGER addr
      INTEGER p4b
      INTEGER p5b
      INTEGER h11b
      INTEGER h1b
      INTEGER h2b
      INTEGER h3b
      length = 0
      DO p4b = noab+1,noab+nvab
      DO p5b = p4b,noab+nvab
      DO h11b = 1,noab
      DO h1b = 1,noab
      DO h2b = h1b,noab
      DO h3b = h2b,noab
      IF (int_mb(k_spin+h11b-1)+int_mb(k_spin+p4b-1)+int_mb(k_spin+p5b-1
     &) .eq. int_mb(k_spin+h1b-1)+int_mb(k_spin+h2b-1)+int_mb(k_spin+h3b
     &-1)) THEN
      IF (ieor(int_mb(k_sym+h11b-1),ieor(int_mb(k_sym+p4b-1),ieor(int_mb
     &(k_sym+p5b-1),ieor(int_mb(k_sym+h1b-1),ieor(int_mb(k_sym+h2b-1),in
     &t_mb(k_sym+h3b-1)))))) .eq. ieor(irrep_v,irrep_t)) THEN
      IF ((.not.restricted).or.(int_mb(k_spin+h11b-1)+int_mb(k_spin+p4b-
     &1)+int_mb(k_spin+p5b-1)+int_mb(k_spin+h1b-1)+int_mb(k_spin+h2b-1)+
     &int_mb(k_spin+h3b-1).ne.12)) THEN
      length = length + 1
      END IF
      END IF
      END IF
      END DO
      END DO
      END DO
      END DO
      END DO
      END DO
      IF (.not.MA_PUSH_GET(mt_int,2*length+1,'noname',l_a_offset,k_a_off
     &set)) CALL ERRQUIT('eomccsdt_x3_10_1',0,MA_ERR)
      int_mb(k_a_offset) = length
      addr = 0
      size = 0
      DO p4b = noab+1,noab+nvab
      DO p5b = p4b,noab+nvab
      DO h11b = 1,noab
      DO h1b = 1,noab
      DO h2b = h1b,noab
      DO h3b = h2b,noab
      IF (int_mb(k_spin+h11b-1)+int_mb(k_spin+p4b-1)+int_mb(k_spin+p5b-1
     &) .eq. int_mb(k_spin+h1b-1)+int_mb(k_spin+h2b-1)+int_mb(k_spin+h3b
     &-1)) THEN
      IF (ieor(int_mb(k_sym+h11b-1),ieor(int_mb(k_sym+p4b-1),ieor(int_mb
     &(k_sym+p5b-1),ieor(int_mb(k_sym+h1b-1),ieor(int_mb(k_sym+h2b-1),in
     &t_mb(k_sym+h3b-1)))))) .eq. ieor(irrep_v,irrep_t)) THEN
      IF ((.not.restricted).or.(int_mb(k_spin+h11b-1)+int_mb(k_spin+p4b-
     &1)+int_mb(k_spin+p5b-1)+int_mb(k_spin+h1b-1)+int_mb(k_spin+h2b-1)+
     &int_mb(k_spin+h3b-1).ne.12)) THEN
      addr = addr + 1
      int_mb(k_a_offset+addr) = h3b - 1 + noab * (h2b - 1 + noab * (h1b 
     &- 1 + noab * (h11b - 1 + noab * (p5b - noab - 1 + nvab * (p4b - no
     &ab - 1)))))
      int_mb(k_a_offset+length+addr) = size
      size = size + int_mb(k_range+p4b-1) * int_mb(k_range+p5b-1) * int_
     &mb(k_range+h11b-1) * int_mb(k_range+h1b-1) * int_mb(k_range+h2b-1)
     & * int_mb(k_range+h3b-1)
      END IF
      END IF
      END IF
      END DO
      END DO
      END DO
      END DO
      END DO
      END DO
      RETURN
      END
      SUBROUTINE OFFSET_eomccsdt_x3_10_2_1(l_a_offset,k_a_offset,size)
C     $Id$
C     This is a Fortran77 program generated by Tensor Contraction Engine v.1.0
C     Copyright (c) Battelle & Pacific Northwest National Laboratory (2002)
C     i2 ( h11 p10 )_f
      IMPLICIT NONE
#include "global.fh"
#include "mafdecls.fh"
#include "sym.fh"
#include "errquit.fh"
#include "tce.fh"
      INTEGER l_a_offset
      INTEGER k_a_offset
      INTEGER size
      INTEGER length
      INTEGER addr
      INTEGER h11b
      INTEGER p10b
      length = 0
      DO h11b = 1,noab
      DO p10b = noab+1,noab+nvab
      IF (int_mb(k_spin+h11b-1) .eq. int_mb(k_spin+p10b-1)) THEN
      IF (ieor(int_mb(k_sym+h11b-1),int_mb(k_sym+p10b-1)) .eq. irrep_f) 
     &THEN
      IF ((.not.restricted).or.(int_mb(k_spin+h11b-1)+int_mb(k_spin+p10b
     &-1).ne.4)) THEN
      length = length + 1
      END IF
      END IF
      END IF
      END DO
      END DO
      IF (.not.MA_PUSH_GET(mt_int,2*length+1,'noname',l_a_offset,k_a_off
     &set)) CALL ERRQUIT('eomccsdt_x3_10_2_1',0,MA_ERR)
      int_mb(k_a_offset) = length
      addr = 0
      size = 0
      DO h11b = 1,noab
      DO p10b = noab+1,noab+nvab
      IF (int_mb(k_spin+h11b-1) .eq. int_mb(k_spin+p10b-1)) THEN
      IF (ieor(int_mb(k_sym+h11b-1),int_mb(k_sym+p10b-1)) .eq. irrep_f) 
     &THEN
      IF ((.not.restricted).or.(int_mb(k_spin+h11b-1)+int_mb(k_spin+p10b
     &-1).ne.4)) THEN
      addr = addr + 1
      int_mb(k_a_offset+addr) = p10b - noab - 1 + nvab * (h11b - 1)
      int_mb(k_a_offset+length+addr) = size
      size = size + int_mb(k_range+h11b-1) * int_mb(k_range+p10b-1)
      END IF
      END IF
      END IF
      END DO
      END DO
      RETURN
      END
      SUBROUTINE OFFSET_eomccsdt_x3_10_3_1(l_a_offset,k_a_offset,size)
C     $Id$
C     This is a Fortran77 program generated by Tensor Contraction Engine v.1.0
C     Copyright (c) Battelle & Pacific Northwest National Laboratory (2002)
C     i2 ( h8 h11 h1 p7 )_v
      IMPLICIT NONE
#include "global.fh"
#include "mafdecls.fh"
#include "sym.fh"
#include "errquit.fh"
#include "tce.fh"
      INTEGER l_a_offset
      INTEGER k_a_offset
      INTEGER size
      INTEGER length
      INTEGER addr
      INTEGER h8b
      INTEGER h11b
      INTEGER h1b
      INTEGER p7b
      length = 0
      DO h8b = 1,noab
      DO h11b = h8b,noab
      DO h1b = 1,noab
      DO p7b = noab+1,noab+nvab
      IF (int_mb(k_spin+h8b-1)+int_mb(k_spin+h11b-1) .eq. int_mb(k_spin+
     &h1b-1)+int_mb(k_spin+p7b-1)) THEN
      IF (ieor(int_mb(k_sym+h8b-1),ieor(int_mb(k_sym+h11b-1),ieor(int_mb
     &(k_sym+h1b-1),int_mb(k_sym+p7b-1)))) .eq. irrep_v) THEN
      IF ((.not.restricted).or.(int_mb(k_spin+h8b-1)+int_mb(k_spin+h11b-
     &1)+int_mb(k_spin+h1b-1)+int_mb(k_spin+p7b-1).ne.8)) THEN
      length = length + 1
      END IF
      END IF
      END IF
      END DO
      END DO
      END DO
      END DO
      IF (.not.MA_PUSH_GET(mt_int,2*length+1,'noname',l_a_offset,k_a_off
     &set)) CALL ERRQUIT('eomccsdt_x3_10_3_1',0,MA_ERR)
      int_mb(k_a_offset) = length
      addr = 0
      size = 0
      DO h8b = 1,noab
      DO h11b = h8b,noab
      DO h1b = 1,noab
      DO p7b = noab+1,noab+nvab
      IF (int_mb(k_spin+h8b-1)+int_mb(k_spin+h11b-1) .eq. int_mb(k_spin+
     &h1b-1)+int_mb(k_spin+p7b-1)) THEN
      IF (ieor(int_mb(k_sym+h8b-1),ieor(int_mb(k_sym+h11b-1),ieor(int_mb
     &(k_sym+h1b-1),int_mb(k_sym+p7b-1)))) .eq. irrep_v) THEN
      IF ((.not.restricted).or.(int_mb(k_spin+h8b-1)+int_mb(k_spin+h11b-
     &1)+int_mb(k_spin+h1b-1)+int_mb(k_spin+p7b-1).ne.8)) THEN
      addr = addr + 1
      int_mb(k_a_offset+addr) = p7b - noab - 1 + nvab * (h1b - 1 + noab 
     &* (h11b - 1 + noab * (h8b - 1)))
      int_mb(k_a_offset+length+addr) = size
      size = size + int_mb(k_range+h8b-1) * int_mb(k_range+h11b-1) * int
     &_mb(k_range+h1b-1) * int_mb(k_range+p7b-1)
      END IF
      END IF
      END IF
      END DO
      END DO
      END DO
      END DO
      RETURN
      END
      SUBROUTINE OFFSET_eomccsdt_x3_11_1(l_a_offset,k_a_offset,size)
C     $Id$
C     This is a Fortran77 program generated by Tensor Contraction Engine v.1.0
C     Copyright (c) Battelle & Pacific Northwest National Laboratory (2002)
C     i1 ( p4 p5 h1 p7 )_vx
      IMPLICIT NONE
#include "global.fh"
#include "mafdecls.fh"
#include "sym.fh"
#include "errquit.fh"
#include "tce.fh"
      INTEGER l_a_offset
      INTEGER k_a_offset
      INTEGER size
      INTEGER length
      INTEGER addr
      INTEGER p4b
      INTEGER p5b
      INTEGER h1b
      INTEGER p7b
      length = 0
      DO p4b = noab+1,noab+nvab
      DO p5b = p4b,noab+nvab
      DO h1b = 1,noab
      DO p7b = noab+1,noab+nvab
      IF (int_mb(k_spin+p4b-1)+int_mb(k_spin+p5b-1) .eq. int_mb(k_spin+h
     &1b-1)+int_mb(k_spin+p7b-1)) THEN
      IF (ieor(int_mb(k_sym+p4b-1),ieor(int_mb(k_sym+p5b-1),ieor(int_mb(
     &k_sym+h1b-1),int_mb(k_sym+p7b-1)))) .eq. ieor(irrep_v,irrep_x)) TH
     &EN
      IF ((.not.restricted).or.(int_mb(k_spin+p4b-1)+int_mb(k_spin+p5b-1
     &)+int_mb(k_spin+h1b-1)+int_mb(k_spin+p7b-1).ne.8)) THEN
      length = length + 1
      END IF
      END IF
      END IF
      END DO
      END DO
      END DO
      END DO
      IF (.not.MA_PUSH_GET(mt_int,2*length+1,'noname',l_a_offset,k_a_off
     &set)) CALL ERRQUIT('eomccsdt_x3_11_1',0,MA_ERR)
      int_mb(k_a_offset) = length
      addr = 0
      size = 0
      DO p4b = noab+1,noab+nvab
      DO p5b = p4b,noab+nvab
      DO h1b = 1,noab
      DO p7b = noab+1,noab+nvab
      IF (int_mb(k_spin+p4b-1)+int_mb(k_spin+p5b-1) .eq. int_mb(k_spin+h
     &1b-1)+int_mb(k_spin+p7b-1)) THEN
      IF (ieor(int_mb(k_sym+p4b-1),ieor(int_mb(k_sym+p5b-1),ieor(int_mb(
     &k_sym+h1b-1),int_mb(k_sym+p7b-1)))) .eq. ieor(irrep_v,irrep_x)) TH
     &EN
      IF ((.not.restricted).or.(int_mb(k_spin+p4b-1)+int_mb(k_spin+p5b-1
     &)+int_mb(k_spin+h1b-1)+int_mb(k_spin+p7b-1).ne.8)) THEN
      addr = addr + 1
      int_mb(k_a_offset+addr) = p7b - noab - 1 + nvab * (h1b - 1 + noab 
     &* (p5b - noab - 1 + nvab * (p4b - noab - 1)))
      int_mb(k_a_offset+length+addr) = size
      size = size + int_mb(k_range+p4b-1) * int_mb(k_range+p5b-1) * int_
     &mb(k_range+h1b-1) * int_mb(k_range+p7b-1)
      END IF
      END IF
      END IF
      END DO
      END DO
      END DO
      END DO
      RETURN
      END
      SUBROUTINE OFFSET_eomccsdt_x3_11_2_1(l_a_offset,k_a_offset,size)
C     $Id$
C     This is a Fortran77 program generated by Tensor Contraction Engine v.1.0
C     Copyright (c) Battelle & Pacific Northwest National Laboratory (2002)
C     i2 ( h11 h12 h1 p7 )_v
      IMPLICIT NONE
#include "global.fh"
#include "mafdecls.fh"
#include "sym.fh"
#include "errquit.fh"
#include "tce.fh"
      INTEGER l_a_offset
      INTEGER k_a_offset
      INTEGER size
      INTEGER length
      INTEGER addr
      INTEGER h11b
      INTEGER h12b
      INTEGER h1b
      INTEGER p7b
      length = 0
      DO h11b = 1,noab
      DO h12b = h11b,noab
      DO h1b = 1,noab
      DO p7b = noab+1,noab+nvab
      IF (int_mb(k_spin+h11b-1)+int_mb(k_spin+h12b-1) .eq. int_mb(k_spin
     &+h1b-1)+int_mb(k_spin+p7b-1)) THEN
      IF (ieor(int_mb(k_sym+h11b-1),ieor(int_mb(k_sym+h12b-1),ieor(int_m
     &b(k_sym+h1b-1),int_mb(k_sym+p7b-1)))) .eq. irrep_v) THEN
      IF ((.not.restricted).or.(int_mb(k_spin+h11b-1)+int_mb(k_spin+h12b
     &-1)+int_mb(k_spin+h1b-1)+int_mb(k_spin+p7b-1).ne.8)) THEN
      length = length + 1
      END IF
      END IF
      END IF
      END DO
      END DO
      END DO
      END DO
      IF (.not.MA_PUSH_GET(mt_int,2*length+1,'noname',l_a_offset,k_a_off
     &set)) CALL ERRQUIT('eomccsdt_x3_11_2_1',0,MA_ERR)
      int_mb(k_a_offset) = length
      addr = 0
      size = 0
      DO h11b = 1,noab
      DO h12b = h11b,noab
      DO h1b = 1,noab
      DO p7b = noab+1,noab+nvab
      IF (int_mb(k_spin+h11b-1)+int_mb(k_spin+h12b-1) .eq. int_mb(k_spin
     &+h1b-1)+int_mb(k_spin+p7b-1)) THEN
      IF (ieor(int_mb(k_sym+h11b-1),ieor(int_mb(k_sym+h12b-1),ieor(int_m
     &b(k_sym+h1b-1),int_mb(k_sym+p7b-1)))) .eq. irrep_v) THEN
      IF ((.not.restricted).or.(int_mb(k_spin+h11b-1)+int_mb(k_spin+h12b
     &-1)+int_mb(k_spin+h1b-1)+int_mb(k_spin+p7b-1).ne.8)) THEN
      addr = addr + 1
      int_mb(k_a_offset+addr) = p7b - noab - 1 + nvab * (h1b - 1 + noab 
     &* (h12b - 1 + noab * (h11b - 1)))
      int_mb(k_a_offset+length+addr) = size
      size = size + int_mb(k_range+h11b-1) * int_mb(k_range+h12b-1) * in
     &t_mb(k_range+h1b-1) * int_mb(k_range+p7b-1)
      END IF
      END IF
      END IF
      END DO
      END DO
      END DO
      END DO
      RETURN
      END
      SUBROUTINE OFFSET_eomccsdt_x3_11_5_1(l_a_offset,k_a_offset,size)
C     $Id$
C     This is a Fortran77 program generated by Tensor Contraction Engine v.1.0
C     Copyright (c) Battelle & Pacific Northwest National Laboratory (2002)
C     i2 ( h8 h9 h1 p7 )_vx
      IMPLICIT NONE
#include "global.fh"
#include "mafdecls.fh"
#include "sym.fh"
#include "errquit.fh"
#include "tce.fh"
      INTEGER l_a_offset
      INTEGER k_a_offset
      INTEGER size
      INTEGER length
      INTEGER addr
      INTEGER h8b
      INTEGER h9b
      INTEGER h1b
      INTEGER p7b
      length = 0
      DO h8b = 1,noab
      DO h9b = h8b,noab
      DO h1b = 1,noab
      DO p7b = noab+1,noab+nvab
      IF (int_mb(k_spin+h8b-1)+int_mb(k_spin+h9b-1) .eq. int_mb(k_spin+h
     &1b-1)+int_mb(k_spin+p7b-1)) THEN
      IF (ieor(int_mb(k_sym+h8b-1),ieor(int_mb(k_sym+h9b-1),ieor(int_mb(
     &k_sym+h1b-1),int_mb(k_sym+p7b-1)))) .eq. ieor(irrep_v,irrep_x)) TH
     &EN
      IF ((.not.restricted).or.(int_mb(k_spin+h8b-1)+int_mb(k_spin+h9b-1
     &)+int_mb(k_spin+h1b-1)+int_mb(k_spin+p7b-1).ne.8)) THEN
      length = length + 1
      END IF
      END IF
      END IF
      END DO
      END DO
      END DO
      END DO
      IF (.not.MA_PUSH_GET(mt_int,2*length+1,'noname',l_a_offset,k_a_off
     &set)) CALL ERRQUIT('eomccsdt_x3_11_5_1',0,MA_ERR)
      int_mb(k_a_offset) = length
      addr = 0
      size = 0
      DO h8b = 1,noab
      DO h9b = h8b,noab
      DO h1b = 1,noab
      DO p7b = noab+1,noab+nvab
      IF (int_mb(k_spin+h8b-1)+int_mb(k_spin+h9b-1) .eq. int_mb(k_spin+h
     &1b-1)+int_mb(k_spin+p7b-1)) THEN
      IF (ieor(int_mb(k_sym+h8b-1),ieor(int_mb(k_sym+h9b-1),ieor(int_mb(
     &k_sym+h1b-1),int_mb(k_sym+p7b-1)))) .eq. ieor(irrep_v,irrep_x)) TH
     &EN
      IF ((.not.restricted).or.(int_mb(k_spin+h8b-1)+int_mb(k_spin+h9b-1
     &)+int_mb(k_spin+h1b-1)+int_mb(k_spin+p7b-1).ne.8)) THEN
      addr = addr + 1
      int_mb(k_a_offset+addr) = p7b - noab - 1 + nvab * (h1b - 1 + noab 
     &* (h9b - 1 + noab * (h8b - 1)))
      int_mb(k_a_offset+length+addr) = size
      size = size + int_mb(k_range+h8b-1) * int_mb(k_range+h9b-1) * int_
     &mb(k_range+h1b-1) * int_mb(k_range+p7b-1)
      END IF
      END IF
      END IF
      END DO
      END DO
      END DO
      END DO
      RETURN
      END
      SUBROUTINE OFFSET_eomccsdt_x3_1_1(l_a_offset,k_a_offset,size)
C     $Id$
C     This is a Fortran77 program generated by Tensor Contraction Engine v.1.0
C     Copyright (c) Battelle & Pacific Northwest National Laboratory (2002)
C     i1 ( h11 p4 h1 h2 )_v
      IMPLICIT NONE
#include "global.fh"
#include "mafdecls.fh"
#include "sym.fh"
#include "errquit.fh"
#include "tce.fh"
      INTEGER l_a_offset
      INTEGER k_a_offset
      INTEGER size
      INTEGER length
      INTEGER addr
      INTEGER p4b
      INTEGER h11b
      INTEGER h1b
      INTEGER h2b
      length = 0
      DO p4b = noab+1,noab+nvab
      DO h11b = 1,noab
      DO h1b = 1,noab
      DO h2b = h1b,noab
      IF (int_mb(k_spin+h11b-1)+int_mb(k_spin+p4b-1) .eq. int_mb(k_spin+
     &h1b-1)+int_mb(k_spin+h2b-1)) THEN
      IF (ieor(int_mb(k_sym+h11b-1),ieor(int_mb(k_sym+p4b-1),ieor(int_mb
     &(k_sym+h1b-1),int_mb(k_sym+h2b-1)))) .eq. irrep_v) THEN
      IF ((.not.restricted).or.(int_mb(k_spin+h11b-1)+int_mb(k_spin+p4b-
     &1)+int_mb(k_spin+h1b-1)+int_mb(k_spin+h2b-1).ne.8)) THEN
      length = length + 1
      END IF
      END IF
      END IF
      END DO
      END DO
      END DO
      END DO
      IF (.not.MA_PUSH_GET(mt_int,2*length+1,'noname',l_a_offset,k_a_off
     &set)) CALL ERRQUIT('eomccsdt_x3_1_1',0,MA_ERR)
      int_mb(k_a_offset) = length
      addr = 0
      size = 0
      DO p4b = noab+1,noab+nvab
      DO h11b = 1,noab
      DO h1b = 1,noab
      DO h2b = h1b,noab
      IF (int_mb(k_spin+h11b-1)+int_mb(k_spin+p4b-1) .eq. int_mb(k_spin+
     &h1b-1)+int_mb(k_spin+h2b-1)) THEN
      IF (ieor(int_mb(k_sym+h11b-1),ieor(int_mb(k_sym+p4b-1),ieor(int_mb
     &(k_sym+h1b-1),int_mb(k_sym+h2b-1)))) .eq. irrep_v) THEN
      IF ((.not.restricted).or.(int_mb(k_spin+h11b-1)+int_mb(k_spin+p4b-
     &1)+int_mb(k_spin+h1b-1)+int_mb(k_spin+h2b-1).ne.8)) THEN
      addr = addr + 1
      int_mb(k_a_offset+addr) = h2b - 1 + noab * (h1b - 1 + noab * (h11b
     & - 1 + noab * (p4b - noab - 1)))
      int_mb(k_a_offset+length+addr) = size
      size = size + int_mb(k_range+p4b-1) * int_mb(k_range+h11b-1) * int
     &_mb(k_range+h1b-1) * int_mb(k_range+h2b-1)
      END IF
      END IF
      END IF
      END DO
      END DO
      END DO
      END DO
      RETURN
      END
      SUBROUTINE OFFSET_eomccsdt_x3_1_2_1(l_a_offset,k_a_offset,size)
C     $Id$
C     This is a Fortran77 program generated by Tensor Contraction Engine v.1.0
C     Copyright (c) Battelle & Pacific Northwest National Laboratory (2002)
C     i2 ( h11 h12 h1 h2 )_v
      IMPLICIT NONE
#include "global.fh"
#include "mafdecls.fh"
#include "sym.fh"
#include "errquit.fh"
#include "tce.fh"
      INTEGER l_a_offset
      INTEGER k_a_offset
      INTEGER size
      INTEGER length
      INTEGER addr
      INTEGER h11b
      INTEGER h12b
      INTEGER h1b
      INTEGER h2b
      length = 0
      DO h11b = 1,noab
      DO h12b = h11b,noab
      DO h1b = 1,noab
      DO h2b = h1b,noab
      IF (int_mb(k_spin+h11b-1)+int_mb(k_spin+h12b-1) .eq. int_mb(k_spin
     &+h1b-1)+int_mb(k_spin+h2b-1)) THEN
      IF (ieor(int_mb(k_sym+h11b-1),ieor(int_mb(k_sym+h12b-1),ieor(int_m
     &b(k_sym+h1b-1),int_mb(k_sym+h2b-1)))) .eq. irrep_v) THEN
      IF ((.not.restricted).or.(int_mb(k_spin+h11b-1)+int_mb(k_spin+h12b
     &-1)+int_mb(k_spin+h1b-1)+int_mb(k_spin+h2b-1).ne.8)) THEN
      length = length + 1
      END IF
      END IF
      END IF
      END DO
      END DO
      END DO
      END DO
      IF (.not.MA_PUSH_GET(mt_int,2*length+1,'noname',l_a_offset,k_a_off
     &set)) CALL ERRQUIT('eomccsdt_x3_1_2_1',0,MA_ERR)
      int_mb(k_a_offset) = length
      addr = 0
      size = 0
      DO h11b = 1,noab
      DO h12b = h11b,noab
      DO h1b = 1,noab
      DO h2b = h1b,noab
      IF (int_mb(k_spin+h11b-1)+int_mb(k_spin+h12b-1) .eq. int_mb(k_spin
     &+h1b-1)+int_mb(k_spin+h2b-1)) THEN
      IF (ieor(int_mb(k_sym+h11b-1),ieor(int_mb(k_sym+h12b-1),ieor(int_m
     &b(k_sym+h1b-1),int_mb(k_sym+h2b-1)))) .eq. irrep_v) THEN
      IF ((.not.restricted).or.(int_mb(k_spin+h11b-1)+int_mb(k_spin+h12b
     &-1)+int_mb(k_spin+h1b-1)+int_mb(k_spin+h2b-1).ne.8)) THEN
      addr = addr + 1
      int_mb(k_a_offset+addr) = h2b - 1 + noab * (h1b - 1 + noab * (h12b
     & - 1 + noab * (h11b - 1)))
      int_mb(k_a_offset+length+addr) = size
      size = size + int_mb(k_range+h11b-1) * int_mb(k_range+h12b-1) * in
     &t_mb(k_range+h1b-1) * int_mb(k_range+h2b-1)
      END IF
      END IF
      END IF
      END DO
      END DO
      END DO
      END DO
      RETURN
      END
      SUBROUTINE OFFSET_eomccsdt_x3_12_1(l_a_offset,k_a_offset,size)
C     $Id$
C     This is a Fortran77 program generated by Tensor Contraction Engine v.1.0
C     Copyright (c) Battelle & Pacific Northwest National Laboratory (2002)
C     i1 ( h7 h8 p4 h1 h2 h3 )_vx
      IMPLICIT NONE
#include "global.fh"
#include "mafdecls.fh"
#include "sym.fh"
#include "errquit.fh"
#include "tce.fh"
      INTEGER l_a_offset
      INTEGER k_a_offset
      INTEGER size
      INTEGER length
      INTEGER addr
      INTEGER p4b
      INTEGER h7b
      INTEGER h8b
      INTEGER h1b
      INTEGER h2b
      INTEGER h3b
      length = 0
      DO p4b = noab+1,noab+nvab
      DO h7b = 1,noab
      DO h8b = h7b,noab
      DO h1b = 1,noab
      DO h2b = h1b,noab
      DO h3b = h2b,noab
      IF (int_mb(k_spin+h7b-1)+int_mb(k_spin+h8b-1)+int_mb(k_spin+p4b-1)
     & .eq. int_mb(k_spin+h1b-1)+int_mb(k_spin+h2b-1)+int_mb(k_spin+h3b-
     &1)) THEN
      IF (ieor(int_mb(k_sym+h7b-1),ieor(int_mb(k_sym+h8b-1),ieor(int_mb(
     &k_sym+p4b-1),ieor(int_mb(k_sym+h1b-1),ieor(int_mb(k_sym+h2b-1),int
     &_mb(k_sym+h3b-1)))))) .eq. ieor(irrep_v,irrep_x)) THEN
      IF ((.not.restricted).or.(int_mb(k_spin+h7b-1)+int_mb(k_spin+h8b-1
     &)+int_mb(k_spin+p4b-1)+int_mb(k_spin+h1b-1)+int_mb(k_spin+h2b-1)+i
     &nt_mb(k_spin+h3b-1).ne.12)) THEN
      length = length + 1
      END IF
      END IF
      END IF
      END DO
      END DO
      END DO
      END DO
      END DO
      END DO
      IF (.not.MA_PUSH_GET(mt_int,2*length+1,'noname',l_a_offset,k_a_off
     &set)) CALL ERRQUIT('eomccsdt_x3_12_1',0,MA_ERR)
      int_mb(k_a_offset) = length
      addr = 0
      size = 0
      DO p4b = noab+1,noab+nvab
      DO h7b = 1,noab
      DO h8b = h7b,noab
      DO h1b = 1,noab
      DO h2b = h1b,noab
      DO h3b = h2b,noab
      IF (int_mb(k_spin+h7b-1)+int_mb(k_spin+h8b-1)+int_mb(k_spin+p4b-1)
     & .eq. int_mb(k_spin+h1b-1)+int_mb(k_spin+h2b-1)+int_mb(k_spin+h3b-
     &1)) THEN
      IF (ieor(int_mb(k_sym+h7b-1),ieor(int_mb(k_sym+h8b-1),ieor(int_mb(
     &k_sym+p4b-1),ieor(int_mb(k_sym+h1b-1),ieor(int_mb(k_sym+h2b-1),int
     &_mb(k_sym+h3b-1)))))) .eq. ieor(irrep_v,irrep_x)) THEN
      IF ((.not.restricted).or.(int_mb(k_spin+h7b-1)+int_mb(k_spin+h8b-1
     &)+int_mb(k_spin+p4b-1)+int_mb(k_spin+h1b-1)+int_mb(k_spin+h2b-1)+i
     &nt_mb(k_spin+h3b-1).ne.12)) THEN
      addr = addr + 1
      int_mb(k_a_offset+addr) = h3b - 1 + noab * (h2b - 1 + noab * (h1b 
     &- 1 + noab * (h8b - 1 + noab * (h7b - 1 + noab * (p4b - noab - 1))
     &)))
      int_mb(k_a_offset+length+addr) = size
      size = size + int_mb(k_range+p4b-1) * int_mb(k_range+h7b-1) * int_
     &mb(k_range+h8b-1) * int_mb(k_range+h1b-1) * int_mb(k_range+h2b-1) 
     &* int_mb(k_range+h3b-1)
      END IF
      END IF
      END IF
      END DO
      END DO
      END DO
      END DO
      END DO
      END DO
      RETURN
      END
      SUBROUTINE OFFSET_eomccsdt_x3_1_2_2_1(l_a_offset,k_a_offset,size)
C     $Id$
C     This is a Fortran77 program generated by Tensor Contraction Engine v.1.0
C     Copyright (c) Battelle & Pacific Northwest National Laboratory (2002)
C     i3 ( h11 h12 h1 p8 )_v
      IMPLICIT NONE
#include "global.fh"
#include "mafdecls.fh"
#include "sym.fh"
#include "errquit.fh"
#include "tce.fh"
      INTEGER l_a_offset
      INTEGER k_a_offset
      INTEGER size
      INTEGER length
      INTEGER addr
      INTEGER h11b
      INTEGER h12b
      INTEGER h1b
      INTEGER p8b
      length = 0
      DO h11b = 1,noab
      DO h12b = h11b,noab
      DO h1b = 1,noab
      DO p8b = noab+1,noab+nvab
      IF (int_mb(k_spin+h11b-1)+int_mb(k_spin+h12b-1) .eq. int_mb(k_spin
     &+h1b-1)+int_mb(k_spin+p8b-1)) THEN
      IF (ieor(int_mb(k_sym+h11b-1),ieor(int_mb(k_sym+h12b-1),ieor(int_m
     &b(k_sym+h1b-1),int_mb(k_sym+p8b-1)))) .eq. irrep_v) THEN
      IF ((.not.restricted).or.(int_mb(k_spin+h11b-1)+int_mb(k_spin+h12b
     &-1)+int_mb(k_spin+h1b-1)+int_mb(k_spin+p8b-1).ne.8)) THEN
      length = length + 1
      END IF
      END IF
      END IF
      END DO
      END DO
      END DO
      END DO
      IF (.not.MA_PUSH_GET(mt_int,2*length+1,'noname',l_a_offset,k_a_off
     &set)) CALL ERRQUIT('eomccsdt_x3_1_2_2_1',0,MA_ERR)
      int_mb(k_a_offset) = length
      addr = 0
      size = 0
      DO h11b = 1,noab
      DO h12b = h11b,noab
      DO h1b = 1,noab
      DO p8b = noab+1,noab+nvab
      IF (int_mb(k_spin+h11b-1)+int_mb(k_spin+h12b-1) .eq. int_mb(k_spin
     &+h1b-1)+int_mb(k_spin+p8b-1)) THEN
      IF (ieor(int_mb(k_sym+h11b-1),ieor(int_mb(k_sym+h12b-1),ieor(int_m
     &b(k_sym+h1b-1),int_mb(k_sym+p8b-1)))) .eq. irrep_v) THEN
      IF ((.not.restricted).or.(int_mb(k_spin+h11b-1)+int_mb(k_spin+h12b
     &-1)+int_mb(k_spin+h1b-1)+int_mb(k_spin+p8b-1).ne.8)) THEN
      addr = addr + 1
      int_mb(k_a_offset+addr) = p8b - noab - 1 + nvab * (h1b - 1 + noab 
     &* (h12b - 1 + noab * (h11b - 1)))
      int_mb(k_a_offset+length+addr) = size
      size = size + int_mb(k_range+h11b-1) * int_mb(k_range+h12b-1) * in
     &t_mb(k_range+h1b-1) * int_mb(k_range+p8b-1)
      END IF
      END IF
      END IF
      END DO
      END DO
      END DO
      END DO
      RETURN
      END
      SUBROUTINE OFFSET_eomccsdt_x3_13_1_1(l_a_offset,k_a_offset,size)
C     $Id$
C     This is a Fortran77 program generated by Tensor Contraction Engine v.1.0
C     Copyright (c) Battelle & Pacific Northwest National Laboratory (2002)
C     i2 ( h7 p11 )_f
      IMPLICIT NONE
#include "global.fh"
#include "mafdecls.fh"
#include "sym.fh"
#include "errquit.fh"
#include "tce.fh"
      INTEGER l_a_offset
      INTEGER k_a_offset
      INTEGER size
      INTEGER length
      INTEGER addr
      INTEGER h7b
      INTEGER p11b
      length = 0
      DO h7b = 1,noab
      DO p11b = noab+1,noab+nvab
      IF (int_mb(k_spin+h7b-1) .eq. int_mb(k_spin+p11b-1)) THEN
      IF (ieor(int_mb(k_sym+h7b-1),int_mb(k_sym+p11b-1)) .eq. irrep_f) T
     &HEN
      IF ((.not.restricted).or.(int_mb(k_spin+h7b-1)+int_mb(k_spin+p11b-
     &1).ne.4)) THEN
      length = length + 1
      END IF
      END IF
      END IF
      END DO
      END DO
      IF (.not.MA_PUSH_GET(mt_int,2*length+1,'noname',l_a_offset,k_a_off
     &set)) CALL ERRQUIT('eomccsdt_x3_13_1_1',0,MA_ERR)
      int_mb(k_a_offset) = length
      addr = 0
      size = 0
      DO h7b = 1,noab
      DO p11b = noab+1,noab+nvab
      IF (int_mb(k_spin+h7b-1) .eq. int_mb(k_spin+p11b-1)) THEN
      IF (ieor(int_mb(k_sym+h7b-1),int_mb(k_sym+p11b-1)) .eq. irrep_f) T
     &HEN
      IF ((.not.restricted).or.(int_mb(k_spin+h7b-1)+int_mb(k_spin+p11b-
     &1).ne.4)) THEN
      addr = addr + 1
      int_mb(k_a_offset+addr) = p11b - noab - 1 + nvab * (h7b - 1)
      int_mb(k_a_offset+length+addr) = size
      size = size + int_mb(k_range+h7b-1) * int_mb(k_range+p11b-1)
      END IF
      END IF
      END IF
      END DO
      END DO
      RETURN
      END
      SUBROUTINE OFFSET_eomccsdt_x3_1_3_1(l_a_offset,k_a_offset,size)
C     $Id$
C     This is a Fortran77 program generated by Tensor Contraction Engine v.1.0
C     Copyright (c) Battelle & Pacific Northwest National Laboratory (2002)
C     i2 ( h11 p4 h1 p7 )_v
      IMPLICIT NONE
#include "global.fh"
#include "mafdecls.fh"
#include "sym.fh"
#include "errquit.fh"
#include "tce.fh"
      INTEGER l_a_offset
      INTEGER k_a_offset
      INTEGER size
      INTEGER length
      INTEGER addr
      INTEGER p4b
      INTEGER h11b
      INTEGER h1b
      INTEGER p7b
      length = 0
      DO p4b = noab+1,noab+nvab
      DO h11b = 1,noab
      DO h1b = 1,noab
      DO p7b = noab+1,noab+nvab
      IF (int_mb(k_spin+h11b-1)+int_mb(k_spin+p4b-1) .eq. int_mb(k_spin+
     &h1b-1)+int_mb(k_spin+p7b-1)) THEN
      IF (ieor(int_mb(k_sym+h11b-1),ieor(int_mb(k_sym+p4b-1),ieor(int_mb
     &(k_sym+h1b-1),int_mb(k_sym+p7b-1)))) .eq. irrep_v) THEN
      IF ((.not.restricted).or.(int_mb(k_spin+h11b-1)+int_mb(k_spin+p4b-
     &1)+int_mb(k_spin+h1b-1)+int_mb(k_spin+p7b-1).ne.8)) THEN
      length = length + 1
      END IF
      END IF
      END IF
      END DO
      END DO
      END DO
      END DO
      IF (.not.MA_PUSH_GET(mt_int,2*length+1,'noname',l_a_offset,k_a_off
     &set)) CALL ERRQUIT('eomccsdt_x3_1_3_1',0,MA_ERR)
      int_mb(k_a_offset) = length
      addr = 0
      size = 0
      DO p4b = noab+1,noab+nvab
      DO h11b = 1,noab
      DO h1b = 1,noab
      DO p7b = noab+1,noab+nvab
      IF (int_mb(k_spin+h11b-1)+int_mb(k_spin+p4b-1) .eq. int_mb(k_spin+
     &h1b-1)+int_mb(k_spin+p7b-1)) THEN
      IF (ieor(int_mb(k_sym+h11b-1),ieor(int_mb(k_sym+p4b-1),ieor(int_mb
     &(k_sym+h1b-1),int_mb(k_sym+p7b-1)))) .eq. irrep_v) THEN
      IF ((.not.restricted).or.(int_mb(k_spin+h11b-1)+int_mb(k_spin+p4b-
     &1)+int_mb(k_spin+h1b-1)+int_mb(k_spin+p7b-1).ne.8)) THEN
      addr = addr + 1
      int_mb(k_a_offset+addr) = p7b - noab - 1 + nvab * (h1b - 1 + noab 
     &* (h11b - 1 + noab * (p4b - noab - 1)))
      int_mb(k_a_offset+length+addr) = size
      size = size + int_mb(k_range+p4b-1) * int_mb(k_range+h11b-1) * int
     &_mb(k_range+h1b-1) * int_mb(k_range+p7b-1)
      END IF
      END IF
      END IF
      END DO
      END DO
      END DO
      END DO
      RETURN
      END
      SUBROUTINE OFFSET_eomccsdt_x3_13_1(l_a_offset,k_a_offset,size)
C     $Id$
C     This is a Fortran77 program generated by Tensor Contraction Engine v.1.0
C     Copyright (c) Battelle & Pacific Northwest National Laboratory (2002)
C     i1 ( h7 h1 )_fx
      IMPLICIT NONE
#include "global.fh"
#include "mafdecls.fh"
#include "sym.fh"
#include "errquit.fh"
#include "tce.fh"
      INTEGER l_a_offset
      INTEGER k_a_offset
      INTEGER size
      INTEGER length
      INTEGER addr
      INTEGER h7b
      INTEGER h1b
      length = 0
      DO h7b = 1,noab
      DO h1b = 1,noab
      IF (int_mb(k_spin+h7b-1) .eq. int_mb(k_spin+h1b-1)) THEN
      IF (ieor(int_mb(k_sym+h7b-1),int_mb(k_sym+h1b-1)) .eq. ieor(irrep_
     &f,irrep_x)) THEN
      IF ((.not.restricted).or.(int_mb(k_spin+h7b-1)+int_mb(k_spin+h1b-1
     &).ne.4)) THEN
      length = length + 1
      END IF
      END IF
      END IF
      END DO
      END DO
      IF (.not.MA_PUSH_GET(mt_int,2*length+1,'noname',l_a_offset,k_a_off
     &set)) CALL ERRQUIT('eomccsdt_x3_13_1',0,MA_ERR)
      int_mb(k_a_offset) = length
      addr = 0
      size = 0
      DO h7b = 1,noab
      DO h1b = 1,noab
      IF (int_mb(k_spin+h7b-1) .eq. int_mb(k_spin+h1b-1)) THEN
      IF (ieor(int_mb(k_sym+h7b-1),int_mb(k_sym+h1b-1)) .eq. ieor(irrep_
     &f,irrep_x)) THEN
      IF ((.not.restricted).or.(int_mb(k_spin+h7b-1)+int_mb(k_spin+h1b-1
     &).ne.4)) THEN
      addr = addr + 1
      int_mb(k_a_offset+addr) = h1b - 1 + noab * (h7b - 1)
      int_mb(k_a_offset+length+addr) = size
      size = size + int_mb(k_range+h7b-1) * int_mb(k_range+h1b-1)
      END IF
      END IF
      END IF
      END DO
      END DO
      RETURN
      END
      SUBROUTINE OFFSET_eomccsdt_x3_13_4_1(l_a_offset,k_a_offset,size)
C     $Id$
C     This is a Fortran77 program generated by Tensor Contraction Engine v.1.0
C     Copyright (c) Battelle & Pacific Northwest National Laboratory (2002)
C     i2 ( h7 p8 )_vx
      IMPLICIT NONE
#include "global.fh"
#include "mafdecls.fh"
#include "sym.fh"
#include "errquit.fh"
#include "tce.fh"
      INTEGER l_a_offset
      INTEGER k_a_offset
      INTEGER size
      INTEGER length
      INTEGER addr
      INTEGER h7b
      INTEGER p8b
      length = 0
      DO h7b = 1,noab
      DO p8b = noab+1,noab+nvab
      IF (int_mb(k_spin+h7b-1) .eq. int_mb(k_spin+p8b-1)) THEN
      IF (ieor(int_mb(k_sym+h7b-1),int_mb(k_sym+p8b-1)) .eq. ieor(irrep_
     &v,irrep_x)) THEN
      IF ((.not.restricted).or.(int_mb(k_spin+h7b-1)+int_mb(k_spin+p8b-1
     &).ne.4)) THEN
      length = length + 1
      END IF
      END IF
      END IF
      END DO
      END DO
      IF (.not.MA_PUSH_GET(mt_int,2*length+1,'noname',l_a_offset,k_a_off
     &set)) CALL ERRQUIT('eomccsdt_x3_13_4_1',0,MA_ERR)
      int_mb(k_a_offset) = length
      addr = 0
      size = 0
      DO h7b = 1,noab
      DO p8b = noab+1,noab+nvab
      IF (int_mb(k_spin+h7b-1) .eq. int_mb(k_spin+p8b-1)) THEN
      IF (ieor(int_mb(k_sym+h7b-1),int_mb(k_sym+p8b-1)) .eq. ieor(irrep_
     &v,irrep_x)) THEN
      IF ((.not.restricted).or.(int_mb(k_spin+h7b-1)+int_mb(k_spin+p8b-1
     &).ne.4)) THEN
      addr = addr + 1
      int_mb(k_a_offset+addr) = p8b - noab - 1 + nvab * (h7b - 1)
      int_mb(k_a_offset+length+addr) = size
      size = size + int_mb(k_range+h7b-1) * int_mb(k_range+p8b-1)
      END IF
      END IF
      END IF
      END DO
      END DO
      RETURN
      END
      SUBROUTINE OFFSET_eomccsdt_x3_1_4_1(l_a_offset,k_a_offset,size)
C     $Id$
C     This is a Fortran77 program generated by Tensor Contraction Engine v.1.0
C     Copyright (c) Battelle & Pacific Northwest National Laboratory (2002)
C     i2 ( h11 p10 )_f
      IMPLICIT NONE
#include "global.fh"
#include "mafdecls.fh"
#include "sym.fh"
#include "errquit.fh"
#include "tce.fh"
      INTEGER l_a_offset
      INTEGER k_a_offset
      INTEGER size
      INTEGER length
      INTEGER addr
      INTEGER h11b
      INTEGER p10b
      length = 0
      DO h11b = 1,noab
      DO p10b = noab+1,noab+nvab
      IF (int_mb(k_spin+h11b-1) .eq. int_mb(k_spin+p10b-1)) THEN
      IF (ieor(int_mb(k_sym+h11b-1),int_mb(k_sym+p10b-1)) .eq. irrep_f) 
     &THEN
      IF ((.not.restricted).or.(int_mb(k_spin+h11b-1)+int_mb(k_spin+p10b
     &-1).ne.4)) THEN
      length = length + 1
      END IF
      END IF
      END IF
      END DO
      END DO
      IF (.not.MA_PUSH_GET(mt_int,2*length+1,'noname',l_a_offset,k_a_off
     &set)) CALL ERRQUIT('eomccsdt_x3_1_4_1',0,MA_ERR)
      int_mb(k_a_offset) = length
      addr = 0
      size = 0
      DO h11b = 1,noab
      DO p10b = noab+1,noab+nvab
      IF (int_mb(k_spin+h11b-1) .eq. int_mb(k_spin+p10b-1)) THEN
      IF (ieor(int_mb(k_sym+h11b-1),int_mb(k_sym+p10b-1)) .eq. irrep_f) 
     &THEN
      IF ((.not.restricted).or.(int_mb(k_spin+h11b-1)+int_mb(k_spin+p10b
     &-1).ne.4)) THEN
      addr = addr + 1
      int_mb(k_a_offset+addr) = p10b - noab - 1 + nvab * (h11b - 1)
      int_mb(k_a_offset+length+addr) = size
      size = size + int_mb(k_range+h11b-1) * int_mb(k_range+p10b-1)
      END IF
      END IF
      END IF
      END DO
      END DO
      RETURN
      END
      SUBROUTINE OFFSET_eomccsdt_x3_14_1(l_a_offset,k_a_offset,size)
C     $Id$
C     This is a Fortran77 program generated by Tensor Contraction Engine v.1.0
C     Copyright (c) Battelle & Pacific Northwest National Laboratory (2002)
C     i1 ( h7 h8 h1 h2 )_vx
      IMPLICIT NONE
#include "global.fh"
#include "mafdecls.fh"
#include "sym.fh"
#include "errquit.fh"
#include "tce.fh"
      INTEGER l_a_offset
      INTEGER k_a_offset
      INTEGER size
      INTEGER length
      INTEGER addr
      INTEGER h7b
      INTEGER h8b
      INTEGER h1b
      INTEGER h2b
      length = 0
      DO h7b = 1,noab
      DO h8b = h7b,noab
      DO h1b = 1,noab
      DO h2b = h1b,noab
      IF (int_mb(k_spin+h7b-1)+int_mb(k_spin+h8b-1) .eq. int_mb(k_spin+h
     &1b-1)+int_mb(k_spin+h2b-1)) THEN
      IF (ieor(int_mb(k_sym+h7b-1),ieor(int_mb(k_sym+h8b-1),ieor(int_mb(
     &k_sym+h1b-1),int_mb(k_sym+h2b-1)))) .eq. ieor(irrep_v,irrep_x)) TH
     &EN
      IF ((.not.restricted).or.(int_mb(k_spin+h7b-1)+int_mb(k_spin+h8b-1
     &)+int_mb(k_spin+h1b-1)+int_mb(k_spin+h2b-1).ne.8)) THEN
      length = length + 1
      END IF
      END IF
      END IF
      END DO
      END DO
      END DO
      END DO
      IF (.not.MA_PUSH_GET(mt_int,2*length+1,'noname',l_a_offset,k_a_off
     &set)) CALL ERRQUIT('eomccsdt_x3_14_1',0,MA_ERR)
      int_mb(k_a_offset) = length
      addr = 0
      size = 0
      DO h7b = 1,noab
      DO h8b = h7b,noab
      DO h1b = 1,noab
      DO h2b = h1b,noab
      IF (int_mb(k_spin+h7b-1)+int_mb(k_spin+h8b-1) .eq. int_mb(k_spin+h
     &1b-1)+int_mb(k_spin+h2b-1)) THEN
      IF (ieor(int_mb(k_sym+h7b-1),ieor(int_mb(k_sym+h8b-1),ieor(int_mb(
     &k_sym+h1b-1),int_mb(k_sym+h2b-1)))) .eq. ieor(irrep_v,irrep_x)) TH
     &EN
      IF ((.not.restricted).or.(int_mb(k_spin+h7b-1)+int_mb(k_spin+h8b-1
     &)+int_mb(k_spin+h1b-1)+int_mb(k_spin+h2b-1).ne.8)) THEN
      addr = addr + 1
      int_mb(k_a_offset+addr) = h2b - 1 + noab * (h1b - 1 + noab * (h8b 
     &- 1 + noab * (h7b - 1)))
      int_mb(k_a_offset+length+addr) = size
      size = size + int_mb(k_range+h7b-1) * int_mb(k_range+h8b-1) * int_
     &mb(k_range+h1b-1) * int_mb(k_range+h2b-1)
      END IF
      END IF
      END IF
      END DO
      END DO
      END DO
      END DO
      RETURN
      END
      SUBROUTINE OFFSET_eomccsdt_x3_14_3_1(l_a_offset,k_a_offset,size)
C     $Id$
C     This is a Fortran77 program generated by Tensor Contraction Engine v.1.0
C     Copyright (c) Battelle & Pacific Northwest National Laboratory (2002)
C     i2 ( h7 h8 h1 p9 )_vx
      IMPLICIT NONE
#include "global.fh"
#include "mafdecls.fh"
#include "sym.fh"
#include "errquit.fh"
#include "tce.fh"
      INTEGER l_a_offset
      INTEGER k_a_offset
      INTEGER size
      INTEGER length
      INTEGER addr
      INTEGER h7b
      INTEGER h8b
      INTEGER h1b
      INTEGER p9b
      length = 0
      DO h7b = 1,noab
      DO h8b = h7b,noab
      DO h1b = 1,noab
      DO p9b = noab+1,noab+nvab
      IF (int_mb(k_spin+h7b-1)+int_mb(k_spin+h8b-1) .eq. int_mb(k_spin+h
     &1b-1)+int_mb(k_spin+p9b-1)) THEN
      IF (ieor(int_mb(k_sym+h7b-1),ieor(int_mb(k_sym+h8b-1),ieor(int_mb(
     &k_sym+h1b-1),int_mb(k_sym+p9b-1)))) .eq. ieor(irrep_v,irrep_x)) TH
     &EN
      IF ((.not.restricted).or.(int_mb(k_spin+h7b-1)+int_mb(k_spin+h8b-1
     &)+int_mb(k_spin+h1b-1)+int_mb(k_spin+p9b-1).ne.8)) THEN
      length = length + 1
      END IF
      END IF
      END IF
      END DO
      END DO
      END DO
      END DO
      IF (.not.MA_PUSH_GET(mt_int,2*length+1,'noname',l_a_offset,k_a_off
     &set)) CALL ERRQUIT('eomccsdt_x3_14_3_1',0,MA_ERR)
      int_mb(k_a_offset) = length
      addr = 0
      size = 0
      DO h7b = 1,noab
      DO h8b = h7b,noab
      DO h1b = 1,noab
      DO p9b = noab+1,noab+nvab
      IF (int_mb(k_spin+h7b-1)+int_mb(k_spin+h8b-1) .eq. int_mb(k_spin+h
     &1b-1)+int_mb(k_spin+p9b-1)) THEN
      IF (ieor(int_mb(k_sym+h7b-1),ieor(int_mb(k_sym+h8b-1),ieor(int_mb(
     &k_sym+h1b-1),int_mb(k_sym+p9b-1)))) .eq. ieor(irrep_v,irrep_x)) TH
     &EN
      IF ((.not.restricted).or.(int_mb(k_spin+h7b-1)+int_mb(k_spin+h8b-1
     &)+int_mb(k_spin+h1b-1)+int_mb(k_spin+p9b-1).ne.8)) THEN
      addr = addr + 1
      int_mb(k_a_offset+addr) = p9b - noab - 1 + nvab * (h1b - 1 + noab 
     &* (h8b - 1 + noab * (h7b - 1)))
      int_mb(k_a_offset+length+addr) = size
      size = size + int_mb(k_range+h7b-1) * int_mb(k_range+h8b-1) * int_
     &mb(k_range+h1b-1) * int_mb(k_range+p9b-1)
      END IF
      END IF
      END IF
      END DO
      END DO
      END DO
      END DO
      RETURN
      END
      SUBROUTINE OFFSET_eomccsdt_x3_1_5_1(l_a_offset,k_a_offset,size)
C     $Id$
C     This is a Fortran77 program generated by Tensor Contraction Engine v.1.0
C     Copyright (c) Battelle & Pacific Northwest National Laboratory (2002)
C     i2 ( h8 h11 h1 p7 )_v
      IMPLICIT NONE
#include "global.fh"
#include "mafdecls.fh"
#include "sym.fh"
#include "errquit.fh"
#include "tce.fh"
      INTEGER l_a_offset
      INTEGER k_a_offset
      INTEGER size
      INTEGER length
      INTEGER addr
      INTEGER h8b
      INTEGER h11b
      INTEGER h1b
      INTEGER p7b
      length = 0
      DO h8b = 1,noab
      DO h11b = h8b,noab
      DO h1b = 1,noab
      DO p7b = noab+1,noab+nvab
      IF (int_mb(k_spin+h8b-1)+int_mb(k_spin+h11b-1) .eq. int_mb(k_spin+
     &h1b-1)+int_mb(k_spin+p7b-1)) THEN
      IF (ieor(int_mb(k_sym+h8b-1),ieor(int_mb(k_sym+h11b-1),ieor(int_mb
     &(k_sym+h1b-1),int_mb(k_sym+p7b-1)))) .eq. irrep_v) THEN
      IF ((.not.restricted).or.(int_mb(k_spin+h8b-1)+int_mb(k_spin+h11b-
     &1)+int_mb(k_spin+h1b-1)+int_mb(k_spin+p7b-1).ne.8)) THEN
      length = length + 1
      END IF
      END IF
      END IF
      END DO
      END DO
      END DO
      END DO
      IF (.not.MA_PUSH_GET(mt_int,2*length+1,'noname',l_a_offset,k_a_off
     &set)) CALL ERRQUIT('eomccsdt_x3_1_5_1',0,MA_ERR)
      int_mb(k_a_offset) = length
      addr = 0
      size = 0
      DO h8b = 1,noab
      DO h11b = h8b,noab
      DO h1b = 1,noab
      DO p7b = noab+1,noab+nvab
      IF (int_mb(k_spin+h8b-1)+int_mb(k_spin+h11b-1) .eq. int_mb(k_spin+
     &h1b-1)+int_mb(k_spin+p7b-1)) THEN
      IF (ieor(int_mb(k_sym+h8b-1),ieor(int_mb(k_sym+h11b-1),ieor(int_mb
     &(k_sym+h1b-1),int_mb(k_sym+p7b-1)))) .eq. irrep_v) THEN
      IF ((.not.restricted).or.(int_mb(k_spin+h8b-1)+int_mb(k_spin+h11b-
     &1)+int_mb(k_spin+h1b-1)+int_mb(k_spin+p7b-1).ne.8)) THEN
      addr = addr + 1
      int_mb(k_a_offset+addr) = p7b - noab - 1 + nvab * (h1b - 1 + noab 
     &* (h11b - 1 + noab * (h8b - 1)))
      int_mb(k_a_offset+length+addr) = size
      size = size + int_mb(k_range+h8b-1) * int_mb(k_range+h11b-1) * int
     &_mb(k_range+h1b-1) * int_mb(k_range+p7b-1)
      END IF
      END IF
      END IF
      END DO
      END DO
      END DO
      END DO
      RETURN
      END
      SUBROUTINE OFFSET_eomccsdt_x3_15_1(l_a_offset,k_a_offset,size)
C     $Id$
C     This is a Fortran77 program generated by Tensor Contraction Engine v.1.0
C     Copyright (c) Battelle & Pacific Northwest National Laboratory (2002)
C     i1 ( p4 p7 )_vx
      IMPLICIT NONE
#include "global.fh"
#include "mafdecls.fh"
#include "sym.fh"
#include "errquit.fh"
#include "tce.fh"
      INTEGER l_a_offset
      INTEGER k_a_offset
      INTEGER size
      INTEGER length
      INTEGER addr
      INTEGER p4b
      INTEGER p7b
      length = 0
      DO p4b = noab+1,noab+nvab
      DO p7b = noab+1,noab+nvab
      IF (int_mb(k_spin+p4b-1) .eq. int_mb(k_spin+p7b-1)) THEN
      IF (ieor(int_mb(k_sym+p4b-1),int_mb(k_sym+p7b-1)) .eq. ieor(irrep_
     &v,irrep_x)) THEN
      IF ((.not.restricted).or.(int_mb(k_spin+p4b-1)+int_mb(k_spin+p7b-1
     &).ne.4)) THEN
      length = length + 1
      END IF
      END IF
      END IF
      END DO
      END DO
      IF (.not.MA_PUSH_GET(mt_int,2*length+1,'noname',l_a_offset,k_a_off
     &set)) CALL ERRQUIT('eomccsdt_x3_15_1',0,MA_ERR)
      int_mb(k_a_offset) = length
      addr = 0
      size = 0
      DO p4b = noab+1,noab+nvab
      DO p7b = noab+1,noab+nvab
      IF (int_mb(k_spin+p4b-1) .eq. int_mb(k_spin+p7b-1)) THEN
      IF (ieor(int_mb(k_sym+p4b-1),int_mb(k_sym+p7b-1)) .eq. ieor(irrep_
     &v,irrep_x)) THEN
      IF ((.not.restricted).or.(int_mb(k_spin+p4b-1)+int_mb(k_spin+p7b-1
     &).ne.4)) THEN
      addr = addr + 1
      int_mb(k_a_offset+addr) = p7b - noab - 1 + nvab * (p4b - noab - 1)
      int_mb(k_a_offset+length+addr) = size
      size = size + int_mb(k_range+p4b-1) * int_mb(k_range+p7b-1)
      END IF
      END IF
      END IF
      END DO
      END DO
      RETURN
      END
      SUBROUTINE OFFSET_eomccsdt_x3_16_1(l_a_offset,k_a_offset,size)
C     $Id$
C     This is a Fortran77 program generated by Tensor Contraction Engine v.1.0
C     Copyright (c) Battelle & Pacific Northwest National Laboratory (2002)
C     i1 ( h8 p4 h1 p7 )_vx
      IMPLICIT NONE
#include "global.fh"
#include "mafdecls.fh"
#include "sym.fh"
#include "errquit.fh"
#include "tce.fh"
      INTEGER l_a_offset
      INTEGER k_a_offset
      INTEGER size
      INTEGER length
      INTEGER addr
      INTEGER p4b
      INTEGER h8b
      INTEGER h1b
      INTEGER p7b
      length = 0
      DO p4b = noab+1,noab+nvab
      DO h8b = 1,noab
      DO h1b = 1,noab
      DO p7b = noab+1,noab+nvab
      IF (int_mb(k_spin+h8b-1)+int_mb(k_spin+p4b-1) .eq. int_mb(k_spin+h
     &1b-1)+int_mb(k_spin+p7b-1)) THEN
      IF (ieor(int_mb(k_sym+h8b-1),ieor(int_mb(k_sym+p4b-1),ieor(int_mb(
     &k_sym+h1b-1),int_mb(k_sym+p7b-1)))) .eq. ieor(irrep_v,irrep_x)) TH
     &EN
      IF ((.not.restricted).or.(int_mb(k_spin+h8b-1)+int_mb(k_spin+p4b-1
     &)+int_mb(k_spin+h1b-1)+int_mb(k_spin+p7b-1).ne.8)) THEN
      length = length + 1
      END IF
      END IF
      END IF
      END DO
      END DO
      END DO
      END DO
      IF (.not.MA_PUSH_GET(mt_int,2*length+1,'noname',l_a_offset,k_a_off
     &set)) CALL ERRQUIT('eomccsdt_x3_16_1',0,MA_ERR)
      int_mb(k_a_offset) = length
      addr = 0
      size = 0
      DO p4b = noab+1,noab+nvab
      DO h8b = 1,noab
      DO h1b = 1,noab
      DO p7b = noab+1,noab+nvab
      IF (int_mb(k_spin+h8b-1)+int_mb(k_spin+p4b-1) .eq. int_mb(k_spin+h
     &1b-1)+int_mb(k_spin+p7b-1)) THEN
      IF (ieor(int_mb(k_sym+h8b-1),ieor(int_mb(k_sym+p4b-1),ieor(int_mb(
     &k_sym+h1b-1),int_mb(k_sym+p7b-1)))) .eq. ieor(irrep_v,irrep_x)) TH
     &EN
      IF ((.not.restricted).or.(int_mb(k_spin+h8b-1)+int_mb(k_spin+p4b-1
     &)+int_mb(k_spin+h1b-1)+int_mb(k_spin+p7b-1).ne.8)) THEN
      addr = addr + 1
      int_mb(k_a_offset+addr) = p7b - noab - 1 + nvab * (h1b - 1 + noab 
     &* (h8b - 1 + noab * (p4b - noab - 1)))
      int_mb(k_a_offset+length+addr) = size
      size = size + int_mb(k_range+p4b-1) * int_mb(k_range+h8b-1) * int_
     &mb(k_range+h1b-1) * int_mb(k_range+p7b-1)
      END IF
      END IF
      END IF
      END DO
      END DO
      END DO
      END DO
      RETURN
      END
      SUBROUTINE OFFSET_eomccsdt_x3_17_1(l_a_offset,k_a_offset,size)
C     $Id$
C     This is a Fortran77 program generated by Tensor Contraction Engine v.1.0
C     Copyright (c) Battelle & Pacific Northwest National Laboratory (2002)
C     i1 ( h9 h10 p4 h1 h2 h3 )_vt
      IMPLICIT NONE
#include "global.fh"
#include "mafdecls.fh"
#include "sym.fh"
#include "errquit.fh"
#include "tce.fh"
      INTEGER l_a_offset
      INTEGER k_a_offset
      INTEGER size
      INTEGER length
      INTEGER addr
      INTEGER p4b
      INTEGER h9b
      INTEGER h10b
      INTEGER h1b
      INTEGER h2b
      INTEGER h3b
      length = 0
      DO p4b = noab+1,noab+nvab
      DO h9b = 1,noab
      DO h10b = h9b,noab
      DO h1b = 1,noab
      DO h2b = h1b,noab
      DO h3b = h2b,noab
      IF (int_mb(k_spin+h9b-1)+int_mb(k_spin+h10b-1)+int_mb(k_spin+p4b-1
     &) .eq. int_mb(k_spin+h1b-1)+int_mb(k_spin+h2b-1)+int_mb(k_spin+h3b
     &-1)) THEN
      IF (ieor(int_mb(k_sym+h9b-1),ieor(int_mb(k_sym+h10b-1),ieor(int_mb
     &(k_sym+p4b-1),ieor(int_mb(k_sym+h1b-1),ieor(int_mb(k_sym+h2b-1),in
     &t_mb(k_sym+h3b-1)))))) .eq. ieor(irrep_v,irrep_t)) THEN
      IF ((.not.restricted).or.(int_mb(k_spin+h9b-1)+int_mb(k_spin+h10b-
     &1)+int_mb(k_spin+p4b-1)+int_mb(k_spin+h1b-1)+int_mb(k_spin+h2b-1)+
     &int_mb(k_spin+h3b-1).ne.12)) THEN
      length = length + 1
      END IF
      END IF
      END IF
      END DO
      END DO
      END DO
      END DO
      END DO
      END DO
      IF (.not.MA_PUSH_GET(mt_int,2*length+1,'noname',l_a_offset,k_a_off
     &set)) CALL ERRQUIT('eomccsdt_x3_17_1',0,MA_ERR)
      int_mb(k_a_offset) = length
      addr = 0
      size = 0
      DO p4b = noab+1,noab+nvab
      DO h9b = 1,noab
      DO h10b = h9b,noab
      DO h1b = 1,noab
      DO h2b = h1b,noab
      DO h3b = h2b,noab
      IF (int_mb(k_spin+h9b-1)+int_mb(k_spin+h10b-1)+int_mb(k_spin+p4b-1
     &) .eq. int_mb(k_spin+h1b-1)+int_mb(k_spin+h2b-1)+int_mb(k_spin+h3b
     &-1)) THEN
      IF (ieor(int_mb(k_sym+h9b-1),ieor(int_mb(k_sym+h10b-1),ieor(int_mb
     &(k_sym+p4b-1),ieor(int_mb(k_sym+h1b-1),ieor(int_mb(k_sym+h2b-1),in
     &t_mb(k_sym+h3b-1)))))) .eq. ieor(irrep_v,irrep_t)) THEN
      IF ((.not.restricted).or.(int_mb(k_spin+h9b-1)+int_mb(k_spin+h10b-
     &1)+int_mb(k_spin+p4b-1)+int_mb(k_spin+h1b-1)+int_mb(k_spin+h2b-1)+
     &int_mb(k_spin+h3b-1).ne.12)) THEN
      addr = addr + 1
      int_mb(k_a_offset+addr) = h3b - 1 + noab * (h2b - 1 + noab * (h1b 
     &- 1 + noab * (h10b - 1 + noab * (h9b - 1 + noab * (p4b - noab - 1)
     &))))
      int_mb(k_a_offset+length+addr) = size
      size = size + int_mb(k_range+p4b-1) * int_mb(k_range+h9b-1) * int_
     &mb(k_range+h10b-1) * int_mb(k_range+h1b-1) * int_mb(k_range+h2b-1)
     & * int_mb(k_range+h3b-1)
      END IF
      END IF
      END IF
      END DO
      END DO
      END DO
      END DO
      END DO
      END DO
      RETURN
      END
      SUBROUTINE OFFSET_eomccsdt_x3_2_1(l_a_offset,k_a_offset,size)
C     $Id$
C     This is a Fortran77 program generated by Tensor Contraction Engine v.1.0
C     Copyright (c) Battelle & Pacific Northwest National Laboratory (2002)
C     i1 ( p4 p5 h1 p12 )_v
      IMPLICIT NONE
#include "global.fh"
#include "mafdecls.fh"
#include "sym.fh"
#include "errquit.fh"
#include "tce.fh"
      INTEGER l_a_offset
      INTEGER k_a_offset
      INTEGER size
      INTEGER length
      INTEGER addr
      INTEGER p4b
      INTEGER p5b
      INTEGER h1b
      INTEGER p12b
      length = 0
      DO p4b = noab+1,noab+nvab
      DO p5b = p4b,noab+nvab
      DO h1b = 1,noab
      DO p12b = noab+1,noab+nvab
      IF (int_mb(k_spin+p4b-1)+int_mb(k_spin+p5b-1) .eq. int_mb(k_spin+h
     &1b-1)+int_mb(k_spin+p12b-1)) THEN
      IF (ieor(int_mb(k_sym+p4b-1),ieor(int_mb(k_sym+p5b-1),ieor(int_mb(
     &k_sym+h1b-1),int_mb(k_sym+p12b-1)))) .eq. irrep_v) THEN
      IF ((.not.restricted).or.(int_mb(k_spin+p4b-1)+int_mb(k_spin+p5b-1
     &)+int_mb(k_spin+h1b-1)+int_mb(k_spin+p12b-1).ne.8)) THEN
      length = length + 1
      END IF
      END IF
      END IF
      END DO
      END DO
      END DO
      END DO
      IF (.not.MA_PUSH_GET(mt_int,2*length+1,'noname',l_a_offset,k_a_off
     &set)) CALL ERRQUIT('eomccsdt_x3_2_1',0,MA_ERR)
      int_mb(k_a_offset) = length
      addr = 0
      size = 0
      DO p4b = noab+1,noab+nvab
      DO p5b = p4b,noab+nvab
      DO h1b = 1,noab
      DO p12b = noab+1,noab+nvab
      IF (int_mb(k_spin+p4b-1)+int_mb(k_spin+p5b-1) .eq. int_mb(k_spin+h
     &1b-1)+int_mb(k_spin+p12b-1)) THEN
      IF (ieor(int_mb(k_sym+p4b-1),ieor(int_mb(k_sym+p5b-1),ieor(int_mb(
     &k_sym+h1b-1),int_mb(k_sym+p12b-1)))) .eq. irrep_v) THEN
      IF ((.not.restricted).or.(int_mb(k_spin+p4b-1)+int_mb(k_spin+p5b-1
     &)+int_mb(k_spin+h1b-1)+int_mb(k_spin+p12b-1).ne.8)) THEN
      addr = addr + 1
      int_mb(k_a_offset+addr) = p12b - noab - 1 + nvab * (h1b - 1 + noab
     & * (p5b - noab - 1 + nvab * (p4b - noab - 1)))
      int_mb(k_a_offset+length+addr) = size
      size = size + int_mb(k_range+p4b-1) * int_mb(k_range+p5b-1) * int_
     &mb(k_range+h1b-1) * int_mb(k_range+p12b-1)
      END IF
      END IF
      END IF
      END DO
      END DO
      END DO
      END DO
      RETURN
      END
      SUBROUTINE OFFSET_eomccsdt_x3_2_3_1(l_a_offset,k_a_offset,size)
C     $Id$
C     This is a Fortran77 program generated by Tensor Contraction Engine v.1.0
C     Copyright (c) Battelle & Pacific Northwest National Laboratory (2002)
C     i2 ( h7 h8 h1 p12 )_v
      IMPLICIT NONE
#include "global.fh"
#include "mafdecls.fh"
#include "sym.fh"
#include "errquit.fh"
#include "tce.fh"
      INTEGER l_a_offset
      INTEGER k_a_offset
      INTEGER size
      INTEGER length
      INTEGER addr
      INTEGER h7b
      INTEGER h8b
      INTEGER h1b
      INTEGER p12b
      length = 0
      DO h7b = 1,noab
      DO h8b = h7b,noab
      DO h1b = 1,noab
      DO p12b = noab+1,noab+nvab
      IF (int_mb(k_spin+h7b-1)+int_mb(k_spin+h8b-1) .eq. int_mb(k_spin+h
     &1b-1)+int_mb(k_spin+p12b-1)) THEN
      IF (ieor(int_mb(k_sym+h7b-1),ieor(int_mb(k_sym+h8b-1),ieor(int_mb(
     &k_sym+h1b-1),int_mb(k_sym+p12b-1)))) .eq. irrep_v) THEN
      IF ((.not.restricted).or.(int_mb(k_spin+h7b-1)+int_mb(k_spin+h8b-1
     &)+int_mb(k_spin+h1b-1)+int_mb(k_spin+p12b-1).ne.8)) THEN
      length = length + 1
      END IF
      END IF
      END IF
      END DO
      END DO
      END DO
      END DO
      IF (.not.MA_PUSH_GET(mt_int,2*length+1,'noname',l_a_offset,k_a_off
     &set)) CALL ERRQUIT('eomccsdt_x3_2_3_1',0,MA_ERR)
      int_mb(k_a_offset) = length
      addr = 0
      size = 0
      DO h7b = 1,noab
      DO h8b = h7b,noab
      DO h1b = 1,noab
      DO p12b = noab+1,noab+nvab
      IF (int_mb(k_spin+h7b-1)+int_mb(k_spin+h8b-1) .eq. int_mb(k_spin+h
     &1b-1)+int_mb(k_spin+p12b-1)) THEN
      IF (ieor(int_mb(k_sym+h7b-1),ieor(int_mb(k_sym+h8b-1),ieor(int_mb(
     &k_sym+h1b-1),int_mb(k_sym+p12b-1)))) .eq. irrep_v) THEN
      IF ((.not.restricted).or.(int_mb(k_spin+h7b-1)+int_mb(k_spin+h8b-1
     &)+int_mb(k_spin+h1b-1)+int_mb(k_spin+p12b-1).ne.8)) THEN
      addr = addr + 1
      int_mb(k_a_offset+addr) = p12b - noab - 1 + nvab * (h1b - 1 + noab
     & * (h8b - 1 + noab * (h7b - 1)))
      int_mb(k_a_offset+length+addr) = size
      size = size + int_mb(k_range+h7b-1) * int_mb(k_range+h8b-1) * int_
     &mb(k_range+h1b-1) * int_mb(k_range+p12b-1)
      END IF
      END IF
      END IF
      END DO
      END DO
      END DO
      END DO
      RETURN
      END
      SUBROUTINE OFFSET_eomccsdt_x3_3_1(l_a_offset,k_a_offset,size)
C     $Id$
C     This is a Fortran77 program generated by Tensor Contraction Engine v.1.0
C     Copyright (c) Battelle & Pacific Northwest National Laboratory (2002)
C     i1 ( h10 h1 )_f
      IMPLICIT NONE
#include "global.fh"
#include "mafdecls.fh"
#include "sym.fh"
#include "errquit.fh"
#include "tce.fh"
      INTEGER l_a_offset
      INTEGER k_a_offset
      INTEGER size
      INTEGER length
      INTEGER addr
      INTEGER h10b
      INTEGER h1b
      length = 0
      DO h10b = 1,noab
      DO h1b = 1,noab
      IF (int_mb(k_spin+h10b-1) .eq. int_mb(k_spin+h1b-1)) THEN
      IF (ieor(int_mb(k_sym+h10b-1),int_mb(k_sym+h1b-1)) .eq. irrep_f) T
     &HEN
      IF ((.not.restricted).or.(int_mb(k_spin+h10b-1)+int_mb(k_spin+h1b-
     &1).ne.4)) THEN
      length = length + 1
      END IF
      END IF
      END IF
      END DO
      END DO
      IF (.not.MA_PUSH_GET(mt_int,2*length+1,'noname',l_a_offset,k_a_off
     &set)) CALL ERRQUIT('eomccsdt_x3_3_1',0,MA_ERR)
      int_mb(k_a_offset) = length
      addr = 0
      size = 0
      DO h10b = 1,noab
      DO h1b = 1,noab
      IF (int_mb(k_spin+h10b-1) .eq. int_mb(k_spin+h1b-1)) THEN
      IF (ieor(int_mb(k_sym+h10b-1),int_mb(k_sym+h1b-1)) .eq. irrep_f) T
     &HEN
      IF ((.not.restricted).or.(int_mb(k_spin+h10b-1)+int_mb(k_spin+h1b-
     &1).ne.4)) THEN
      addr = addr + 1
      int_mb(k_a_offset+addr) = h1b - 1 + noab * (h10b - 1)
      int_mb(k_a_offset+length+addr) = size
      size = size + int_mb(k_range+h10b-1) * int_mb(k_range+h1b-1)
      END IF
      END IF
      END IF
      END DO
      END DO
      RETURN
      END
      SUBROUTINE OFFSET_eomccsdt_x3_3_2_1(l_a_offset,k_a_offset,size)
C     $Id$
C     This is a Fortran77 program generated by Tensor Contraction Engine v.1.0
C     Copyright (c) Battelle & Pacific Northwest National Laboratory (2002)
C     i2 ( h10 p11 )_f
      IMPLICIT NONE
#include "global.fh"
#include "mafdecls.fh"
#include "sym.fh"
#include "errquit.fh"
#include "tce.fh"
      INTEGER l_a_offset
      INTEGER k_a_offset
      INTEGER size
      INTEGER length
      INTEGER addr
      INTEGER h10b
      INTEGER p11b
      length = 0
      DO h10b = 1,noab
      DO p11b = noab+1,noab+nvab
      IF (int_mb(k_spin+h10b-1) .eq. int_mb(k_spin+p11b-1)) THEN
      IF (ieor(int_mb(k_sym+h10b-1),int_mb(k_sym+p11b-1)) .eq. irrep_f) 
     &THEN
      IF ((.not.restricted).or.(int_mb(k_spin+h10b-1)+int_mb(k_spin+p11b
     &-1).ne.4)) THEN
      length = length + 1
      END IF
      END IF
      END IF
      END DO
      END DO
      IF (.not.MA_PUSH_GET(mt_int,2*length+1,'noname',l_a_offset,k_a_off
     &set)) CALL ERRQUIT('eomccsdt_x3_3_2_1',0,MA_ERR)
      int_mb(k_a_offset) = length
      addr = 0
      size = 0
      DO h10b = 1,noab
      DO p11b = noab+1,noab+nvab
      IF (int_mb(k_spin+h10b-1) .eq. int_mb(k_spin+p11b-1)) THEN
      IF (ieor(int_mb(k_sym+h10b-1),int_mb(k_sym+p11b-1)) .eq. irrep_f) 
     &THEN
      IF ((.not.restricted).or.(int_mb(k_spin+h10b-1)+int_mb(k_spin+p11b
     &-1).ne.4)) THEN
      addr = addr + 1
      int_mb(k_a_offset+addr) = p11b - noab - 1 + nvab * (h10b - 1)
      int_mb(k_a_offset+length+addr) = size
      size = size + int_mb(k_range+h10b-1) * int_mb(k_range+p11b-1)
      END IF
      END IF
      END IF
      END DO
      END DO
      RETURN
      END
      SUBROUTINE OFFSET_eomccsdt_x3_4_1(l_a_offset,k_a_offset,size)
C     $Id$
C     This is a Fortran77 program generated by Tensor Contraction Engine v.1.0
C     Copyright (c) Battelle & Pacific Northwest National Laboratory (2002)
C     i1 ( p4 p10 )_f
      IMPLICIT NONE
#include "global.fh"
#include "mafdecls.fh"
#include "sym.fh"
#include "errquit.fh"
#include "tce.fh"
      INTEGER l_a_offset
      INTEGER k_a_offset
      INTEGER size
      INTEGER length
      INTEGER addr
      INTEGER p4b
      INTEGER p10b
      length = 0
      DO p4b = noab+1,noab+nvab
      DO p10b = noab+1,noab+nvab
      IF (int_mb(k_spin+p4b-1) .eq. int_mb(k_spin+p10b-1)) THEN
      IF (ieor(int_mb(k_sym+p4b-1),int_mb(k_sym+p10b-1)) .eq. irrep_f) T
     &HEN
      IF ((.not.restricted).or.(int_mb(k_spin+p4b-1)+int_mb(k_spin+p10b-
     &1).ne.4)) THEN
      length = length + 1
      END IF
      END IF
      END IF
      END DO
      END DO
      IF (.not.MA_PUSH_GET(mt_int,2*length+1,'noname',l_a_offset,k_a_off
     &set)) CALL ERRQUIT('eomccsdt_x3_4_1',0,MA_ERR)
      int_mb(k_a_offset) = length
      addr = 0
      size = 0
      DO p4b = noab+1,noab+nvab
      DO p10b = noab+1,noab+nvab
      IF (int_mb(k_spin+p4b-1) .eq. int_mb(k_spin+p10b-1)) THEN
      IF (ieor(int_mb(k_sym+p4b-1),int_mb(k_sym+p10b-1)) .eq. irrep_f) T
     &HEN
      IF ((.not.restricted).or.(int_mb(k_spin+p4b-1)+int_mb(k_spin+p10b-
     &1).ne.4)) THEN
      addr = addr + 1
      int_mb(k_a_offset+addr) = p10b - noab - 1 + nvab * (p4b - noab - 1
     &)
      int_mb(k_a_offset+length+addr) = size
      size = size + int_mb(k_range+p4b-1) * int_mb(k_range+p10b-1)
      END IF
      END IF
      END IF
      END DO
      END DO
      RETURN
      END
      SUBROUTINE OFFSET_eomccsdt_x3_5_1(l_a_offset,k_a_offset,size)
C     $Id$
C     This is a Fortran77 program generated by Tensor Contraction Engine v.1.0
C     Copyright (c) Battelle & Pacific Northwest National Laboratory (2002)
C     i1 ( h11 h12 h1 h2 )_v
      IMPLICIT NONE
#include "global.fh"
#include "mafdecls.fh"
#include "sym.fh"
#include "errquit.fh"
#include "tce.fh"
      INTEGER l_a_offset
      INTEGER k_a_offset
      INTEGER size
      INTEGER length
      INTEGER addr
      INTEGER h11b
      INTEGER h12b
      INTEGER h1b
      INTEGER h2b
      length = 0
      DO h11b = 1,noab
      DO h12b = h11b,noab
      DO h1b = 1,noab
      DO h2b = h1b,noab
      IF (int_mb(k_spin+h11b-1)+int_mb(k_spin+h12b-1) .eq. int_mb(k_spin
     &+h1b-1)+int_mb(k_spin+h2b-1)) THEN
      IF (ieor(int_mb(k_sym+h11b-1),ieor(int_mb(k_sym+h12b-1),ieor(int_m
     &b(k_sym+h1b-1),int_mb(k_sym+h2b-1)))) .eq. irrep_v) THEN
      IF ((.not.restricted).or.(int_mb(k_spin+h11b-1)+int_mb(k_spin+h12b
     &-1)+int_mb(k_spin+h1b-1)+int_mb(k_spin+h2b-1).ne.8)) THEN
      length = length + 1
      END IF
      END IF
      END IF
      END DO
      END DO
      END DO
      END DO
      IF (.not.MA_PUSH_GET(mt_int,2*length+1,'noname',l_a_offset,k_a_off
     &set)) CALL ERRQUIT('eomccsdt_x3_5_1',0,MA_ERR)
      int_mb(k_a_offset) = length
      addr = 0
      size = 0
      DO h11b = 1,noab
      DO h12b = h11b,noab
      DO h1b = 1,noab
      DO h2b = h1b,noab
      IF (int_mb(k_spin+h11b-1)+int_mb(k_spin+h12b-1) .eq. int_mb(k_spin
     &+h1b-1)+int_mb(k_spin+h2b-1)) THEN
      IF (ieor(int_mb(k_sym+h11b-1),ieor(int_mb(k_sym+h12b-1),ieor(int_m
     &b(k_sym+h1b-1),int_mb(k_sym+h2b-1)))) .eq. irrep_v) THEN
      IF ((.not.restricted).or.(int_mb(k_spin+h11b-1)+int_mb(k_spin+h12b
     &-1)+int_mb(k_spin+h1b-1)+int_mb(k_spin+h2b-1).ne.8)) THEN
      addr = addr + 1
      int_mb(k_a_offset+addr) = h2b - 1 + noab * (h1b - 1 + noab * (h12b
     & - 1 + noab * (h11b - 1)))
      int_mb(k_a_offset+length+addr) = size
      size = size + int_mb(k_range+h11b-1) * int_mb(k_range+h12b-1) * in
     &t_mb(k_range+h1b-1) * int_mb(k_range+h2b-1)
      END IF
      END IF
      END IF
      END DO
      END DO
      END DO
      END DO
      RETURN
      END
