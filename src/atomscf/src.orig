* $Id$
      function osatod(iat,ic,iiloc,iisch,nbb)
c
      implicit none
      integer nbb, iat
      integer ic(6,nbb),iiloc(nbb,6),iisch(nbb,6)
      logical osatod
c
c...   function checks if this atom is the same as one for which info
c...   is in /cguess/ and from which we can use the density matrix
c...   for atomic startup
c...   if so osatod is true  and iiloc is updated
c...
c...   commons where information comes from :
c
#include "int.h"
      integer  kmin, kmax, nuct
      common /iguess/ kmin(mxshell), kmax(mxshell), nuct(mxnat)
c
c...   common where info goes to :
c
c
      integer nb, no
      parameter (nb=100, no=50)
      integer nsym, nbas, ncsh, nosh, nccup, nsht, nitscf, n1, nqn
      integer nconv, nbc, nbct, nstrt, ifcont
      real *8 zn, zeta, eps, cin, vir, energ, ajmn, damp, cont
      common /cguess/nsym,nbas(5),ncsh(5),nosh(5),nccup(6),nsht,nitscf,
     + zn,n1(6),nqn(nb),zeta(nb),eps(no),cin,vir,energ,ajmn(24),damp,
     + nconv,nbc(5),cont(nb),nbct,nstrt(nb),ifcont
c
      integer nbcn(5)
c..
      real *8 pi32, fac, ee, contn
      integer i, ii, iorb, ispdf, j, k
      integer mini, maxi, kk, if, is, kkzc, kh, isymax, nbasn
c
      data pi32/5.56832799683170d0/
c..
      osatod = .false.
      if (zan(iat).ne.zn) return
c
c...  gather  shell / symmetry info
c
      do i = 1 , 4
         nbcn(i) = 0
      enddo
c
c.. nbc  # shell's / symmetry
c.. iisch  contains index of shell
c.. iiloc  contains position of starting ao of shell in "real" world
c..  translate to 1 (s)
c
      do ii = 1 , nshell
         i = katom(ii)
         if (i.eq.iat) then
            mini = kmin(ii)
            maxi = kmax(ii)
            kk = ktype(ii)
            if (kk.eq.6) kk = 2
            do iorb = mini , maxi
               if (iorb.eq.1) then
                  nbcn(1) = nbcn(1) + 1
                  iisch(nbcn(1),1) = ii
                  iiloc(nbcn(1),1) = kloc(ii)
               else if (iorb.eq.2 .or. iorb.eq.5 .or. iorb.eq.11) then
c..  translate to 2 (p) 3(d) or  4(f)
                  ispdf = kk
                  nbcn(ispdf) = nbcn(ispdf) + 1
                  iisch(nbcn(ispdf),ispdf) = ii
                  iiloc(nbcn(ispdf),ispdf) = kloc(ii) + iorb - mini
               end if
            enddo
         end if
      enddo
c..     check nbcn
      do i = 1 , 4
         if (nbc(i).ne.nbcn(i)) return
      enddo
c..
c..     we gathered symmetry/shell info ; now check the real thing
c..
      kkzc = 0
      kh = 0
      isymax = 0
      do ispdf = 1 , 4
c..      nbas = total # primitives for this symmetry
         nbasn = 0
         if (nbc(ispdf).gt.0) isymax = ispdf
         do j = 1 , nbc(ispdf)
            ii = iisch(j,ispdf)
            is = kstart(ii)
            if = is + kng(ii) - 1
c..      ic = # number of primitives /contracted /symmetry
            if (ic(ispdf,j).ne.kng(ii)) return
            nbasn = nbasn + kng(ii)
c..      check the primitives / watch the subtle use of 2-dim cspd
            do k = is , if
               kkzc = kkzc + 1
               if (zeta(kkzc).ne.ex(k)) return
               contn = cspd(k,ispdf)
c...     get contraction coeff's as we are used to
               ee = 2*zeta(kkzc)
               fac = pi32/(ee*sqrt(ee))
               if (ispdf.eq.2) then
                  fac = 0.5d0*fac/ee
               else if (ispdf.eq.3) then
                  fac = 0.75d0*fac/(ee*ee)
               else if (ispdf.eq.4) then
                  fac = 1.875d0*fac/(ee**3)
               end if
               contn = contn*sqrt(fac)
               if (cont(kkzc).ne.contn) return
            enddo
         enddo
c...
         if (nbasn.ne.nbas(ispdf)) return
c...
      enddo
c..
c..      all checks out
c..
      osatod = .true.
c..
      return
      end
      subroutine atomd(oprin,iwr,znps,ic,isymax,hatom,
     + pcap,qcap,fc,fo,s,u,t,h,dc,dos,dt,dold,ss,
c
      implicit none
c
      logical oprin
      integer iwr, nbb, isymax
      integer ic(6,*)
      real *8  pcap(*), qcap(*), fc(*), fo(*), s(*), u(*), t(*)
      real *8  h(*), dc(*), dos(*), dt(*), dold(*), ss(*), hatom(*)
      real *8  c(*),copn(*),smin(nbb,*),qmin(nbb,*),transf(*),cc(*)
      real *8 znps
c
c.......................................................................
c     atomic r h f code for gto's. uses roothaan double diagonalization.
c.......................................................................
c
c      routine datoms .. tramad are a totally separate unit
c      they use commom cguess to communicate
c      oprin,iwr are new parameters to control printing
c      hatom are the pseudo-corrections in the contracted basis from gam
c            they replace atom's own integrals
c.......................................................................
c
      integer nsym, nbas, ncsh, nosh, nccup, nsht, nitscf, n1, nqn
      integer nconv, nbc, nbct, nstrt, ifcont
      integer nb, no
      real *8 zn, zeta, eps, cin, vir, energ, ajmn, damp, cont
      parameter (nb=100, no=50)
      common /cguess/nsym,nbas(5),ncsh(5),nosh(5),nccup(6),nsht,nitscf,
     + zn,n1(6),nqn(nb),zeta(nb),eps(no),cin,vir,energ,ajmn(24),damp,
     + nconv,nbc(5),cont(nb),nbct,nstrt(nb),ifcont
c
      integer i, j, l, m
      integer nbcdim, jcount, k, iant, ksum
      integer noff, nbci, ll, mm, ndim, nsqt, ns, maxitr, lm
      integer nstep1, nstep2, knteps, nbc1, nbc2, nbc3, icount, idum
      real *8 znsave, tlarge
c
c     nsht      = total number of shells
c     n1(i)     = nbas(i) * (nbas(i) + 1 ) / 2
c     nbc(i)    = number of cont. orbitals in symmetry i
c     cont(i)   = contraction coeff. assosiated with primitive no. i
c     nstrt(i)  = number for first primitive in cont. no. i
c     nbct      = total number of cont. basis functions.
c.......................................................................
      if (dabs(zn).ge.1.d-8) then
c.......................................................................
c
c     distribute electrons according to aufbau
c.......................................................................
         call atcond(zn,ncsh,nosh,nccup,ajmn,nsym,znps)
crz
c     fix for use of pseudopotentials
         znsave = zn
         zn = znps
c.......................................................................
c
c     move basis set information from transfer variables to working
c     variables. ** not necessary in present version
c.......................................................................
         nbct = 0
         ndim = 0
         nsqt = 0
         nbcdim = 0
         jcount = 0
         nsht = 0
         k = 0
         do i = 1 , nsym
            n1(i) = nbas(i)*(nbas(i)+1)/2
            nbcdim = nbcdim + nbc(i)*(nbc(i)+1)/2
            ndim = ndim + n1(i)
            nsht = nsht + ncsh(i) + nosh(i)
            nsqt = nsqt + nbas(i)**2
            nbct = nbct + nbc(i)
            do j = 1 , nbas(i)
               jcount = jcount + 1
               nqn(jcount) = i
            enddo
            do j = 1 , n1(i)
               k = k + 1
               dold(k) = 0.0d0
            enddo
         enddo
         ns = 1
         nstrt(ns) = 1
         do l = 1 , nsym
            iant = nbc(l)
            ksum = 0
            do i = 1 , iant
               nstrt(ns+i) = nstrt(ns+i-1) + ic(l,i)
               ksum = ksum + ic(l,i)
            enddo
            if (ksum.ne.nbas(l)) write (iwr,6020) l , ksum , nbas(l)
            ns = ns + iant
         enddo
         do i = 1 , nsqt
            c(i) = 0.d0
            copn(i) = 0.0d0
            cc(i) = 0.d0
         enddo
         do i = 1 , ndim
            dold(i) = 0.0d0
         enddo
cjvl  few extra checks
         do i=1,nsym
            if (nbc(i).lt.ncsh(i)+nosh(i)) then
               oprin = .true.
               ndim = 0
            end if
         enddo
cjvl      
         if (oprin) write (iwr,6030) zn
         if (oprin) write (iwr,6040) (nbas(i),i=1,nsym)
         if (oprin) write (iwr,6050) (nbc(i),i=1,nsym)
         if (oprin) write (iwr,6060) (ncsh(i),i=1,nsym)
         if (oprin) write (iwr,6070) (nosh(i),i=1,nsym)
         if (oprin) write (iwr,6080) (nccup(i),i=1,nsym)
cjvl
         if (ndim.eq.0) call errquit('error in atom scf',0,
     &       UNKNOWN_ERR)
cjvl
         maxitr = 100
c..
c..     calculate 1-electron ints
c..
         call oeigd(fc,s,u,t,h)
c.......................................................................
c
c     copy overlap matrix to ss
c.......................................................................
         do i = 1 , ndim
            ss(i) = s(i)
            fc(i) = s(i)
         enddo
c.......................................................................
c
c     now transform ss to contracted basis, then set up transformation
c     matrix to o.n. contracted basis.
c.......................................................................
         call trafsd(nsym,nbas,ndim,ss,nbc,cont,nstrt,dc)
         call trafsd(nsym,nbas,ndim,fc,nbc,cont,nstrt,dc)
c...
         nstep1 = 1
         nstep2 = 1
         do i = 1 , nsym
crz      to surpress problems when there is one type of shell missing...
            if (nbc(i).ne.0) then
               call shalfd(fc(nstep1),transf(nstep2),nbc(i))
               call starcd(cc(nstep2),ss(nstep1),nbc(i),ncsh(i),
     +                     nosh(i))
               nstep1 = nstep1 + nbc(i)*(nbc(i)+1)/2
               nstep2 = nstep2 + nbc(i)**2
            end if
         enddo
         nitscf = 0
         nconv = 0
         damp = .30d0
         if (znsave.eq.30.0d0) then
            damp = .9d0
            maxitr = 200
c         print *,' zn is special ',damp,maxitr
         end if
 110     nitscf = nitscf + 1
c.......................................................................
c
c     transform vectors and set up matrices in primitive basis,
c     then transform fock matrices to contracted basis.
c.......................................................................
         call tracd(c,cc,nsqt,nsym, nbas, ncsh, nosh, nbc,nstrt,
     +                 cont)
         call densid(dt,dold,dos,nsym,nosh,ncsh,nccup,c,damp,nconv,nbas,
     +               nitscf,tlarge)
c
c... check for convergence on tlarge (max change of d-matrix)
c
         if (tlarge.le.1.0d-5) nconv = 1
         if (nitscf+20.ge.maxitr) then
            write (iwr,6010) nitscf , energ , tlarge
         end if
c
         call hamild(pcap,qcap,fc,fo,s,u,t,h,dos,dt,c,smin,qmin,nbb)
         call trafsd(nsym,nbas,ndim,fc,nbc,cont,nstrt,dc)
         call trafsd(nsym,nbas,ndim,fo,nbc,cont,nstrt,dc)
c...
c...    now add the h-pseudo-contributions (from xpsnld)
c...
         do i = 1 , ndim
            fc(i) = fc(i) + hatom(i)
            fo(i) = fo(i) + hatom(i)
         enddo
c.......................................................................
c
c     do double diagonalization by symmetries:
c         1. transform block to o.n.basis (contracted).
c         2. store o.n. transformation matrix in vector matrix.
c         3. diagonalize.
c         4. order eigenvectors by eigenvalue.
c         5. if necessary, merge open and closed vectors.
c.......................................................................
         nstep1 = 1
         nstep2 = 1
         knteps = 0
         do i = 1 , nsym
            nbc1 = nbc(i)
            nbc2 = nbc1**2
            nbc3 = (nbc2+nbc1)/2
            if (ncsh(i).ne.0) then
               call tramad(fc(nstep1),transf(nstep2),dc,nbc3,nbc1,dt)
               call dcopy(nbc2,transf(nstep2),1,cc(nstep2),1)
               call jacod(fc(nstep1),cc(nstep2),nbc1,n1(i),nbc2,1,nbc1,
     +                    dc,dt,nbc1)
            end if
            if (nosh(i).ne.0) then
               call tramad(fo(nstep1),transf(nstep2),dc,nbc3,nbc1,dt)
               call dcopy(nbc2,transf(nstep2),1,copn(nstep2),1)
               call jacod(fo(nstep1),copn(nstep2),nbc1,n1(i),nbc2,1,
     +                    nbc1,dc,dt,nbc1)
            end if
            icount = nstep1
            do j = 1 , nbc1
               dc(j) = fc(icount)
               dos(j) = fo(icount)
               icount = icount + 1 + j
            enddo
            call orderd(cc(nstep2),nbc1,nbc1,idum,idum,dt,dc,100)
            if (nosh(i).gt.0) then
               call orderd(copn(nstep2),nbc1,nbc1,idum,idum,dt,dos,100)
               call cmergd(cc(nstep2),copn(nstep2),ncsh(i),nbc1,nosh(i))
            end if
            nstep1 = nstep1 + nbc1*(nbc1+1)/2
            nstep2 = nstep2 + nbc2
            if (nconv.gt.0) then
               if (ncsh(i).gt.0) then
                  do j = 1 , ncsh(i)
                     knteps = knteps + 1
                     eps(knteps) = dc(j)
                  enddo
               end if
               if (nosh(i).gt.0) then
                  do j = 1 , nosh(i)
                     knteps = knteps + 1
                     eps(knteps) = dos(ncsh(i)+j)
                  enddo
               end if
            end if
         enddo
         if (nitscf.ge.maxitr) nconv = 1
         if (nconv.le.0) go to 110
         if (oprin) then
            call outpud(copn,cc,1,iwr)
         else
            call outpud(copn,cc,0,iwr)
         end if
         call densid(dt,dold,dos,nsym,nosh,ncsh,nccup,cc,damp,nconv,nbc,
     +               nitscf,tlarge)
         lm = 0
         do i = 1 , nsym
            noff = lm
            nbci = nbc(i)
            do l = 1 , nbci
               ll = noff + l*(l+1)/2
               do m = 1 , l
                  mm = noff + m*(m+1)/2
                  lm = lm + 1
                  dt(lm) = dt(lm)*sqrt(ss(ll)*ss(mm))
                  if (m.ne.l) dt(lm) = dt(lm)/2.0d0
               enddo
            enddo
         enddo
      else
c.......................................................................
c
c     special section for handling the case of floating functions
c     on centers with no charge.
c.......................................................................
         nbcdim = 0
         do i = 1 , isymax
            nbcdim = nbcdim + nbc(i)*(nbc(i)+1)/2
         enddo
         do i = 1 , nbcdim
            dt(i) = 0.0d0
         enddo
         nsym = isymax
         energ = 0.0d0
      end if
c
      return
 6010 format (' it.',i4,'  energy',d19.10,'  div.',d13.5)
 6020 format ('-',' wrong contraction in symmetry   ',3i5)
 6030 format (/'      charge =',f10.6,//'      symmetry species',12x,
     +        's',5x,'p',5x,'d',5x,'f')
 6040 format (6x,'number of basis functions =',4(i2,4x))
 6050 format (6x,'number of cont. functions =',4(i2,4x))
 6060 format (6x,'number of closed shells   =',4(i2,4x))
 6070 format (6x,'number of open shells     =',4(i2,4x))
 6080 format (6x,'open shell occupation     =',4(i2,4x))
      end
      implicit none
c.......................................................................
c
c     for atom of nuclear charge zn find electron configuration
c     and k(l,l,0) coupling coefficient. simple aufbau is
c     assumed throughout the periodic system. the algorithm used
c     will work for zn less than 119.
c
c     to allow for pseudo-potentials the effective charge znps
c     is used to determine the number of closed shells filled
c     jvl  (daresbury 1988): corrected July 93
c.......................................................................
      real *8 zn, znps
      real *8 ajmn(*)
      integer ncsh(*),nccup(*),nosh(*)
      integer nelhw(103),nelcep(103)
      integer isymhw(13)
      integer isymce(13)
      integer nsym
c
      integer i, j, k, nz, nlast, ksym, ihw
      integer nzps, idiff, nshell, isymm, nelec
      real *8 t, f
c
      data isymhw / 1,1,2,1,2, 3,1,2, 3,1,2, 4, 3/
      data isymce / 1,1,2,1,2, 3,1,2, 3, 4,1,2, 3/
      data nelhw/
     $         0, 0,
     $         2, 2, 2, 2, 2, 2, 2, 2,
     $         10, 10, 10, 10, 10, 10, 10, 10,
     $         18, 18,
     $                     18, 18, 18, 18, 18,
     $                     18, 18, 18, 18, 18,
     $                     28, 28, 28, 28, 28, 28,
     $ 36,36,36,36,36,36,36,36,36,36,36,36,
     $ 46,46,46,46,46,46,54,54,54,0,0,0,
     $ 0,0,0,0,0,0,0,0,0,0,0,68,
     $ 68,68,68,68,68,68,68,68,68,78,78,0,
     $ 0,0,0,0,0,0,0,0,0,0,0,0,
     $ 0,0,0,0,0,0,0   /
      data nelcep /
     $         0, 0,
     $         2, 2, 2, 2, 2, 2, 2, 2,
     $         10, 10, 10, 10, 10, 10, 10, 10,
     $         18, 18,
     $                     10, 10, 10, 10, 10,
     $                     10, 10, 10, 10, 10,
     $                     10, 28, 28, 28, 28, 28,
     $ 36,36,28,28,28,28,28,28,28,28,28,28,
     $ 28,46,46,46,46,46,54,54,46,0,0,0,
     $ 0,0,0,0,0,0,0,0,0,0,0,60,
     $ 60,60,60,60,60,60,60,60,60,78,78,78,
     $ 78,78,0,0,0,0,0,0,0,0,0,0,
     $ 0,0,0,0,0,0,0   /
c.......................................................................
c     initialize .
c.......................................................................
      nsym = 0
      do i = 1 , 4
         ncsh(i) = 0
         nosh(i) = 0
         nccup(i) = 0
      enddo
c.......................................................................
      nz = zn + 0.1d0
      nzps = znps + 0.1d0
      idiff = nz - nzps
      ihw = 0
      if (idiff.ne.0) then
c     determine pseudopotential type (hw or cep)
       if (nelhw(nz).eq.idiff) then
         ihw = 1
       else if (nelcep(nz).eq.idiff) then
         ihw = 2
       else
         call errquit('unrecognised pseudopotential',0,
     &       UNKNOWN_ERR)
       endif
      endif
      nzps = idiff
c.......................................................................
c
c     fill up shells - all electron first
c.......................................................................
      nlast = 0
       do i = 1 , 4
          do j = 1 , 2
             ksym = i
             do k = 1 , i
                nshell = nlast + 4*ksym - 2
                if (nz.lt.nshell) go to 60
                nsym = max0(nsym,ksym)
                ncsh(ksym) = ncsh(ksym) + 1
                ksym = ksym - 1
                nlast = nshell
             enddo
          enddo
       enddo
c.......................................................................
c
c     check if open shell atom. test for la and ac.
c.......................................................................
 60   if (nz.eq.57 .or. nz.eq.89) then
         ncsh(4) = ncsh(4) - ncsh(4)/2
         ksym = 3
      end if
c
c ... now consider pseudopotentials ...
c ... decrease ncsh according to nelcor (nzps)
c     
      if (nzps.gt.0) then
       nelec = 0
       if(ihw.eq.1) then
        do i = 1,13
        nelec = nelec + 4*isymhw(i) - 2
        if (nelec.le.nzps) then
         isymm = isymhw(i)
         ncsh(isymm) = ncsh(isymm) - 1
        else
        go to 90
        endif
       enddo
      else
        do i = 1,13
        nelec = nelec + 4*isymce(i) - 2
        if (nelec.le.nzps) then
         isymm = isymce(i)
         ncsh(isymm) = ncsh(isymm) - 1
        else
        go to 90
        endif
       enddo
       endif
      endif
c
c     check for cases where pseudo-potential changes  state
c     (cu  pseudo incl d10 => s1)
c
90    if (nz.eq.29.and.nzps.eq.28) then
         nlast = 28
         ksym = 1
      end if
c
      do i = 1 , 24
         ajmn(i) = 0.0d0
      enddo
      if (nz.ne.nlast) then
         nosh(ksym) = 1
         nsym = max(nsym,ksym)
         nccup(ksym) = nz - nlast
c.......................................................................
c
c     set k(l,l,0).
c.......................................................................
         i = ksym*(ksym+1)*(ksym+2)/6 - ksym + 1
         t = float(nccup(ksym))
         f = 4*ksym - 4
         ajmn(i) = -(f+1.0d0)/(f+2.0d0) + (t-1.0d0)/t
      end if
      return
      end
      subroutine cmergd(c1,c2,nc,nb,no)
      implicit none
c.......................................................................
c     merge open and closed shell coefficient matrices.
c.......................................................................
      integer nc, nb, no
      real *8  c1(nb,*), c2(nb,*)
c
      integer i, j
      integer nlast, nrow
c
      nlast = nc + no
      nrow = nc + 1
      do i = nrow , nlast
         do j = 1 , nb
            c1(j,i) = c2(j,i)
         enddo
      enddo
      return
      end





      subroutine denmad(d,c,ns,nb,occ,nrow)
      implicit none
c.......................................................................
c     make actual density matrices.
c.......................................................................
      integer ns, nb, nrow
      real *8  d(*), c(nb,nb), occ
c
      integer i, j, k
      integer icount, klast
      real *8 sum
c
      icount = 0
      do i = 1 , nb
         do j = 1 , i
            icount = icount + 1
            klast = nrow + ns - 1
            sum = 0.0d0
            do k = nrow , klast
               sum = sum + c(i,k)*c(j,k)
            enddo
            sum = sum*occ
            if (i.ne.j) sum = sum + sum
            d(icount) = sum
         enddo
      enddo
      return
      end


      subroutine densid(dt,dold,dos,nsym,nosh,ncsh,nccup,c,damp,nconv,
     x                 nbas,nitscf,tlarge)
c.......................................................................
c
c     driver routine for density matrix processing
c.......................................................................
      implicit none
c
      real *8 dt(*), dold(*), dos(*), c(*)
      real *8 damp, tlarge
      integer ncsh(*), nosh(*), nccup(*),  nbas(*)
      integer nsym, nconv, nitscf
c
      real *8 vamp1, vamp2, occucl, occuop, ddiff
      integer k, nstep1, nstep2, nbas1, icount
      integer i, m, n, j
c
      nstep1 = 1
      nstep2 = 1
      k = 0
      vamp1 = 1.0d0
      vamp2 = 0.0d0
      if (nitscf.gt.1 .and. nconv.eq.0) vamp1 = 1.0d0 - damp
      if (nitscf.gt.1 .and. nconv.eq.0) vamp2 = damp
      do i = 1 , nsym
         occucl = 4*i - 2
         occuop = nccup(i)
         nbas1 = nbas(i)
         do m = 1 , nbas1
            do n = 1 , m
               k = k + 1
               dt(k) = 0.0d0
               dos(k) = 0.0d0
            enddo
         enddo
         if (ncsh(i).ne.0) call denmad(dt(nstep1),c(nstep2),ncsh(i),
     +                                 nbas1,occucl,1)
         if (nosh(i).ne.0) call denmad(dos(nstep1),c(nstep2),nosh(i),
     +                                 nbas1,occuop,ncsh(i)+1)
         nstep1 = nstep1 + nbas1*(nbas1+1)/2
         nstep2 = nstep2 + nbas1**2
      enddo
      tlarge = 0.0d0
      icount = 0
      do i = 1 , nsym
         do j = 1 , nbas(i)
            do k = 1 , j
               icount = icount + 1
               dt(icount) = (dt(icount)+dos(icount))
     +                      *vamp1 + dold(icount)*vamp2
               ddiff = dabs(dt(icount)-dold(icount))
               dold(icount) = dt(icount)
               if (ddiff.gt.tlarge) then
                  tlarge = ddiff
               end if
            enddo
         enddo
      enddo
      return
      end
      subroutine hamild(pcap, qcap, fc, fo, s, u, t, h, dos, dt,
     +                  c, smin, qmin, nbb)
      implicit none
c.......................................................................
c
c     construct fock matrices. this is a direct s c f procedure,
c     and the two-electron integrals are recalculated for every
c     iteration.
c.......................................................................
      integer nb, no
      parameter (nb=100, no=50)
      integer nsym, nbas, ncsh, nosh, nccup, nsht, nitscf, n1, nqn
      integer nconv, nbc, nbct, nstrt, ifcont
      real *8 zn, zeta, eps, cin, vir, energ, ajmn, damp, cont
      common /cguess/nsym,nbas(5),ncsh(5),nosh(5),nccup(6),nsht,nitscf,
     + zn,n1(6),nqn(nb),zeta(nb),eps(no),cin,vir,energ,ajmn(24),damp,
     + nconv,nbc(5),cont(nb),nbct,nstrt(nb),ifcont
c
      integer nbb
      real *8  c(*), smin(nbb,*), qmin(nbb,*)
      real *8  pcap(*), qcap(*), fc(*), fo(*), s(*)
      real *8  u(*), t(*), h(*), dos(*), dt(*)
c
      integer i, j, m, n
      integer nstep1, nstep2, nstep, nsh, nbas1, naddr, j1
      integer k, nosh1
      real *8 occucl, fact1, fact2, term1, term2
c
      call teigd (pcap, qcap, u, t, dt, dos)
c.......................................................................
c     compute smin and qmin
c.......................................................................
      nstep1 = 0
      nstep2 = 0
      nstep = 0
      do 50 i = 1 , nsym
         nsh = ncsh(i) + nosh(i)
         nbas1 = nbas(i)
         do j = 1 , nsh
            naddr = nstep2 + (j-1)*nbas1
            j1 = nstep + j
            do m = 1 , nbas1
               smin(m,j1) = 0.d0
               qmin(m,j1) = 0.d0
               do n = 1 , nbas1
                  k = max(m,n)*(max(m,n)-1)/2 + min(m,n) + nstep1
                  smin(m,j1) = smin(m,j1) + s(k)*c(n+naddr)
                  qmin(m,j1) = qmin(m,j1) + qcap(k)*c(n+naddr)
               enddo
            enddo
         enddo
         nstep = nstep + nsh
         nstep2 = nstep2 + nbas1**2
         nstep1 = nstep1 + n1(i)
 50   continue
c.......................................................................
c     compute fc and fo
c.......................................................................
      k = 1
      nstep = 0
      do i = 1 , nsym
         occucl = 4*i - 2
         nosh1 = nosh(i)
         nsh = ncsh(i) + nosh1
         fact1 = occucl/(occucl-nccup(i))
         fact2 = nccup(i)/(occucl-nccup(i))
         nbas1 = nbas(i)
         do m = 1 , nbas1
            do n = 1 , m
               term1 = 0.d0
               term2 = 0.d0
               do j = 1 , nsh
                  j1 = j + nstep
                  if (j.ne.nsh .or. nosh1.eq.0) then
                     term1 = term1 + smin(m,j1)*qmin(n,j1) + qmin(m,j1)
     +                       *smin(n,j1)
                  else
                     term2 = smin(m,j1)*qmin(n,j1) + qmin(m,j1)
     +                       *smin(n,j1)
                  end if
               enddo
               fo(k) = fact1*term1 + pcap(k) + h(k) - qcap(k)
               fc(k) = fact2*term2 + pcap(k) + h(k)
               k = k + 1
            enddo
         enddo
         nstep = nstep + nsh
      enddo
      return
      end
      subroutine jacod(f,v,nb,nb1,nb2,nmin,nmax,big,jbig,maxao)
      implicit none
c.......................................................................
c      f is the matrix to be diagonalized. f is stored triangular
c      v is the array of eigenvectors. quadratic array, dimension nb*nb
c      big and jbig are temporary scratch areas of dimension nb
c      the rotations among the first nmin basis functions are not
c      accounted for.
c      the rotations among the last nb-nmax basis functions are not
c      accounted for.
c.......................................................................
      integer nb, nb1, nb2, nmin, nmax, maxao
      integer jbig(nb)
      real *8 big(nb),f(nb1),v(nb2)
c
      integer i, k, ir
      integer ii, j, jj, i1, ib, ia, iaa, ibb, jaa, jbb
      integer iear, iebr, ieaa, ieab, it, kq, ir1
      real *8 sd, t, dif, t2x2, t2x25, cx, sx, tt
c
      real *8 root2, c1, c2, c3, c4, c5, c6
      data root2 /0.707106781186548d0/
      data c1,c2,c3,c4,c5,c6/1.0d-12,1.0d-12,4.0d-16,2.0d-16,
     +                        8.0d-9,3.0d-6/
c
      if (nb.eq.1) then
         v(1) = 1.0d0
         return
      end if
      ii = 0
c.......................................................................
c      loop over rows (i) of triangular matrix
c.......................................................................
      do i = 1 , nb
         big(i) = 0.00d0
         jbig(i) = 0
         if (i.ge.nmin .and. i.ne.1) then
            j = min0(i-1,nmax)
c.......................................................................
c      loop over columns (k) of triangular matrix to determine
c      largest off-diagonal elements in row(i).
c.......................................................................
            do k = 1 , j
               if (abs(big(i)).lt.abs(f(ii+k))) then
                  big(i) = f(ii+k)
                  jbig(i) = k
               end if
            enddo
         end if
         ii = ii + i
      enddo
 40   sd = 1.050d0
c.......................................................................
c      find smallest diagonal element and corresponding largest
c      off-diagonal element.
c.......................................................................
      jj = 0
      do j = 1 , nb
         jj = jj + j
         sd = min(sd,abs(f(jj)))
      enddo
      sd = max(sd,c6)*c2
      t = 0.0d0
      i1 = max0(2,nmin)
      do i = i1 , nb
         if (t.lt.abs(big(i))) then
            t = abs(big(i))
            ib = i
         end if
      enddo
c.......................................................................
c      test for convergence, then determine rotation.
c.......................................................................
      ia = jbig(ib)
      if (t.lt.sd) then
         return
      else
         iaa = ia*(ia-1)/2
         ibb = ib*(ib-1)/2
         jaa = (ia-1)*maxao
         jbb = (ib-1)*maxao
         dif = f(iaa+ia) - f(ibb+ib)
         if (abs(dif).gt.c3*t) then
            t2x2 = big(ib)/dif
            t2x25 = t2x2*t2x2
            if (t2x25.le.c4) then
               cx = 1.0d0
               sx = t2x2
            else if (t2x25.le.c5) then
               sx = t2x2*(1.0d0-1.5d0*t2x25)
               cx = 1.0d0 - 0.5d0*t2x25
            else if (t2x25.gt.c6) then
               t = 0.25d0/sqrt(0.25d0+t2x25)
               cx = sqrt(0.5d0+t)
               sx = dsign(sqrt(0.5d0-t),t2x2)
            else
               cx = 1.0d0 + t2x25*(t2x25*1.375d0-0.5d0)
               sx = t2x2*(1.00d0+t2x25*(t2x25*3.875d0-1.5d0))
            end if
         else
            sx = root2
            cx = root2
         end if
         iear = iaa + 1
         iebr = ibb + 1
         do 90 ir = 1 , nb
            t = f(iear)*sx
            f(iear) = f(iear)*cx + f(iebr)*sx
            f(iebr) = t - f(iebr)*cx
            if (ir.lt.ia) then
               iear = iear + 1
               iebr = iebr + 1
               go to 90
            else if (ir.eq.ia) then
               tt = f(iebr)
               ieaa = iear
               ieab = iebr
               f(iebr) = big(ib)
               iear = iear + ir - 1
               if (jbig(ir).ne.0) go to 70
               iear = iear + 1
               iebr = iebr + 1
               go to 90
            else
               t = f(iear)
               it = ia
               iear = iear + ir - 1
               if (ir.lt.ib) then
               else if (ir.eq.ib) then
                  f(ieaa) = f(ieaa)*cx + f(ieab)*sx
                  f(ieab) = tt*cx + f(iebr)*sx
                  f(iebr) = tt*sx - f(iebr)*cx
                  iebr = iebr + ir - 1
                  go to 70
               else
                  if (abs(t).lt.abs(f(iebr))) then
                     if (ib.le.nmax) then
                        t = f(iebr)
                        it = ib
                     end if
                  end if
                  iebr = iebr + ir - 1
               end if
            end if
            if (abs(t).ge.abs(big(ir))) then
               big(ir) = t
               jbig(ir) = it
               iear = iear + 1
               iebr = iebr + 1
               go to 90
            else if (ia.ne.jbig(ir) .and. ib.ne.jbig(ir)) then
               iear = iear + 1
               iebr = iebr + 1
               go to 90
            end if
 70         kq = iear - ir - ia + 1
            big(ir) = 0.00d0
            ir1 = min0(ir-1,nmax)
            do i = 1 , ir1
               k = kq + i
               if (abs(big(ir)).lt.abs(f(k))) then
                  big(ir) = f(k)
                  jbig(ir) = i
               end if
            enddo
            iear = iear + 1
            iebr = iebr + 1
 90      continue
         do i = 1 , maxao
            t = v(jbb+i)*sx
            v(jbb+i) = v(jaa+i)*sx - v(jbb+i)*cx
            v(jaa+i) = v(jaa+i)*cx + t
         enddo
         go to 40
      end if
      end
      subroutine oeigd(fc, s, u, t, h)
      implicit none
      real *8 fc(*), s(*), u(*), t(*), h(*)
c.......................................................................
c     one-electron integrals. general.
c.......................................................................
c
      integer nb, no
      parameter (nb=100, no=50)
      integer nsym, nbas, ncsh, nosh, nccup, nsht, nitscf, n1, nqn
      integer nconv, nbc, nbct, nstrt, ifcont
      real *8 zn, zeta, eps, cin, vir, energ, ajmn, damp, cont
      common /cguess/nsym,nbas(5),ncsh(5),nosh(5),nccup(6),nsht,nitscf,
     + zn,n1(6),nqn(nb),zeta(nb),eps(no),cin,vir,energ,ajmn(24),damp,
     + nconv,nbc(5),cont(nb),nbct,nstrt(nb),ifcont
c
      integer l, i, j
      integer nbas1, k, nstep
      real *8 ufacl, expfac, zp, zq, zpq, term1, ppq, rpq
c
      ufacl = sqrt(8.0d0/3.1415926536d0)
      nstep = 0
      k = 0
      do l = 1 , nsym
         nbas1 = nbas(l)
         expfac = l + 0.5d0
         do i = 1 , nbas1
            do j = 1 , i
               k = k + 1
               zp = zeta(nstep+i)
               zq = zeta(nstep+j)
               zpq = 0.5d0*(zp+zq)
               term1 = sqrt(zpq)
               ppq = zp*zq/zpq
               rpq = sqrt(ppq/zpq)
               s(k) = rpq**expfac
               fc(k) = s(k)
               u(k) = ufacl*s(k)*term1
               t(k) = expfac*s(k)*ppq
               h(k) = t(k) - zn*u(k)
            enddo
         enddo
         nstep = nstep + nbas1
         ufacl = ufacl*2.0d0*l/(2.0d0*l+1.0d0)
      enddo
      return
      end
      subroutine orderd(amat,nrow,ncol,imemb,nblock,ind,vec,iflag)
      implicit none
c.......................................................................
c     this routine sorts a set of column vectors in amat(*,*) according
c     to increasing values in vec(*). care is taken that the output orde
c     of the vectors is as close to the input order as possible.
c.......................................................................
      integer nrow, ncol, nblock, iflag
      integer ind(*), imemb(*)
      real *8  amat(nrow,ncol), vec(*)
c.......................................................................
c     set tolerance for test, then determine for each element how
c     many smaller elements vec(*) contains.
c.......................................................................
      real *8 tol, test, scra
      integer i, j
      integer icount, indi, itest, im1, ilow, index
c
      tol = 1.0d-10
      do i = 1 , ncol
         test = vec(i) - tol
         indi = 1
         do j = 1 , ncol
            if (vec(j).lt.test) indi = indi + 1
         enddo
         ind(i) = indi
      enddo
c.......................................................................
c
c     if desired,scan ind(*) to determine the number of different values
c     in vec(*) and the number of elements of each value.
c.......................................................................
      if (iflag.le.99) then
         do i = 1 , ncol
            imemb(i) = 0
         enddo
         do i = 1 , ncol
            indi = ind(i)
            imemb(indi) = imemb(indi) + 1
         enddo
         icount = 0
         do i = 1 , ncol
            if (imemb(i).ne.0) then
               icount = icount + 1
               imemb(icount) = imemb(i)
            end if
         enddo
         nblock = icount
      end if
c.......................................................................
c
c     establish order in degeneracies of the ordering vector.
c.......................................................................
      do i = 2 , ncol
         itest = ind(i)
         im1 = i - 1
         do j = 1 , im1
            if (ind(j).eq.itest) itest = itest + 1
         enddo
         ind(i) = itest
      enddo
c.......................................................................
c
c     ind(*) contains ordering indices for amat(*,*). sort following
c     input order as far as this is correct.
c.......................................................................
      ilow = 1
 90   do i = 1 , ncol
         if (i.ne.ind(i)) go to 110
      enddo
      go to 130
c.......................................................................
c
c     input order wrong. swap present vector into correct col.
c.......................................................................
 110  index = ind(i)
      do j = 1 , nrow
         scra = amat(j,i)
         amat(j,i) = amat(j,index)
         amat(j,index) = scra
      enddo
      scra = vec(i)
      vec(i) = vec(index)
      vec(index) = scra
      ind(i) = ind(index)
      ind(index) = index
      if (ind(i).ne.i) go to 110
c.......................................................................
c
c     amat(*,*) is ordered through i. go back to checking order.
c.......................................................................
      ilow = i + 1
      if (ilow.lt.ncol) go to 90
 130  return
      end
      subroutine outpud(copn,cc,ntest,iwr)
      implicit none
c
      real *8 copn(*), cc(*)
      integer ntest, iwr
c
      integer nb, no
      parameter (nb=100, no=50)
      integer nsym, nbas, ncsh, nosh, nccup, nsht, nitscf, n1, nqn
      integer nconv, nbc, nbct, nstrt, ifcont
      real *8 zn, zeta, eps, cin, vir, energ, ajmn, damp, cont
      common /cguess/nsym,nbas(5),ncsh(5),nosh(5),nccup(6),nsht,nitscf,
     + zn,n1(6),nqn(nb),zeta(nb),eps(no),cin,vir,energ,ajmn(24),damp,
     + nconv,nbc(5),cont(nb),nbct,nstrt(nb),ifcont
c
      integer i, j, k
      integer nbc1, naddr, noddr, jfirst, jlast
c
      if (ntest.gt.0) write (iwr,6010) nitscf , energ , cin , vir
      if (ntest.gt.0) write (iwr,6030)
      nbc1 = nbc(1)
      do i = 2 , nsym
         nbc1 = max(nbc1,nbc(i))
      enddo
      naddr = 0
      noddr = 0
      do i = 1 , nsym
         do j = 1 , ncsh(i) + nosh(i)
            do k = 1 , nbc(i)
               naddr = naddr + 1
               noddr = noddr + 1
               copn(noddr) = cc(naddr)
            enddo
            if (nbc(i).lt.nbc1) then
               do k = nbc(i) + 1 , nbc1
                  noddr = noddr + 1
                  copn(noddr) = 0.0d0
               enddo
            end if
         enddo
         naddr = naddr + nbc(i)*(nbc(i)-ncsh(i)-nosh(i))
      enddo
      jfirst = 1
 70   jlast = min(jfirst+7,nsht)
      if (ntest.gt.0) then
         write (iwr,6020) (eps(j),j=jfirst,jlast)
         write (iwr,6030)
         do i = 1 , nbc1
            write (iwr,6040) (copn(i+(j-1)*nbc1),j=jfirst,jlast)
         enddo
      end if
      if (jlast.eq.nsht) return
      jfirst = jfirst + 8
      if (ntest.gt.0) write (iwr,6030)
      go to 70
 6010 format (/,8x,'final scf results at iteration',i4,/,8x,
     +        'total hf energy',4x,'kinetic energy',4x,'virial theorem',
     +        /4x,3(e19.10),//,8x,'orbital energies and eigenvectors')
 6020 format (/,2x,8(2x,f12.5),1x)
 6030 format (' ')
 6040 format (2x,8f14.6)
      end


#ifndef ADRIANS_CRAP

      subroutine pdfded(k,kdim,d,dhelp,factor,dmult,lm,nbci,iiloc)
      implicit none
c.......................................................................
c
c     routine for distributing atomic densities to the molecular
c     density matrix. note that the number of orbitals differ in
c     the molecular and atomic case for d and f orbitals. transformat-
c     ion matrices are provided in dmult(*,*). to work out these tables
c     real atomic orbitals are needed. for f functions these are:
c              sqrt(1/60)*(2zzz-3zyy-3zxx)
c              sqrt(1/40)*(4zzy-yyy-xxy)
c              sqrt(1/40)*(4zzx-xxx-xyy)
c                    xyz
c              sqrt(1/4)*(xxz-yyz)
c              sqrt(1/24)*(3xxy-yyy)
c              sqrt(1/24)*(3xyy-xxx)
c     normalization of primitives is given by (xyz:xyz)=1, (xxy:xxy)=3
c     (xxx:xxx)=15.
c
c.......................................................................
c..
      integer k, kdim, lm, nbci
      real *8 d(*),dhelp(*),dmult(kdim,kdim)
      real *8 factor
      integer iiloc(nbci)
c
      integer l, na, m, nb
      integer lmsave, nbrang, noff
      real *8 delem
c     
      integer i, j, itria2
      itria2(i,j,na) = (max0(i,j)+na-1)*(max0(i,j)+na-2)/2 + min0(i,j)
c..
c..
      do l = 1 , nbci
         lmsave = lm
         do na = 1 , kdim
            lm = lmsave
            do m = 1 , l
               noff = itria2(iiloc(m),iiloc(l),na) - 1
               lm = lm + 1
               delem = dhelp(lm)*factor
               nbrang = kdim
               if (m.eq.l) nbrang = na
               do nb = 1 , nbrang
                  noff = noff + 1
                  d(noff) = delem*dmult(na,nb)
               enddo
            enddo
         enddo
      enddo
c..
      return
      end
#endif /* ADRIANS_CRAP */




      implicit none
c.......................................................................
c
c     make s**(-1/2) for transformation to orthonormal basis.
c.......................................................................
      integer n
      real *8 s(*), v(n,n)
c
      real *8  scr1(50), scr2(50)
      real *8 hlp
      integer icount, nn, nnd
      integer i, j, k
c
      icount = 0
      nnd = n*(n+1)/2
      nn = n*n
      if (n.gt.50) call errquit('dimensioning error in shalfd',0,
     &       UNKNOWN_ERR)
      do i = 1 , n
         do j = 1 , i
            v(i,j) = 0.0d0
            v(j,i) = 0.0d0
         enddo
         v(i,i) = 1.0d0
      enddo
      call jacod(s,v,n,nnd,nn,1,n,scr1,scr2,n)
      icount = 1
      do i = 1 , n
         scr1(i) = 1.0d0/sqrt(s(icount))
         icount = icount + i + 1
      enddo
      icount = 0
      do i = 1 , n
         do j = 1 , i
            icount = icount + 1
            hlp = 0.0d0
            do k = 1 , n
               hlp = hlp + v(i,k)*scr1(k)*v(j,k)
            enddo
            s(icount) = hlp
         enddo
      enddo
      icount = 0
      do i = 1 , n
         do j = 1 , i
            icount = icount + 1
            v(j,i) = s(icount)
            v(i,j) = s(icount)
         enddo
      enddo
      return
      end
      implicit none
      integer nbci, ncshi, noshi
      real *8 ss(*), c(nbci,nbci)
      real *8  a(100)
c.......................................................................
c
c     this routine provides a set of schmidt
c     orthogonalized start vectors.
c
c.......................................................................
      integer i, j, k, l, m
      integer nshti, ixx, klo, khi, indxlm, jm1
      real *8 sum
c
c     inline indexing function for triangular matrices.
c
      integer index
      index(i,j) = max0(i,j)*(max0(i,j)-1)/2 + min0(i,j)
c
c.......................................................................
c     uneducated guess of trial vectors.
c.......................................................................
c
      nshti = ncshi + noshi
      if (nshti.eq.0) return
      if (nshti.gt.nbci) call errquit(
     +  'more atomic shells than basis functions in atomic startup',0,
     &       BASIS_ERR)
      ixx = nbci/nshti
      khi = 0
      do j = 1 , nshti
         klo = khi + 1
         khi = khi + ixx
         do k = klo , khi
            c(k,j) = 1.0d0
         enddo
      enddo
c.......................................................................
c
c     orthogonalize.
c
c.......................................................................
      do j = 1 , nshti
c.......................................................................
c
c     take scalar products with preceding vectors of same symm.
c     first do a(*) = ss(*)*c(*,j).
c
c.......................................................................
         do 50 l = 1 , nbci
            sum = 0.0d0
            do 40 m = 1 , nbci
               indxlm = index(l,m)
               sum = sum + ss(indxlm)*c(m,j)
 40         continue
            a(l) = sum
 50      continue
c.......................................................................
c
c     if first vector of symmetry, normalize directly.
c
c.......................................................................
         if (j.ne.1) then
c.......................................................................
c
c     c(*,k)*a(*)
c
c.......................................................................
            jm1 = j - 1
            do k = 1 , jm1
               sum = 0.0d0
               do l = 1 , nbci
                  sum = sum + c(l,k)*a(l)
               enddo
c.......................................................................
c
c     multiply c(*,k) by the scalar product and subtract from c(*,j)
c
c.......................................................................
               do l = 1 , nbci
                  c(l,j) = c(l,j) - c(l,k)*sum
               enddo
            enddo
c.......................................................................
c
c     c(*,j) is orthogonal to all preceding vectors. normalize.
c
c.......................................................................
            do l = 1 , nbci
               sum = 0.0d0
               do m = 1 , nbci
                  indxlm = index(l,m)
                  sum = sum + ss(indxlm)*c(m,j)
               enddo
               a(l) = sum
            enddo
         end if
         sum = 0.0d0
         do l = 1 , nbci
            sum = sum + c(l,j)*a(l)
         enddo
         sum = sqrt(sum)
         do l = 1 , nbci
            c(l,j) = c(l,j)/sum
         enddo
      enddo
      return
      end
      subroutine teigd(pcap,qcap,u,t,dt,dos)
      implicit none
      logical klnemn
      real *8  pcap(*),qcap(*),u(*),t(*),dos(*),dt(*)
c.......................................................................
c
c     two-electron integral routine for s,p,d, and f functions.
c.......................................................................
      integer nb, no
      parameter (nb=100, no=50)
      integer nsym, nbas, ncsh, nosh, nccup, nsht, nitscf, n1, nqn
      integer nconv, nbc, nbct, nstrt, ifcont
      real *8 zn, zeta, eps, cin, vir, energ, ajmn, damp, cont
      common /cguess/nsym,nbas(5),ncsh(5),nosh(5),nccup(6),nsht,nitscf,
     + zn,n1(6),nqn(nb),zeta(nb),eps(no),cin,vir,energ,ajmn(24),damp,
     + nconv,nbc(5),cont(nb),nbct,nstrt(nb),ifcont
c
      integer i, k, l, im, m, n
      integer j, nstep1, nstep2, kin, kmx, kl, mmx, mmxp, mn
      integer nmx, ntest, min
      logical open
c
      real *8 twopow(14), pifac(14)
      real *8 pi, on6, on15, on70, on35, pot, potn, factkl
      real *8 prfac1, prfac2, prfac3, prfac4
      real *8 zp, zq, zpq, zr, zpr, zqr, zs, zps, zrs, zqs, zpqrs
      real *8 zpqrs2, zprzqs, zpszqr
      real *8 xterm, factmn, term
      real *8 xfac1, xfac2, xfac3, xfac11, xfac21, xfsum
      real *8 x0, y0, pj, qj, y1, y2, y3, x2, x4, y01, y02
      real *8 y21, y22, y4, y5, y6
c
c.......................................................................
c     angular factors for exchange integrals. obtained as sum of squares
c     of slater coefficients c(kappa;l1,m1;l2,m2) divided by
c     2*(2*l1+1)*(2*l2+1) for any kappa, l1, and l2.
c.......................................................................
      real *8 ss0, sp1, pp0, pp2, sd2, pd1, pd3, dd0, dd2, dd4
      real *8 sf3, pf2, pf4, df1, df3, df5, ff0, ff2, ff4, ff6
      data ss0,sp1,pp0,pp2,sd2,pd1,pd3,dd0,dd2,dd4,
     x     sf3,pf2,pf4,df1,df3,df5,ff0,ff2,ff4,ff6
     x/ .50000000000d+00, .16666666667d+00, .16666666667d+00,
     x  .66666666667d-01, .10000000000d+00, .66666666667d-01,
     x  .42857142857d-01, .10000000000d+00, .28571428571d-01,
     x  .28571428571d-01, .71428571429d-01, .42857142857d-01,
     x  .31746031746d-01, .42857142857d-01, .19047619048d-01,
     x  .21645021645d-01, .71428571429d-01, .19047619048d-01,
     x  .12987012987d-01, .16650016650d-01/
      real *8 a, b
      real *8 f0pol, f2pol, df1pol, df3pol
      f0pol(a,b) = 3*(16*a**6+104*a**5*b+286*a**4*b**2+429*(a*b)
     +             **3+286*a**2*b**4+104*a*b**5+16*b**6)
      f2pol(a,b) = 8*a**4 + 52*a**3*b + 143*(a*b)**2 + 52*a*b**3 +
     +             8*b**4
      df1pol(a,b) = 8*a**4 + 44*a**3*b + 99*(a*b)**2 + 44*a*b**3 +
     +              8*b**4
      df3pol(a,b) = 2*a**2 + 11*a*b + 2*b**2
c.......................................................................
c     two-electron integral routine for lcgo atom scf.
c     restricted to principal quantum numbers 1,2 and 3 for respectively
c     s,p, and d orbitals.
c.......................................................................
      pi = 3.14159265d0
      on6 = 1.0d0/6.0d0
      on15 = 1.0d0/15.d0
      on70 = 1.0d0/70.d0
      on35 = 2*on70
      pifac(1) = sqrt(3.14159265d0)
      twopow(1) = 1
      do i = 2 , 14
         twopow(i) = twopow(i-1)*0.5d0
         pifac(i) = pifac(i-1)*(2*i-1)
      enddo
c.......................................................................
c
c     this part sets up the coefficients lambda,p,q and mu,r,s.
c.......................................................................
      j = 0
      nstep1 = 0
      kmx = 0
      factkl = 1
      kl = 0
      pot = 0.0d0
      potn = 0.0d0
      cin = 0.0d0
      do i = 1 , nsym
         prfac1 = twopow(i+1)*factkl
         kin = kmx + 1
         kmx = kin + nbas(i) - 1
         do k = kin , kmx
            zp = zeta(k)
            do l = kin , k
               kl = kl + 1
               pcap(kl) = 0.0d0
               qcap(kl) = 0.0d0
               zq = zeta(l)
               zpq = zp + zq
               prfac2 = prfac1*u(kl)
               xfac1 = prfac2*zpq**i*pifac(i)
               nstep2 = 0
               mmx = 0
               factmn = 1.0d0
               mn = 0
               do im = 1 , i
                  open = (nosh(i).ne.0 .and. nosh(im).ne.0)
                  prfac3 = prfac2*pifac(im)*twopow(im)*factmn
                  xfac2 = xfac1*factmn*twopow(im+1)
                  min = mmx + 1
                  mmx = min - 1 + nbas(im)
                  mmxp = mmx
                  if (im.eq.i) mmxp = k
                  do m = min , mmxp
                     zr = zeta(m)
                     zpr = zp + zr
                     zqr = zq + zr
                     nmx = l
                     if (m.lt.k) nmx = m
                     do n = min , nmx
                        mn = mn + 1
                        klnemn = (kl.ne.mn)
                        j = j + 1
c.......................................................................
c
c     j is the number label of the matrix elements to be calculated
c     i=lambda+1,k=p,l=q,im=mu+1,m=r,n=s
c.......................................................................
                        zs = zeta(n)
                        zrs = zr + zs
                        zqs = zq + zs
                        zps = zp + zs
                        zpqrs = zpq + zrs
                        zpqrs2 = 2*zpqrs**2
                        zprzqs = zpr*zqs
                        zpszqr = zps*zqr
                        xterm = (1.0d0/sqrt(zpqrs))**(2*(i+im)-3)
                        prfac4 = prfac3*u(mn)*xterm
                        xfac3 = xfac2*u(mn)*xterm
                        xfac11 = xfac3*(zrs/zprzqs)**im
                        xfac21 = xfac3*(zrs/zpszqr)**im
                        xfsum = xfac11 + xfac21
                        ntest = i*(i-1)/2 + im
                        go to (30,40,50,60,70,80,90,100,110,120,140) ,
     +                         ntest
c.......................................................................
c
c     i=1,im=1,(ss)-loop. x0=j0(ss),y0=k0(ss)
c.......................................................................
 30                     x0 = prfac4
                        y0 = xfsum
                        pj = x0 - y0*ss0
                        qj = -ajmn(1)*y0
                        go to 130
c.......................................................................
c
c     i=2,im=1,(sp)-loop. x0=j0(sp),y1=k1(sp)
c.......................................................................
 40                     x0 = prfac4*(3*zpq+2*zrs)
                        y1 = xfsum
                        pj = x0 - y1*sp1
                        qj = -ajmn(2)*y1
                        go to 130
c.......................................................................
c
c     i=2,im=2,(pp)-loop. x0=j0(pp),y0=k0(pp),y2=k2(pp)
c.......................................................................
 50                     x0 = prfac4*(zpqrs2+zpq*zrs)
                        y0 = xfsum*zpqrs2
                        xfsum = xfac11*zpr*zqs + xfac21*zps*zqr
                        y0 = y0 + xfsum
                        y2 = xfsum*5
                        pj = x0 - y0*pp0 - y2*pp2
                        qj = -(ajmn(3)*y0+ajmn(4)*y2)
                        go to 130
c.......................................................................
c
c     i=3,im=1,(sd)-loop. x0=j0(sd),y2=k2(sd)
c.......................................................................
 60                     x0 = prfac4*(15*zpq**2+20*zpq*zrs+8*zrs**2)
                        y2 = xfsum
                        pj = x0 - y2*sd2
                        qj = -ajmn(5)*y2
                        go to 130
c.......................................................................
c
c     i=3,im=2,(pd)-loop. x0=j0(pd),y1=k1(pd),y3=k3(pd),x2=j2(pd)
c.......................................................................
 70                     x0 = prfac4*(10*zpq**3+35*zpq**2*zrs+
     +                       28*zpq*zrs**2+8*zrs**3)
                        y1 = xfsum*zpqrs2
                        xfsum = xfac11*zpr*zqs + xfac21*zps*zqr
                        y1 = y1 + 3*xfsum
                        y3 = 7*xfsum
                        pj = x0 - y1*pd1 - y3*pd3
                        qj = 0.d0
                        if (open) then
                           x2 = prfac4*5*zpq*zrs*(7*zpq+2*zrs)
                           qj = ajmn(21)*x2 - (ajmn(6)*y1+ajmn(7)*y3)
                        end if
                        go to 130
c.......................................................................
c
c     i=3,im=3,(dd)-loop. x0=j0(dd),y0=k0(dd),y2=k2(dd),y4=k4(dd)
c.......................................................................
 80                     zprzqs = zpr*zqs
                        zpszqr = zps*zqr
                        x0 = prfac4*((zpqrs2+zpq*zrs)
     +                       *zpqrs2*2+7*(zpq*zrs)**2)
                        y01 = xfac11*((zpqrs2+zprzqs)
     +                        *zpqrs2*2+7*zprzqs**2)
                        y02 = xfac21*((zpqrs2+zpszqr)
     +                        *zpqrs2*2+7*zpszqr**2)
                        y0 = y01 + y02
                        xfac11 = xfac11*7*zprzqs
                        xfac21 = xfac21*7*zpszqr
                        y21 = xfac11*(zpqrs2+5*zprzqs)
                        y22 = xfac21*(zpqrs2+5*zpszqr)
                        y2 = y21 + y22
                        y4 = (xfac11*zprzqs+xfac21*zpszqr)*9
                        pj = x0 - y0*dd0 - (y2+y4)*dd2
                        qj = -ajmn(8)*y0 - ajmn(9)*y2 - ajmn(10)*y4
                        go to 130
c.......................................................................
c
c     i=4,im=1,(sf)-loop. x0=j0(sf),y3=k3(sf)
c.......................................................................
 90                     x0 = prfac4*(105*zpq**3+210*zpq**2*zrs+
     +                       168*zpq*zrs**2+48*zrs**3)
                        y3 = xfsum
                        pj = x0 - y3*sf3
                        qj = -ajmn(11)*y3
                        go to 130
c.......................................................................
c
c     i=4,im=2,(pf)-loop. x0=j0(pf),y2=k2(pf),y4=k4(pf),x2=j2(pf)
c.......................................................................
 100                    x0 = prfac4*(70*zpq**4+315*zpq**3*zrs+
     +                       378*(zpq*zrs)**2+216*zpq*zrs**3+48*zrs**4)
c.......................................................................
c                       y2 = xfsum*zpqrs2
c.......................................................................
                        y2 = xfac11*(2*zpr**2+9*zpr*zqs+2*zqs**2)
     +                       + xfac21*(2*zps**2+9*zps*zqr+2*zqr**2)
                        xfsum = xfac11*zpr*zqs + xfac21*zps*zqr
c.......................................................................
c                       y2 = y2 + 5*xfsum
c.......................................................................
                        y4 = 9*xfsum
                        pj = x0 - y2*pf2 - y4*pf4
                        qj = 0.0d0
                        if (open) then
                           x2 = prfac4*5*zpq*zrs*(63*zpq**2+26*zpq*zrs+
     +                          8*zrs**2)
                           qj = ajmn(22)*x2 - ajmn(12)*y2 - ajmn(13)*y4
                        end if
                        go to 130
c.......................................................................
c
c     i=4,im=3,(df)-loop. x0=j0(df),y1=k1(df),y3=k3(df),y5=k5(df)
c                         x2=j2(df),x4=j4(df).
c.......................................................................
 110                    x0 = prfac4*(56*zpq**5+308*zpq**4*zrs+
     +                       693*zpq**3*zrs**2+594*zpq**2*zrs**3+
     +                       264*zpq*zrs**4+48*zrs**5)
                        y1 = xfac11*df1pol(zpr,zqs)
     +                       + xfac21*df1pol(zps,zqr)
                        xfac11 = 9*zpr*zqs*xfac11
                        xfac21 = 9*zps*zqr*xfac21
                        y3 = xfac11*df3pol(zpr,zqs)
     +                       + xfac21*df3pol(zps,zqr)
                        y5 = 11*(xfac11*zpr*zqs+xfac21*zps*zqr)
                        pj = x0 - y1*df1 - y3*df3 - y5*df5
                        qj = 0.0d0
                        if (open) then
                           prfac4 = prfac4*7*zpq*zrs
                           x2 = prfac4*(18*zpq**3+99*zpq**2*zrs+
     +                          44*zpq*zrs**2+8*zrs**3)
                           x4 = 9*prfac4*(11*zpq+2*zrs)*zpq*zrs
                           qj = x2*ajmn(23) + x4*ajmn(24) - y1*ajmn(14)
     +                          - y3*ajmn(15) - y5*ajmn(16)
                        end if
                        go to 130
c.......................................................................
c
c     i=4,im=4,(ff)-loop. x0=j0(ff),y0=k0(ff),y2=k2(ff),y4=k4(ff)
c              y6=k6(ff)
c.......................................................................
 120                    x0 = prfac4*f0pol(zpq,zrs)
                        y0 = xfac11*f0pol(zpr,zqs)
     +                       + xfac21*f0pol(zps,zqr)
                        xfac11 = xfac11*zpr*zqs*9
                        xfac21 = xfac21*zps*zqr*9
                        y2 = xfac11*f2pol(zpr,zqs)
     +                       + xfac21*f2pol(zps,zqr)
                        xfac11 = xfac11*zpr*zqs*11
                        xfac21 = xfac21*zps*zqr*11
                        y4 = xfac11*(2*zpr**2+13*zpr*zqs+2*zqs**2)
     +                       + xfac21*(2*zps**2+13*zps*zqr+2*zqr**2)
                        y6 = 13*(xfac11*zpr*zqs+xfac21*zps*zqr)
                        pj = x0 - y0*ff0 - y2*ff2 - y4*ff4 - y6*ff6
                        qj = -y0*ajmn(17) - y2*ajmn(18) - y4*ajmn(19)
     +                       - y6*ajmn(20)
 130                    pcap(kl) = pcap(kl) + pj*dt(mn)
                        if (klnemn) pcap(mn) = pcap(mn) + pj*dt(kl)
                        term = dt(kl)*pj*dt(mn)
                        if (open) then
                           qcap(kl) = qcap(kl) + qj*dos(mn)
                           if (klnemn) qcap(mn) = qcap(mn) + qj*dos(kl)
                           term = term - dos(kl)*qj*dos(mn)
                        end if
                        if (.not.klnemn) term = term*0.5d0
                        pot = pot + term
 140                 continue
                     enddo
                  enddo
                  factmn = factmn/im
               enddo
               potn = potn + u(kl)*dt(kl)
               cin = cin + t(kl)*dt(kl)
            enddo
         enddo
         factkl = factkl/i
      enddo
      pot = pot - zn*potn
      energ = cin + pot
      vir = pot/cin
      return
      end
      subroutine tracd(c, cc, nsqt, nsym, nbas, ncsh, nosh, nbc,
     +      nstrt, cont)
      implicit none
c.......................................................................
c
c     transform vectors from contr. to primitive basis functions.
c.......................................................................
      real *8 c(*),cc(*), cont(*)
      integer nsqt, nsym, nbas(*), ncsh(*), nosh(*), nbc(*), nstrt(*)
c
      integer i, l, n, k, j
      integer k1, k2, ii
      integer nstep, nstep1, nstep2, nbc1, nbasl, nsh1
c
      do i = 1 , nsqt
         c(i) = 0.0d0
      enddo
c.......................................................................
c
c     cc(i,j)  contains vectors over cont. functions.
c              i runs over functions, j runs over orbitals
c.......................................................................
      nstep = 0
      nstep1 = 0
      nstep2 = 0
      do l = 1 , nsym
         nbc1 = nbc(l)
         nbasl = nbas(l)
         nsh1 = ncsh(l) + nosh(l)
         ii = 1
         do n = 1 , nbc1
            k1 = nstrt(nstep+n)
            k2 = nstrt(nstep+n+1) - 1
            do k = k1 , k2
               do j = 1 , nsh1
                  c(nstep2+ii+(j-1)*nbasl) = cc(nstep1+n+(j-1)*nbc1)
     +               *cont(k)
               enddo
               ii = ii + 1
            enddo
         enddo
         nstep = nstep + nbc1
         nstep1 = nstep1 + nbc1**2
         nstep2 = nstep2 + nbasl**2
      enddo
      return
      end
      subroutine trafsd(nsym,nbas,ndim,a,nbc,cont,nstrt,ffc)
      implicit none
c.......................................................................
c     transform matrix a
c     from prim. to cont. basis.
c.......................................................................
      real *8 ffc(*), a(*), cont(*)
      integer nbas(*), nbc(*), nstrt(*)
      integer nsym, ndim
c
      real *8 sumc
      integer i, j, m, n, l
      integer mnstep, ijstep, k, ijbas, mnbas, nbc1, ij, jj
      integer m1, m2, n0, n2
c
      do i = 1 , ndim
         ffc(i) = a(i)
      enddo
      mnstep = 0
      ijstep = 0
      k = 1
      ijbas = 0
      mnbas = 0
      do  l = 1 , nsym
         nbc1 = nbc(l)
         do m = 1 , nbc1
            do n = 1 , m
               m1 = nstrt(mnbas+m)
               n0 = nstrt(mnbas+n)
               m2 = nstrt(mnbas+m+1) - 1
               n2 = nstrt(mnbas+n+1) - 1
               sumc = 0.0d0
               do i = m1 , m2
                  ij = ijstep + (i-ijbas-1)*(i-ijbas)/2
                  if (m.eq.n) then
                     n2 = i
                  end if
                  do j = n0 , n2
                     jj = j - ijbas
                     if (m.ne.n) then
                        sumc = sumc + cont(i)*cont(j)*ffc(ij+jj)
                     else if (i.ne.j) then
                        sumc = sumc + 2.0d0*cont(i)*cont(j)*ffc(ij+jj)
                     else
                        sumc = sumc + cont(i)*cont(j)*ffc(ij+jj)
                     end if
                  enddo
               enddo
               a(k) = sumc
               k = k + 1
            enddo
         enddo
         mnstep = mnstep + nbc(l)*(nbc(l)+1)/2
         ijstep = ijstep + nbas(l)*(nbas(l)+1)/2
         mnbas = mnbas + nbc(l)
         ijbas = ijbas + nbas(l)
      enddo
      return
      end
      subroutine tramad(a,b,c,mdima,mdim,scr)
      implicit none
c.......................................................................
c
c     this routine tranforms a to (b+)ab, where a is a lower
c     triangular symmetric matrix, and b is a square matrix.
c     the transformed matrix is returned in a.
c.......................................................................
      integer mdima, mdim
      real *8 a(mdima), b(mdim,mdim), c(mdima), scr(mdim)
c
      integer i, j, k, l, maxjl
      real *8 sum
c
      do i = 1 , mdim
c.......................................................................
c
c     generate i'th column of ab.
c.......................................................................
         do j = 1 , mdim
            sum = 0.0d0
            do l = 1 , mdim
               maxjl = max(j,l)
               sum = sum + a(maxjl*(maxjl-3)/2 + j + l)*b(l,i)
            enddo
            scr(j) = sum
         enddo
c.......................................................................
c
c     multiply this by rows of b+
c.......................................................................
         do j = 1 , i
            sum = 0.0d0
            do k = 1 , mdim
               sum = sum + scr(k)*b(k,j)
            enddo
            c(i*(i-1)/2+j) = sum
         enddo
      enddo
c.......................................................................
c
c     transfer to a for return.
c.......................................................................
      do i = 1 , mdima
         a(i) = c(i)
      enddo
      return
      end
      subroutine writel(p,newbas,oprint)
      implicit none
c
      logical oprint
      real *8 p(*)
      integer newbas
c
      integer ind, i, j
c
      integer m5, m, n
c
      ind(i,j)=max0(i,j)*(max0(i,j)-1)/2+min0(i,j)
c
      m5=12
      if(oprint) m5=8
      m=1
      n=m5
   6  if(newbas.lt.m)return
      if(n.gt.newbas)n=newbas
      if(.not.oprint)write(6,200)(i,i=m,n)
      if(oprint)write(6,100)(i,i=m,n)
100   format(//3x,8i14)
200   format(//12i9)
      write(6,101)
101   format(/)
      do 1 j=1,newbas
      if(oprint)write(6,102)j,(p(ind(i,j)),i=m,n)
      if(.not.oprint)write(6,202)j,(p(ind(i,j)),i=m,n)
 1    continue
102   format(7x,i3,8f14.7)
202   format(1x,i3,12f9.4)
      m=m+m5
      n=n+m5
      goto 6
      end
      subroutine square(r,a,mrowr,n)
      implicit none
      integer mrowr, n
      real *8  r(*),a(*)
c
c... convert triangle a to square r
c
      integer i,j
      integer iii,jj,jjj,k
      iii=0
      jjj=1
      k=1
      do  i=1,n
         jj=jjj
         do   j=1,i
           r(iii+j)=a(k)
           r(jj)=a(k)
           k=k+1
           jj=jj+mrowr
         enddo
         iii=iii+mrowr
         jjj=jjj+1
      enddo
      return
      end

       subroutine guess_dens(rtdb,basis,g_dens)
       implicit none
#include "mafdecls.h"
#include "global.h"
#include "rtdb_fort.h"
c
c
       integer rtdb,basis,g_dens
c
c
       integer nshell,memscr
       integer natoms,nbf,nprim,maxprim,max_l,max_sh_bf,max_at_bf
       integer l_scr,k_scr
       logical status
c
c
c
       call gto_info(basis,natoms,nshell,nbf,nprim,maxprim,
     $               max_l,max_sh_bf,max_at_bf)

       call ga_zero(g_dens)
C     ********* Please change to maximum primitives **************
C     ********* Careful because there are common blocks **********
C     ********* in atomic SCF that are dimensioned to ************
C     *********************** 100*********************************
       nprim = 100
       call guess_mem(nprim,memscr)

#ifdef DEBUG
       if (ga_nodeid().eq.0) then
         print*,'Max num of basis funs on atom:',max_at_bf
         print*,'Maximum primitives:',nprim
         print*,'Scratch space:',memscr
         call flush_output()
       endif
#endif

       status = ma_push_get(MT_DBL,memscr,'guess scratch',l_scr,k_scr)
       call denat(nprim,natoms,1,dbl_mb(k_scr),memscr,g_dens)
       status = ma_pop_stack(l_scr)

       return
       end




c
c (atw) Modified to calculate max. memory for atom blocks
c       only. 7/3/94
c
      subroutine guess_mem(max_prim,memscr)
c
      implicit none
c
      integer max_prim,memscr
c
c..   calculate memory requirements for atomic guess routines
c..
      integer nb, no, ntr, nsq
      integer i10, ipcap, iqcap, ifc, ifo, is, iu, it
      integer ih, idc, idos, idt, idold, iss, ic, icopn, ismin
      integer iqmin, itransf, icc
c..
c..    core partitioning
c..

c
c
      nb = max_prim
      no = 50
      ntr = nb*(nb+1)/2
      nsq = nb * nb
c
c
      i10 = 1
      ipcap = i10 + ntr
      iqcap = ipcap + ntr
      ifc = iqcap + ntr
      ifo = ifc + ntr
      is = ifo + ntr
      iu = is + ntr
      it = iu + ntr
      ih = it + ntr
      idc = ih + ntr
      idos = idc + ntr
      idt = idos + ntr
      idold = idt + ntr
      iss = idold + ntr
      ic = iss + ntr
c
      icopn = ic + nsq
      ismin = icopn + nsq
      iqmin = ismin + nb * no
      itransf = iqmin + nb * no
      icc = itransf + nsq
      memscr = icc + nsq - 1
c
c     NOTE: later inserts required for pseudopotentials
c
      end





      subroutine denat(maxbf_at,nat,iprint,q,memq,g_dens)
      implicit none
#include "mafdecls.h"
#include "global.h"
c
      integer maxbf_at,nat,g_dens
      integer iprint,memq
c
c..   get starting vectors from superposition of atomic densities
c..
c..   routines involved are (all present in this order) :
c..   denat  : general control routine
c..   datoms : translate orbital info, call atomscf , gather d-matrix
c..   atomd,tracd,trafsd,cmergd,oeigd,teigd,densid,denmad, ..
c..   .. hamild,outpud,shalfd,atcond,starcd,creded,pdfded, ..
c..   .. jacod,orderd,tramad
c..   oeigd has been changed to pick up the 1-elec ints
c..   atcond has been changed to allow for effective nuclear charge
c..   creded/pdfded have been adapted to yield directly a d-matrix
crz   xpsnld: implemented for use of non local pseudo potentials
c..
c...    start all types after one cycle closed shell in routine denscf
c
      real *8 q(memq)
c
      integer iread, iwrite
      common/iofile/ iread,iwrite
c
      logical oprinv
      integer l2
      integer nb, no, ntr, nsq
      integer i10, ipcap, iqcap, ifc, ifo, is, iu, it
      integer ih, idc, idos, idt, idold, iss, ic, icopn, ismin
      integer iqmin, itransf, icc, last
c
c..
c..    core partitioning
c..
      oprinv = iprint.eq.2
      l2 = (maxbf_at*(maxbf_at+1))/2
c
c     allow for maximum of 100 bfns on any given atom
c
      nb = maxbf_at
      no = 50
      ntr = nb*(nb+1)/2
      nsq = nb * nb
c
c
      i10 = 1
      ipcap = i10 + l2
      iqcap = ipcap + ntr
      ifc = iqcap + ntr
      ifo = ifc + ntr
      is = ifo + ntr
      iu = is + ntr
      it = iu + ntr
      ih = it + ntr
      idc = ih + ntr
      idos = idc + ntr
      idt = idos + ntr
      idold = idt + ntr
      iss = idold + ntr
      ic = iss + ntr
c
      icopn = ic + nsq
      ismin = icopn + nsq
      iqmin = ismin + nb * no
      itransf = iqmin + nb * no
      icc = itransf + nsq
      last = icc + nsq
c
c     NOTE: later inserts required for pseudopotentials
c
c..     get core
c
c..    to supply to the atomic scf routines to cover
c..    pseudo-potential calculations
c..     d in  dens    /  workspace in i10 (exact fit)
c      pseudo corrections in i15 .. NOW REMOVED
c..    **** not symmetry adapted ****
c..
c..
c..   now loop over the atoms / do atomic scf and gather d-matrix
c..
      call datoms(q(i10),g_dens,oprinv,
     +    q(ipcap), q(iqcap), q(ifc), q(ifo), q(is), q(iu), 
     +    q(it), q(ih), q(idc), q(idos), q(idt), q(idold), q(iss) ,
     +    q(ic), q(icopn), q(ismin), q(iqmin), q(itransf), q(icc) ,
     +    nb) 
c
c..   print if requested
c
      if (oprinv) then
        if (ga_nodeid().eq.0) write (iwrite,6020)
        call ga_print(g_dens)
      endif
c
      return
 6020 format (//30x,28('-'),/,30x,'   initial guess density   ',/,30x,
     +        28('-')//)
      end










      subroutine datoms(hatom,g_dens,oprin,
     + pcap, qcap, fc, fo, s, u, t, h, dc, dos, dt, dold, ss,
     + cvec, copn, smin, qmin, transf, cc, nbb)
c
      implicit none
#include "mafdecls.h"
#include "global.h"
      logical osatod
c
c...   subroutine to coordinate atom-scf calls and d-matrix gathering
c...   for atomic startup
c...   h,t  : full h-matrix and t-matrix to supply to atom
c...   d    : full density matrix as return parameter
c...
c...   **note** data is transferred to atom directly via common/cguess/
c
c
      integer nbb,g_dens
      real *8 hatom(*)
      real *8 pcap(*), qcap(*), fc(*), fo(*), s(*), u(*), t(*)
      real *8 h(*), dc(*), dos(*), dt(*), dold(*), ss(*)
      real *8 cvec(*), copn(*), smin(nbb,*), qmin(nbb,*),transf(*),cc(*)
      logical oprin
c
c...   commons where information comes from :
c
#include "int.h"
c
      integer iread, iwrite
      common /iofile/ iread,iwrite
      integer kmin, kmax, nuct
      common /iguess/ kmin(mxshell), kmax(mxshell), nuct(mxnat)
c
c...   common where info goes to :
c
      integer nb, no
      parameter (nb=100, no=50)
      integer nsym, nbas, ncsh, nosh, nccup, nsht, nitscf
      integer nqn, n1, nconv, nbc, nbct, nstrt, ifcont
      real *8 zn, zeta, eps, cin, vir, energ, ajmn, damp, cont
      common /cguess/nsym,nbas(5),ncsh(5),nosh(5),nccup(6),nsht,nitscf,
     + zn,n1(6),nqn(nb),zeta(nb),eps(no),cin,vir,energ,ajmn(24),damp,
     + nconv,nbc(5),cont(nb),nbct,nstrt(nb),ifcont
c
      integer ic(6,nb),iiloc(nb,6),iisch(nb,6)
      logical odone(mxnat)
c
      integer i, ii, ispdf, iat, j, k, iorb
      integer kk, mini, maxi
      integer kkzc, kh, isymax, is, if
      integer icount_atom
      real *8 pi32, toteng, ee, fac, znps
c
c..    we need xy for d and xyz for f in gathering h-ints
c..    so set proper offsets in ioffhp (see do 140)
c
      integer ioffhp(4)
      data ioffhp/0,0,3,9/
c
      integer maxtyp
      parameter (maxtyp = 6)
      integer minf(maxtyp),maxf(maxtyp)
      data minf  / 1, 2,  5, 11, 21, 1 /
      data maxf  / 1, 4, 10, 20, 35, 4 /
c
c..
      data pi32/5.56832799683170d0/
c
      do i = 1,nshell
        ii = ktype(i)
        kmin(i) = minf(ii)
        kmax(i) = maxf(ii)
      enddo
c
      toteng = 0.0d0
      do i = 1 , nat
         nuct(i) = 1
         odone(i) = .false.
      enddo
c
c...  loop over atoms like adapt does
c
      do iat = 1 , nat
c
c ... eliminate ghost/dummies/point charges
c
         if (nuct(iat).ne.1) then
            odone(iat) = .true.
            go to 110
c..
c..   check if we have already treated this one or if it is of same
c..   type as the one we just did
         else if (iat.gt.1) then
            if (odone(iat)) then
               odone(iat) = .true.
               go to 110
            else if (osatod(iat,ic,iiloc,iisch,nbb)) then
               go to 100
            end if
         end if
c
c...  gather  shell / symmetry info
c
         do i = 1 , 4
            nbc(i) = 0
         enddo
c
c   nbc  # shell's / symmetry
c   iisch  contains index of shell
c   iiloc  contains position of starting ao of shell in "real" world
c   translate to 1 (s)
c
         do ii = 1 , nshell
            i = katom(ii)
            if (i.eq.iat) then
               mini = kmin(ii)
               maxi = kmax(ii)
               kk = ktype(ii)
               if (kk.eq.6) kk = 2
               do iorb = mini , maxi
                  if (iorb.eq.1) then
                     nbc(1) = nbc(1) + 1
                     iisch(nbc(1),1) = ii
                     iiloc(nbc(1),1) = kloc(ii)
                  else if (iorb.eq.2 .or. iorb.eq.5 .or. iorb.eq.11)
     +                     then
c..  translate to 2 (p) 3(d) or  4(f)
                     ispdf = kk
                     nbc(ispdf) = nbc(ispdf) + 1
                     iisch(nbc(ispdf),ispdf) = ii
                     iiloc(nbc(ispdf),ispdf) = kloc(ii) + iorb - mini
                  end if
               enddo
            end if
         enddo
c..
c..     we gathered symmetry/shell info ; now get the real thing
c..
         kkzc = 0
         kh = 0
         isymax = 0
         do ispdf = 1 , 4
c..      nbas = total # primitives for this symmetry
            nbas(ispdf) = 0
            if (nbc(ispdf).gt.0) isymax = ispdf
            do j = 1 , nbc(ispdf)
               ii = iisch(j,ispdf)
               is = kstart(ii)
               if = is + kng(ii) - 1
c..      ic = # number of primitives /contracted /symmetry
               ic(ispdf,j) = kng(ii)
               nbas(ispdf) = nbas(ispdf) + kng(ii)
c..      gather the primitives / watch the subtle use of 2-dim cspd
               do k = is , if
                  kkzc = kkzc + 1
                  zeta(kkzc) = ex(k)
                  cont(kkzc) = cspd(k,ispdf)
c...     get contraction coeff's as we are used to
                  ee = 2*zeta(kkzc)
                  fac = pi32/(ee*sqrt(ee))
                  if (ispdf.eq.2) then
                     fac = 0.5d0*fac/ee
                  else if (ispdf.eq.3) then
                     fac = 0.75d0*fac/(ee*ee)
                  else if (ispdf.eq.4) then
                     fac = 1.875d0*fac/(ee**3)
                  end if
                  cont(kkzc) = cont(kkzc)*sqrt(fac)
               enddo
c...     in the pseudopotential case, we would be involved in
c...     gathering  the h integrals for the contracted ao's
c...     so that they are added in at the right time (in atomd)
c...     use proper offset to use pure d or f functions (ioffhp)
c...     only the comments remain ...
               do k = 1 , j
                  kh = kh + 1
                  hatom(kh) = 0.0d0
               enddo
c...
            enddo
         enddo
c..
c..     all prepared call  atomd
c..     zeta,cont,nbas,nbc,nbas,ic,zn are passed via cguess
c..     energ and the density matrix dt are received via cguess
c..     note zn is the real nuclear charge / znps is the effective charg
c..
         zn = zan(iat)
         znps = zan(iat)
c
         call atomd(.false.,iwrite,znps,ic,isymax,hatom,
     +        pcap, qcap, fc, fo, s, u, t, h, dc, dos, dt, dold, ss,
     +        cvec, copn, smin, qmin, transf, cc, nbb)
c..    
 100     toteng = toteng + energ
c..    now add density-matrix to the molecular d-matrix
c..    
         call creded(g_dens,dt,iiloc,nbb)
c..    
         odone(iat) = .true.
 110  continue
      enddo
c..
      if (ga_nodeid().eq.0) then
        write (iwrite,6010) toteng
        call flush_output()
       endif
c..
      return
 6010 format(/,1x,'Superposition of Atomic Density Guess',/,
     $     1x,'-----------------------------------------------',/,
     $     1x,'Sum of atomic energies: ',6x,f17.8)
      end







      subroutine creded(g_dens,dt,iiloc,nbb)
c
      implicit none
#include "global.h"
c
c..   routine to merge atomic density matrix into molecular one
c..   is called straight after atom, so all info is still in
c..   common /cguess/ : i.e. dt,nbc
c
      integer nbb,g_dens
      real *8 dt(*)
      integer iiloc(nbb,6)
c
      integer nb, no, nsym, nbas, ncsh, nosh, nccup, nsht, nitscf, n1
      integer nqn, nconv, nbc, nbct, nstrt, ifcont
      real *8 zn, zeta, eps, cin, vir, energ, ajmn, damp, cont
      parameter (nb=100, no=50)
      common /cguess/nsym,nbas(5),ncsh(5),nosh(5),nccup(6),nsht,nitscf,
     + zn,n1(6),nqn(nb),zeta(nb),eps(no),cin,vir,energ,ajmn(24),damp,
     + nconv,nbc(5),cont(nb),nbct,nstrt(nb),ifcont
c..
      real *8 dmult(145)
c..
crz   order of d's and f's in GAMESS is completely different
crz   from MOLECULE !!
c
c     dmult consists of :
c     nothing for s;
c      p functions (1 line)
c      d functions (next 4 lines)
c      f functions (last lines)
c      -0.670820393 = -0.3*sqrt(5) (used for f)
c
      data dmult/ 1.0d0, 3*0.0d0, 1.0d0, 3*0.0d0, 1.0d0,
     x  1.0d0, -0.5d0, -0.5d0, 3*0.0d0,
     x -0.5d0,  1.0d0, -0.5d0, 3*0.0d0,
     x -0.5d0, -0.5d0,  1.0d0, 3*0.0d0,
     x  3*0.0d0, 1.0d0, 6*0.0d0, 1.0d0, 6*0.0d0, 1.0d0,
     x  1.0d0,   4*0.0d0, -0.670820393d0, 0.0d0,-0.670820393d0, 2*0.0d0,
     x  0.0d0,1.0d0,0.0d0,-0.670820393d0, 4*0.0d0,-0.670820393d0, 0.0d0,
     x2*0.0d0,1.0d0,0.0d0,-0.670820393d0, 0.0d0,-0.670820393d0, 3*0.0d0,
     x   0.0d0, -0.670820393d0,  0.0d0,  1.2d0, 4*0.0d0, -0.3d0,  0.0d0,
     x 2*0.0d0, -0.670820393d0,  0.0d0,  1.2d0,  0.0d0, -0.3d0, 3*0.0d0,
     x  -0.670820393d0,         4*0.0d0, 1.2d0,  0.0d0, -0.3d0, 2*0.0d0,
     x 2*0.0d0, -0.670820393d0,  0.0d0, -0.3d0,  0.0d0,  1.2d0, 3*0.0d0,
     x  -0.670820393d0,     4*0.0d0,    -0.3d0,  0.0d0,  1.2d0, 2*0.0d0,
     x   0.0d0, -0.670820393d0, 0.0d0, -0.3d0, 4*0.0d0,  1.2d0,   0.0d0,
     x 9*0.0d0,  1.0d0/
c.......................................................................
c         among the variables used are:
c
c              nsym       - highest l-quantum no. used in atomic calc.
c              dt         - atomic density matrix
c              d          - area for final molecular density matrix.
c.......................................................................
c
      integer k, l, m
      integer lm, nbci, kdim, kmone, kpoint
      integer ll,mm
      real *8 factor
c..
c..    triangle statement function
c..
c..
      lm = 0
      do k = 1 , nsym
         nbci = nbc(k)
         if (k.eq.1) then
c.......................................................................
c
c       s-orbitals, simple distribution of matrix elements.
c
c.......................................................................
            do l = 1 , nbci
               do m = 1 , l
                  ll = iiloc(l,1)
                  mm = iiloc(m,1)
                  lm = lm + 1
                  call ga_put(g_dens,ll,ll,mm,mm,dt(lm),1)
                  call ga_put(g_dens,mm,mm,ll,ll,dt(lm),1)
               enddo
            enddo
         else if (k.le.4) then
            kdim = k*(k+1)/2
            kmone = k - 1
            kpoint = kmone*(kmone+1)*(((6*kmone+24)*kmone+26)*kmone+4)
     +               /120
            factor = 1.d0/(k+k-1)
            call pdfded(k,kdim,g_dens,dt,factor,dmult(kpoint),lm,nbci,
     +                  iiloc(1,k))
         end if
      enddo
c..
      return
      end



      subroutine pdfded(k,kdim,g_dens,dhelp,factor,dmult,lm,nbci,iiloc)
      implicit none
c.......................................................................
c
c     routine for distributing atomic densities to the molecular
c     density matrix. note that the number of orbitals differ in
c     the molecular and atomic case for d and f orbitals. transformat-
c     ion matrices are provided in dmult(*,*). to work out these tables
c     real atomic orbitals are needed. for f functions these are:
c              sqrt(1/60)*(2zzz-3zyy-3zxx)
c              sqrt(1/40)*(4zzy-yyy-xxy)
c              sqrt(1/40)*(4zzx-xxx-xyy)
c                    xyz
c              sqrt(1/4)*(xxz-yyz)
c              sqrt(1/24)*(3xxy-yyy)
c              sqrt(1/24)*(3xyy-xxx)
c     normalization of primitives is given by (xyz:xyz)=1, (xxy:xxy)=3
c     (xxx:xxx)=15.
c
c.......................................................................
c..
      integer g_dens
      integer k, kdim, lm, nbci
      real *8 dhelp(*),dmult(kdim,kdim)
      real *8 factor
      integer iiloc(nbci)
c
      integer l, na, m, nb
      integer ll,mm
      integer lmsave, nbrang
      real *8 delem,xx
c     
c..
c..
      do l = 1 , nbci
         lmsave = lm
         do na = 1 , kdim
            lm = lmsave
            do m = 1 , l
               lm = lm + 1
               delem = dhelp(lm)*factor
               nbrang = kdim
               if (m.eq.l) nbrang = na
               do nb = 1 , nbrang
                  xx = delem*dmult(na,nb)
                  ll = iiloc(l)+nb-1
                  mm = iiloc(m)+na-1
                  call ga_put(g_dens,ll,ll,mm,mm,xx,1)
                  call ga_put(g_dens,mm,mm,ll,ll,xx,1)
               enddo
            enddo
         enddo
      enddo
c..
      return
      end

